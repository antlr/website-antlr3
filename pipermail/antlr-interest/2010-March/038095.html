<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] FailedPredicateException leads to infinite	loop - bug in the Lexer?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20FailedPredicateException%20leads%20to%20infinite%0A%09loop%20-%20bug%20in%20the%20Lexer%3F&In-Reply-To=%3Cd559651d5db9bc4da1eb311ba2eae3d4%40temporal-wave.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="038093.html">
   <LINK REL="Next"  HREF="038096.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] FailedPredicateException leads to infinite	loop - bug in the Lexer?</H1>
    <B>Jim Idle</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20FailedPredicateException%20leads%20to%20infinite%0A%09loop%20-%20bug%20in%20the%20Lexer%3F&In-Reply-To=%3Cd559651d5db9bc4da1eb311ba2eae3d4%40temporal-wave.com%3E"
       TITLE="[antlr-interest] FailedPredicateException leads to infinite	loop - bug in the Lexer?">jimi at temporal-wave.com
       </A><BR>
    <I>Tue Mar 30 11:34:42 PDT 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="038093.html">[antlr-interest] FailedPredicateException leads to infinite loop - bug in the Lexer?
</A></li>
        <LI>Next message: <A HREF="038096.html">[antlr-interest] FailedPredicateException leads to infinite	loop - bug in the Lexer?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#38095">[ date ]</a>
              <a href="thread.html#38095">[ thread ]</a>
              <a href="subject.html#38095">[ subject ]</a>
              <a href="author.html#38095">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Actually, I did not dispute that the hang was a bug, but stated that it was really somewhat irrelevant because the bug is in your predicate specifications. Lexers should not really be throwing exceptions but should be coded to deal with any input in a controlled manner. Your code was looked at, but as there has been no release since you reported your bug, I am not sure what you expect just at the moment.

Of course, while debugging, it would be better if the lexer did not go in to an endless loop; that is an oversight and we should do something about that (in the next release - but I have not recently even had time to raise the JIRA). But you should not be relying on exceptions and recovery in the lexer; especially not in something that is commercial. Fix your predicates/rules/etc and cater for the error cases; your error messages will be commensurately better and your users will thank you in kind.

Jim



&gt;<i> -----Original Message-----
</I>&gt;<i> From: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-bounces at antlr.org</A> [mailto:antlr-interest-
</I>&gt;<i> <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">bounces at antlr.org</A>] On Behalf Of Ron Hunter-Duvar
</I>&gt;<i> Sent: Tuesday, March 30, 2010 10:58 AM
</I>&gt;<i> To: Cliff Hudson
</I>&gt;<i> Cc: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>
</I>&gt;<i> Subject: Re: [antlr-interest] FailedPredicateException leads to
</I>&gt;<i> infinite loop - bug in the Lexer?
</I>&gt;<i> 
</I>&gt;<i> The message title was: &quot;Antlr Bug: Failed semantic predicate in lexer
</I>&gt;<i> triggers endless loop&quot;
</I>&gt;<i> 
</I>&gt;<i> Basically, the bug is in the nextToken() method in Antlr's Lexer class.
</I>&gt;<i> If a NoViableAlt exception is thrown, the method calls the recover
</I>&gt;<i> method, which consumes one character before trying again. But if any
</I>&gt;<i> other RecognitionException (including a FailedPredicateException) is
</I>&gt;<i> thrown, it doesn't call recover, it just reports the exception and
</I>&gt;<i> loops
</I>&gt;<i> back to try again at the same point, which of course results in the
</I>&gt;<i> same
</I>&gt;<i> exception, because nothing has changed. I just added a recover call to
</I>&gt;<i> the second catch block, and it solved the problem.
</I>&gt;<i> 
</I>&gt;<i> As I mentioned, I did this as an overriding method in a custom
</I>&gt;<i> superclass. You could also fix it directly in the Antlr source, but
</I>&gt;<i> then
</I>&gt;<i> you'd have to rebuild Antlr.
</I>&gt;<i> 
</I>&gt;<i> I'm not sure this ever got reported as an official bug. Jim Idle
</I>&gt;<i> disputed whether it was an Antlr bug. I sent proof, but not sure it was
</I>&gt;<i> even looked at. Unfortunately, because of the (quite reasonable) legal
</I>&gt;<i> agreement required to submit bug reports, and the fact that I'm doing
</I>&gt;<i> this as an employee, I can't submit bug reports or fixes until I get
</I>&gt;<i> approval to do so (seems ridiculous at first glance, but in today's
</I>&gt;<i> legal climate I can't take chances).
</I>&gt;<i> 
</I>&gt;<i> Ron
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Cliff Hudson wrote:
</I>&gt;<i> &gt; I've been all over the archives, but perhaps my search terms were
</I>&gt;<i> &gt; inadequate.  I'll look again with that date in mind.  Thanks.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; On Tue, Mar 30, 2010 at 8:11 AM, Ron Hunter-Duvar
</I>&gt;<i> &gt; &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">ron.hunter-duvar at oracle.com</A> &lt;mailto:<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">ron.hunter-duvar at oracle.com</A>&gt;&gt;
</I>&gt;<i> wrote:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     Hi Cliff,
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     I reported this same problem on February 10 on this list. It's an
</I>&gt;<i> &gt;     Antlr bug, and my emails on it had the work around (which
</I>&gt;<i> requires
</I>&gt;<i> &gt;     you to implement a custom superclass if you haven't already). If
</I>&gt;<i> &gt;     you search the list archives you should be able to find it.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     Ron
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     Cliff Hudson wrote:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;         I have been trying to work through an issue with an infinite
</I>&gt;<i> &gt;         loop caused
</I>&gt;<i> &gt;         when no tokens can be matched because a predicate has failed
</I>&gt;<i> &gt;         its test.  The
</I>&gt;<i> &gt;         problem appears to be in the Lexer.NextToken() (looking at
</I>&gt;<i> &gt;         CSharp2 sources)
</I>&gt;<i> &gt;         method, which I have copied here for reference:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;                        /// &lt;summary&gt;
</I>&gt;<i> &gt;                        /// Return a token from this source; i.e.,
</I>&gt;<i> &gt;         Match a token on the char stream.
</I>&gt;<i> &gt;                        /// &lt;/summary&gt;
</I>&gt;<i> &gt;                        public virtual IToken NextToken()
</I>&gt;<i> &gt;                        {
</I>&gt;<i> &gt;                                while (true)
</I>&gt;<i> &gt;                                {
</I>&gt;<i> &gt;                                        state.token = null;
</I>&gt;<i> &gt;                                        state.channel =
</I>&gt;<i> &gt;         Token.DEFAULT_CHANNEL;
</I>&gt;<i> &gt;                                        state.tokenStartCharIndex =
</I>&gt;<i> &gt;         input.Index;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;          state.tokenStartCharPositionInLine =
</I>&gt;<i> input.CharPositionInLine;
</I>&gt;<i> &gt;                                        state.tokenStartLine =
</I>&gt;<i> input.Line;
</I>&gt;<i> &gt;                                        state.text = null;
</I>&gt;<i> &gt;                                        if (input.LA(1) ==
</I>&gt;<i> &gt;         (int)CharStreamConstants.EOF)
</I>&gt;<i> &gt;                                        {
</I>&gt;<i> &gt;                                                return
</I>&gt;<i> Token.EOF_TOKEN;
</I>&gt;<i> &gt;                                        }
</I>&gt;<i> &gt;                                        try
</I>&gt;<i> &gt;                                        {
</I>&gt;<i> &gt;                                                mTokens();
</I>&gt;<i> &gt;                                                if (state.token ==
</I>&gt;<i> null)
</I>&gt;<i> &gt;                                                {
</I>&gt;<i> &gt;                                                        Emit();
</I>&gt;<i> &gt;                                                }
</I>&gt;<i> &gt;                                                else if (state.token
</I>&gt;<i> ==
</I>&gt;<i> &gt;         Token.SKIP_TOKEN)
</I>&gt;<i> &gt;                                                {
</I>&gt;<i> &gt;                                                        continue;
</I>&gt;<i> &gt;                                                }
</I>&gt;<i> &gt;                                                return state.token;
</I>&gt;<i> &gt;                                        }
</I>&gt;<i> &gt;                                        catch (NoViableAltException
</I>&gt;<i> nva) {
</I>&gt;<i> &gt;                                                ReportError(nva);
</I>&gt;<i> &gt;                                                Recover(nva); // throw
</I>&gt;<i> &gt;         out current char and try again
</I>&gt;<i> &gt;                                        }
</I>&gt;<i> &gt;                                        catch (RecognitionException
</I>&gt;<i> re) {
</I>&gt;<i> &gt;                                                ReportError(re);
</I>&gt;<i> &gt;                                                // Match() routine has
</I>&gt;<i> &gt;         already called Recover()
</I>&gt;<i> &gt;                                        }
</I>&gt;<i> &gt;                                }
</I>&gt;<i> &gt;                        }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;         Note the RecognitionException clause.  This is the clause
</I>&gt;<i> &gt;         which will
</I>&gt;<i> &gt;         catch the FailedPredicateException().  Unfortunately, because
</I>&gt;<i> the
</I>&gt;<i> &gt;         FailedPredicateException gets thrown just before Match()
</I>&gt;<i> &gt;         occurs in the
</I>&gt;<i> &gt;         rule, Recover will *not* have been called by the rule or its
</I>&gt;<i> &gt;         callees,
</I>&gt;<i> &gt;         and therefore the DFA will continue to try processing the
</I>&gt;<i> same
</I>&gt;<i> &gt;         token.
</I>&gt;<i> &gt;         It would appear that there should instead be a specific
</I>&gt;<i> &gt;         FailedPredicateException clause which does the same thing as
</I>&gt;<i> the
</I>&gt;<i> &gt;         NoViableAltException clause.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;         I have seen two other people ask questions about this error,
</I>&gt;<i> &gt;         and in
</I>&gt;<i> &gt;         neither case was a suitable response given.  Has this bug
</I>&gt;<i> been
</I>&gt;<i> &gt;         fixed
</I>&gt;<i> &gt;         in non-released builds?  Can someone give me an up-or-down on
</I>&gt;<i> &gt;         whether
</I>&gt;<i> &gt;         this is a correct and appropriate fix?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;         Thanks.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;         - Cliff
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;         List: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">http://www.antlr.org/mailman/listinfo/antlr-interest</A>
</I>&gt;<i> &gt;         Unsubscribe:
</I>&gt;<i> &gt;         <A HREF="http://www.antlr.org/mailman/options/antlr-interest/your-">http://www.antlr.org/mailman/options/antlr-interest/your-</A>
</I>&gt;<i> email-address
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     --
</I>&gt;<i> &gt;     Ron Hunter-Duvar | Software Developer V | 403-272-6580
</I>&gt;<i> &gt;     Oracle Service Engineering
</I>&gt;<i> &gt;     Gulf Canada Square 401 - 9th Avenue S.W., Calgary, AB, Canada T2P
</I>&gt;<i> 3C5
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     All opinions expressed here are mine, and do not necessarily
</I>&gt;<i> represent
</I>&gt;<i> &gt;     those of my employer.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> 
</I>&gt;<i> --
</I>&gt;<i> Ron Hunter-Duvar | Software Developer V | 403-272-6580
</I>&gt;<i> Oracle Service Engineering
</I>&gt;<i> Gulf Canada Square 401 - 9th Avenue S.W., Calgary, AB, Canada T2P 3C5
</I>&gt;<i> 
</I>&gt;<i> All opinions expressed here are mine, and do not necessarily represent
</I>&gt;<i> those of my employer.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> List: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">http://www.antlr.org/mailman/listinfo/antlr-interest</A>
</I>&gt;<i> Unsubscribe: <A HREF="http://www.antlr.org/mailman/options/antlr-interest/your-">http://www.antlr.org/mailman/options/antlr-interest/your-</A>
</I>&gt;<i> email-address
</I>


</PRE>








<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="038093.html">[antlr-interest] FailedPredicateException leads to infinite loop - bug in the Lexer?
</A></li>
	<LI>Next message: <A HREF="038096.html">[antlr-interest] FailedPredicateException leads to infinite	loop - bug in the Lexer?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#38095">[ date ]</a>
              <a href="thread.html#38095">[ thread ]</a>
              <a href="subject.html#38095">[ subject ]</a>
              <a href="author.html#38095">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
