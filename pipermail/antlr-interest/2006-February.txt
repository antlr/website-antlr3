From open.zone at virgin.net  Wed Feb  1 02:40:56 2006
From: open.zone at virgin.net (Micheal J)
Date: Wed Feb  1 02:24:33 2006
Subject: Please unlink [antlr-interest],
	[antlr-dev] and [stringtemplate-interest]
Message-ID: <00f001c6271b$fc62a000$6b02a8c0@hercules>

It seems prefectly reasonable to me that anyone that can find the ANTLR list
and website can also find ANTLR3 and StringTemplate lists and websites if
they wished.

If an author feels a particular message if relevant to multiple communities,
the author can chose to post to both communities.

Cheers,

Micheal

From mail at martin-probst.com  Wed Feb  1 02:26:23 2006
From: mail at martin-probst.com (Martin Probst)
Date: Wed Feb  1 02:26:35 2006
Subject: [antlr-interest] help requested for selective whitespace
In-Reply-To: <1138762449.7476.8.camel@localhost>
References: <1138585445.7879.16.camel@localhost>
	<1138762449.7476.8.camel@localhost>
Message-ID: <1138789583.10153.10.camel@localhost.localdomain>

> a b c
> 
> to be valid, but not:
> 
> abc

Might this help?

NOTE: (a..f | A..F)* { if ($getText().length() > 1) throw ...; }

Martin

From mail at martin-probst.com  Wed Feb  1 02:49:36 2006
From: mail at martin-probst.com (Martin Probst)
Date: Wed Feb  1 02:49:41 2006
Subject: [antlr-interest] help requested for selective whitespace
In-Reply-To: <1138789583.10153.10.camel@localhost.localdomain>
References: <1138585445.7879.16.camel@localhost>
	<1138762449.7476.8.camel@localhost>
	<1138789583.10153.10.camel@localhost.localdomain>
Message-ID: <1138790976.10153.11.camel@localhost.localdomain>

Make that a '+':

> NOTE: (a..f | A..F)+ { if ($getText().length() > 1) throw ...; }

Martin

From sunjigang1965 at yahoo.com.cn  Wed Feb  1 06:30:24 2006
From: sunjigang1965 at yahoo.com.cn (=?gb2312?q?=CB=EF=BC=CD=B8=D5?=)
Date: Wed Feb  1 06:30:41 2006
Subject: [antlr-interest] a silly question?
Message-ID: <20060201143024.19508.qmail@web15708.mail.cnb.yahoo.com>

 
  If I make extension with boolean type data to Terence's sample programmar on http://www.cs.usfca.edu/~parrt/course/652/lectures/antlr.html
   
  class ExprParser extends Parser;
   
  expr:   mexpr ((PLUS|MINUS) mexpr)*
      ;      
   
  mexpr      
      :   atom (STAR atom)*
      ;    
   
  atom:   INT 
  |   LPAREN expr RPAREN 
  ;
    
  adding atomic data "true" and "false", logical operator AND and OR,
   
  class ExprParser extends Parser;
   
  expr:   mexpr ((PLUS|MINUS|OR) mexpr)*
      ;      
   
  mexpr      
  :   atom (STAR|AND atom)*
      ;    
   
  atom:   INT 
  |   LPAREN expr RPAREN 
  | "true"
  |"false"
  ;
   
   
  What modification should be added to the interpreter 
   
  class ExprParser extends Parser;
   
  expr returns [int value=0]
  {int x;}
      :   value=mexpr
          ( PLUS x=mexpr  {value += x;}
          | MINUS x=mexpr {value -= x;} 
          )*
      ;
   
  mexpr returns [int value=0]
  {int x;}
      :   value=atom ( STAR x=atom {value *= x;} )*
      ;
   
  atom returns [int value=0]
      :   i:INT {value=Integer.parseInt(i.getText());}
      |   LPAREN value=expr RPAREN
      ;
   
  to make generated method atom, mexpr and expr polymorphic? That is 
   
  class ExprParser extends Parser;
   
  expr returns [? value=?]
  {int x;bool y;}
      :   value=mexpr
          ( PLUS x=mexpr  {value += x;}
          | MINUS x=mexpr {value -= x;} 
          |OR y=mepr {value=value or y;})*
      ;
   
  mexpr returns [? value=?]
  {int x;bool y;}
      :   value=atom ( STAR x=atom {value *= x;}
      |AND y=atom {value=y && value;} )*
      ;
   
  atom returns [? value=?]
      :   i:INT {value=Integer.parseInt(i.getText());}
      |   LPAREN value=expr RPAREN
      |"true" {value=true;}
      |"false" {value=false;}
      ;
   
   
  I did a lot of search on the Internet  but have not got the answer. 
   
  Jigang 
   

		
---------------------------------
 œÎ≥…Œ™∑Î–°∏’°¢≥¬ø≠∏Ë°¢’≈ºÕ÷–»˝¥Ûµº—›µƒ÷˜Ω«¬£ø
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060201/ae8bcb01/attachment-0001.html
From gevik at xs4all.nl  Wed Feb  1 07:00:51 2006
From: gevik at xs4all.nl (Gevik Babakhani)
Date: Wed Feb  1 07:00:56 2006
Subject: [antlr-interest] Zero based  $i$ index in StringTemplate 
Message-ID: <12561.195.169.118.236.1138806051.squirrel@webmail.xs4all.nl>

I was wondering why we are using 1 based index in
ASTExpr.java, function applyListOfAlternatingTemplates at
argumentContext.put(DEFAULT_INDEX_VARIABLE_NAME, new Integer(i+1));

isn't 0 based index "new Integer(i)" better?

Regards,
Gevik.





From cb at acrolinx.com  Wed Feb  1 07:36:22 2006
From: cb at acrolinx.com (Christian Bering)
Date: Wed Feb  1 07:36:30 2006
Subject: [antlr-interest] ANTLR error in Ant for multiple super grammars
Message-ID: <81E919FE86CB74479838F35608448C6B195F6F@elba.acrolinx.local>

Hi everybody,

 

we are experiencing a strange problem when calling ANTLR from Ant for a
grammar which has two super grammars. The scenario is as follows: We
have three grammars Grammar1, 2, 3, where Grammar1 and Grammar2 reside
at path1, and Grammar3 resides at path2. Grammar2 inherits from
Grammar1, and Grammar3 inherits from both Grammar1 and Grammar2. The
following code snippet should IMHO (and AFAIK according to
<http://ant.apache.org/manual/OptionalTasks/antlr.html>) render this
situation:

 

-- 8< ---

            <target name="antlr" description="Compiles the ANTLR grammar
files">

                        <antlr target="path1/Grammar1.g">

                                   <classpath>

                                               <pathelement
location="${utils.root.dir}/lib/antlr.jar"/>

                                               <pathelement
path="${classpath}"/>                                          

                                   </classpath>

                        </antlr>

                        <antlr target="path1/Grammar2.g"

                                   glib="path1/Grammar1.g">

                                   <classpath>

                                               <pathelement
location="${utils.root.dir}/lib/antlr.jar"/>

                                               <pathelement
path="${classpath}"/>                                          

                                   </classpath>

                        </antlr>

                        <antlr target="path2/Grammar3.g"

 
glib="path1/Grammar1.g;path1/Grammar2.g">

                                   <classpath>

                                               <pathelement
location="${utils.root.dir}/lib/antlr.jar"/>

                <pathelement path="${classpath}"/>

                                   </classpath>

                        </antlr>

            </target>

-- 8< ---

 

Of the three <antlr target ...> blocks, the first two (for Grammar1 and
2) work fine, but for the third one we get an ANTLR error in ant:

 

C:\buildTemp\[...]\build.xml:97: ANTLR signaled an error: ANTLR Parser
Generator   Version 2.7.5 (20050128)   1989-2005 jGuru.com

error: file Grammar2.g not found

 

When we switch the order of Grammar1.g and Grammar2.g in the glib-line
(i.e., make it glib="path1/Grammar2.g;path1/Grammar1.g"), we get the
same error, but for "Grammar1.g", i.e., it always reports the second one
as being missing. I had found (but unfortunately do not re-find) a bug
discussion from the ant context in which it was discussed that glib list
arguments would not be checked in any way by ant, but passed directly to
ANTLR (which is apparently what happens here, since the error is an
ANTLR error). The file reported missing is present in the build
directory (the strange thing is that, if ANTLR doesn't check the
argument list backwards, it apparently finds Grammar1.g in the same
directory). A workaround which works (since Grammar2.g inherits from
Grammar1.g anyway) is to make Grammar3.g inherit from the expanded
version of Grammar2.g, i.e., use glib="path1/expandedGrammar2.g".
However, since this relies on what one might want to treat as internal
ANTLR expansion processes, we regard this somewhat as a hack.

 

Has anybody experienced anything similar and/or found a solution? Any
help or hint is greatly appreciated.

 

Cheers

Christian Bering

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060201/c537533f/attachment.html
From parrt at cs.usfca.edu  Wed Feb  1 08:54:22 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Wed Feb  1 08:54:31 2006
Subject: Please unlink [antlr-interest],
	[antlr-dev] and [stringtemplate-interest]
In-Reply-To: <00f001c6271b$fc62a000$6b02a8c0@hercules>
References: <00f001c6271b$fc62a000$6b02a8c0@hercules>
Message-ID: <EAAD61A8-0769-4AFF-AEB4-BBCB374AF46F@cs.usfca.edu>


On Feb 1, 2006, at 2:40 AM, Micheal J wrote:

> It seems prefectly reasonable to me that anyone that can find the  
> ANTLR list
> and website can also find ANTLR3 and StringTemplate lists and  
> websites if
> they wished.
>
> If an author feels a particular message if relevant to multiple  
> communities,
> the author can chose to post to both communities.

Hi Michael, not sure i know what you mean.  Those lists are not  
linked in anyway.

Ter

From ewbank at gmail.com  Wed Feb  1 14:35:16 2006
From: ewbank at gmail.com (Bryan Ewbank)
Date: Wed Feb  1 14:35:19 2006
Subject: [antlr-interest] Syntactic predicates question
In-Reply-To: <Pine.GSO.4.63.0601301353570.9406@alumni.engin.umich.edu>
References: <Pine.GSO.4.63.0601301353570.9406@alumni.engin.umich.edu>
Message-ID: <dd3a065f0602011435gf5f0cd2rda2a73271e82ea96@mail.gmail.com>

Hi Artem,

As others have said, the core problem is keywords and identifiers. 
Look for reference to keyword and lookup table in the ANTLR manual. 
Essentially, you first match IDENTIFIER, but then adjust the token
type using a look-up table or other algorithm...

IDENTIFIER : ALPHA ( ALPHA | DIGIT )+
   { $setType( grind(<string>, ID) ); }

here, the grind function will return the second arg if the first arg
does not match something of interest.  it will often be a simple
lookup table; however, it can be as complex as you desire/need.

On 1/30/06, Artem Dmytrenko <admytren@engin.umich.edu> wrote:
> Another newbie question here :)
>
> I'm running into some problems while using syntactic predicates to
> resolve between ambiguous grammar rules. Here's a snippet from my lexer:
>
> protected ActionToken: ("Action" | 'A');
> protected ID: ALPHA (ALPHA | DIGIT)+;
>
> SyntacticPredicate:
>    (ActionToken) => (ActionToken { $setType (ActionToken); } ) |
>    (ID) => (ID { $setType (ID); } );
>
> The expectation is that this rule will match either "Action" or "A" and
> tag it as ActionToken or it will match alphanumeric string that starts
> with a letter and mark it as ID. However when parsing a string like
> "A12345" the rule returns neither to the parser. Here's an example
> misparsing message that my parser emits:
>
> line 1:94: expecting ID, found 'A'
>
> It appears that the match is stuck in the middle - e.g. ActionToken rule
> rejected the string but ID did not match it. Is that the expected
> behavior for syntactic predicates? Are there any workarounds for this
> problem?
>
> Thank you in advance for any help and/or pointers.
>
> Sincerely,
> Artem Dmytrenko
>
From ewbank at gmail.com  Wed Feb  1 14:22:50 2006
From: ewbank at gmail.com (Bryan Ewbank)
Date: Wed Feb  1 14:48:46 2006
Subject: [antlr-interest] How to duplicate a subtree into a tree
In-Reply-To: <20060131160049.ip0emcb74oswsc4g@webmail.iro.umontreal.ca>
References: <e163e2f50601311129s12f2afaey@mail.gmail.com>
	<20060131160049.ip0emcb74oswsc4g@webmail.iro.umontreal.ca>
Message-ID: <dd3a065f0602011422q62e807dcwd3da91fcf25e3d4f@mail.gmail.com>

You must first /copy/ the tree, not just use it twice.  In C++ there's
a duptree method available that does this.  I don't know, but assume
there is something similar, in java-land.

On 1/31/06, duboimat@iro.umontreal.ca <duboimat@iro.umontreal.ca> wrote:
> Hello,
>
> I would like to know how to duplicate a subtree to build a new one.
> When I add two time the same subtree in a new one, my computer will stuck
>
> like
> klo.addChild(kl.getFirstChild());
> klo.addChild(kl.getFirstChild());
>
> thank you
> Mat
>
> ----------------------------------------------------------------
> This message was sent using IMP, the Internet Messaging Program.
>
>
From ewbank at gmail.com  Wed Feb  1 14:26:51 2006
From: ewbank at gmail.com (Bryan Ewbank)
Date: Wed Feb  1 14:51:06 2006
Subject: [antlr-interest] a silly question?
In-Reply-To: <20060201143024.19508.qmail@web15708.mail.cnb.yahoo.com>
References: <20060201143024.19508.qmail@web15708.mail.cnb.yahoo.com>
Message-ID: <dd3a065f0602011426r58cae9d5q58bf7ca9f12d193c@mail.gmail.com>

One solution is to assume that "true" is 1, and "false" is zero, then keep
the declarations as written.  If this is unacceptable - i.e., if you want to
support a boolean type - then you must provlde a value object that can hold
either an integer or a boolean.

You must also decide if it's an error to see "10 AND 20" or "true +
false"...

On 2/1/06, ÀÔºÕ∏’ <sunjigang1965@yahoo.com.cn> wrote:
>
>
> If I make extension with boolean type data to Terence's sample programmar
> on http://www.cs.usfca.edu/~parrt/course/652/lectures/antlr.html<http://www.cs.usfca.edu/%7Eparrt/course/652/lectures/antlr.html>
>
> class ExprParser extends Parser;
>
> expr:   mexpr ((PLUS|MINUS) mexpr)*
>     ;
>
> mexpr
>     :&nbsp ;  atom (STAR atom)*
>     ;
>
> atom:   INT
> |   LPAREN expr RPAREN
> ;
>
> adding atomic data "true" and "false", logical operator AND and OR,
>
> class ExprParser extends Parser;
>
> expr:   mexpr ((PLUS|MINUS|OR) mexpr)*
>     ;
>
> mexpr
> :   atom (STAR|AND atom)*
>     ;
>
> atom:   INT
> |   LPAREN expr RPAREN
> | "true"
> |"false"
> ;
>
>
> What modification should be added to the interpreter
>
> class ExprParser extends Parser;
>
> expr returns [int value=0]
> {int x;}
>     :   value=mexpr
>         ( PLUS x=mexpr  {value += x;}
>         | MINUS x=mexpr {value -= x;}
>         )*
>     ;
>
> mexpr returns [int value=0]
> {int x;}
>     :   value=atom ( STAR x=atom {value *= x;} )*
>     ;
>
> atom returns [int value=0]
>     :   i:INT {value=Integer.parseInt(i.getText());}
>     |   LPAREN value=expr RPAREN
>     ;
>
> to make generated method atom, mexpr and expr polymorphic? That is
>
> class ExprParser extends Parser;
>
> expr returns [? value=?]
> {int x;bool y;}
>     :   value=mexpr
>         ( PLUS x=mexpr  {value += x;}
>         | MINUS x=mexpr {value -= x;}
>         |OR y=mepr {value=value or y;})*
>     ;
>
> mexpr returns [? value=?]
> {int x;bool y;}
>     :   value=atom ( STAR x=atom {value *= x;}
>     |AND y=atom {value=y && value;} )*
>     ;
>
> atom returns [? value=?]
>     :   i:INT {value=Integer.parseInt(i.getText());}
>     |   LPAREN value=expr RPAREN
>     |"true" {value=true;}
>     |"false" {value=false;}
>     ;
>
>
> I did a lot of search on the Internet  but have not got the answer.
>
> Jigang
>
>
> ------------------------------
> œÎ≥…Œ™∑Î–°∏’°¢≥¬ø≠∏Ë°¢’≈ºÕ÷–»˝¥Ûµº—›µƒ÷˜Ω«¬£ø <http://sostar.cn.yahoo.com>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060201/a813b9b7/attachment-0001.html
From open.zone at virgin.net  Wed Feb  1 14:11:54 2006
From: open.zone at virgin.net (Micheal J)
Date: Wed Feb  1 15:19:23 2006
Subject: Please unlink [antlr-interest],
	[antlr-dev] and [stringtemplate-interest]
In-Reply-To: <EAAD61A8-0769-4AFF-AEB4-BBCB374AF46F@cs.usfca.edu>
Message-ID: <011201c6277c$836685c0$6b02a8c0@hercules>

> > It seems prefectly reasonable to me that anyone that can find the
> > ANTLR list
> > and website can also find ANTLR3 and StringTemplate lists and  
> > websites if
> > they wished.
> >
> > If an author feels a particular message if relevant to multiple
> > communities,
> > the author can chose to post to both communities.
> 
> Hi Michael, not sure i know what you mean.  Those lists are not  
> linked in anyway.

Oops, aren't they?. I'd seen a few threads duplicated on two or all three of
the lists and I reached the wrong conclusion it seems. 

My mistake.

Cheers,

Micheal

From sunjigang1965 at yahoo.com.cn  Wed Feb  1 17:16:10 2006
From: sunjigang1965 at yahoo.com.cn (=?gb2312?q?=CB=EF=BC=CD=B8=D5=20Jigang=20(Robert)=20Sun?=)
Date: Wed Feb  1 17:16:19 2006
Subject: [antlr-interest] How to interpret object creation sentence?
Message-ID: <20060202011610.21796.qmail@web15707.mail.cnb.yahoo.com>

 
   
  Now I want to interpret an object creation with actions in C#, source syntax like "new ClassName()",  objective code is the same, such as" ClassName aObject=new ClassName();"
   
  The first grammar is refused by C# compiler,
  createObject returns [Object o=null]
 :
 "new" id:ID LPAREN RPAREN { o= new  id.getText()+"()";} 
 ;
    
The second just return a string, e.g. "new ClassName ()",
  createObject returns [string r=null]
 :
 "new" id:ID LPAREN RPAREN{r= "new "+id.getText()+"()";}
 ;
   
  Could any ony give me an idea?
   
  Jigang

   


		
---------------------------------
øÏ¿¥—≈ª¢” œ‰∑¢∫ÿø®£¨∞›¥ÛƒÍ¿≤£° 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060202/01a8e6ac/attachment.html
From jsamort at sympatico.ca  Wed Feb  1 17:46:25 2006
From: jsamort at sympatico.ca (Scott Amort)
Date: Wed Feb  1 17:46:37 2006
Subject: [antlr-interest] help requested for selective whitespace
In-Reply-To: <1138762449.7476.8.camel@localhost>
References: <1138585445.7879.16.camel@localhost>
	<1138762449.7476.8.camel@localhost>
Message-ID: <1138844785.2032.8.camel@localhost>

Me again :-)

I've found a post from the archive of this mailing list that partially
addresses almost exactly the problem I am facing:

http://groups.yahoo.com/group/antlr-interest/message/13929

In this posters case, he needed to be sure that WS was not included
around certain statements, while I need to be sure that WS is included
between certain constructs.

Now, there were a few reponses to his post - but the one that seemed
most appealing to me was:

> I would recommend an alternative approach, which would be to not skip
> whitespace in the lexer.  Instead, discard it in the parser filter.
> That filter can still check that no whitespace occurs before or after
> an @ between IDENTS.

I did some reading and have implemented a filter that discards
whitespace, but I'm still unclear about how to test for this discarded
whitespace within the filter (or within the parser).

Is this the best way to approach this?  And, if anyone could provide me
with a few tips on how to approach the test for discarded whitespace, I
would most certainly appreciate it.

Thanks for any and all help!

Best, Scott


From allex at all-x.net  Wed Feb  1 22:26:07 2006
From: allex at all-x.net (Alexey Demakov)
Date: Wed Feb  1 22:26:11 2006
Subject: [antlr-interest] How to interpret object creation sentence?
References: <20060202011610.21796.qmail@web15707.mail.cnb.yahoo.com>
Message-ID: <006601c627c1$8d633ba0$012ca8c0@allex>

If you need to create object for the given class name you can use CreateInstance method in Assembly class.
Assembly is returned by the correspondent property of System.Type class.

System.Type type = ...;
object instance = type.Assembly.CreateInstance( fullName )

But it is not so easy - you need to know fully qualified name of class to create, not just last identifier.

---
Alexey Demakov
TreeDL: Tree Description Language: http://treedl.sourceforge.net
RedVerst Group: http://www.unitesk.com

  ----- Original Message ----- 
  From: ÀÔºÕ∏’ Jigang (Robert) Sun 
  To: antlr-interest@antlr.org 
  Sent: Thursday, February 02, 2006 4:16 AM
  Subject: [antlr-interest] How to interpret object creation sentence?




  Now I want to interpret an object creation with actions in C#, source syntax like "new ClassName()",  objective code is the same, such as" ClassName aObject=new ClassName();"

  The first grammar is refused by C# compiler,
  createObject returns [Object o=null]
   :
   "new" id:ID LPAREN RPAREN { o= new  id.getText()+"()";} 
   ;

  The second just return a string, e.g. "new ClassName ()",
  createObject returns [string r=null]
   :
   "new" id:ID LPAREN RPAREN{r= "new "+id.getText()+"()";}
   ;

  Could any ony give me an idea?

  Jigang




------------------------------------------------------------------------------
  øÏ¿¥—≈ª¢” œ‰∑¢∫ÿø®£¨∞›¥ÛƒÍ¿≤£° 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060202/55629ea9/attachment.html
From mail at martin-probst.com  Thu Feb  2 03:42:25 2006
From: mail at martin-probst.com (Martin Probst)
Date: Thu Feb  2 03:42:32 2006
Subject: [antlr-interest] help requested for selective whitespace
In-Reply-To: <1138844785.2032.8.camel@localhost>
References: <1138585445.7879.16.camel@localhost>
	<1138762449.7476.8.camel@localhost> <1138844785.2032.8.camel@localhost>
Message-ID: <1138880545.9733.5.camel@localhost.localdomain>

Hi,

maybe I should write a bit more about my other email. As far as I
understand it, your problem is that you want single identifiers like "a"
or "b", always length == 1, to be separated by whitespace. This doesn't
work if you have a rule that consumes exactly one character, as you
cannot be sure if whitespace we're between the identifiers. So my idea
is to just parse longer identifiers like this:
IDENT: ('a' .. 'b')+;
and then check in that Lexer rules if the token was actually longer than
one character, in which case you throw an exception with the error
message:
IDENT: ('a' .. 'b')+ { if ($getText().length() > 1) throw ... };
Does that work for you?

Martin

From admytren at engin.umich.edu  Thu Feb  2 09:54:00 2006
From: admytren at engin.umich.edu (Artem Dmytrenko)
Date: Thu Feb  2 09:54:05 2006
Subject: [antlr-interest] Syntactic predicates question
In-Reply-To: <dd3a065f0602011435gf5f0cd2rda2a73271e82ea96@mail.gmail.com>
References: <Pine.GSO.4.63.0601301353570.9406@alumni.engin.umich.edu>
	<dd3a065f0602011435gf5f0cd2rda2a73271e82ea96@mail.gmail.com>
Message-ID: <Pine.GSO.4.63.0602021237480.15880@alumni.engin.umich.edu>

Thank you all for the very valuable explanations of lexer behavior. My 
confusion came from not properly understanding this very behavior. It 
looks like the art of ANTLR is to keep complexity of parser and lexer 
balanced. I allowed my lexer to become too complicated and do a lot of 
work that really belongs to parser.

Bryan the tip in your email is very useful. I'm also trying to split my 
identifiers (~90) and value types (~30) into two different lexer states to 
minimize the use of syntactic predicates. I think those two approaches 
should resolve my non-determinism problem.

Thank you again.

Sincerely,
Artem Dmytrenko

On Wed, 1 Feb 2006, Bryan Ewbank wrote:

> Hi Artem,
>
> As others have said, the core problem is keywords and identifiers.
> Look for reference to keyword and lookup table in the ANTLR manual.
> Essentially, you first match IDENTIFIER, but then adjust the token
> type using a look-up table or other algorithm...
>
> IDENTIFIER : ALPHA ( ALPHA | DIGIT )+
>   { $setType( grind(<string>, ID) ); }
>
> here, the grind function will return the second arg if the first arg
> does not match something of interest.  it will often be a simple
> lookup table; however, it can be as complex as you desire/need.
>
> On 1/30/06, Artem Dmytrenko <admytren@engin.umich.edu> wrote:
>> Another newbie question here :)
>>
>> I'm running into some problems while using syntactic predicates to
>> resolve between ambiguous grammar rules. Here's a snippet from my lexer:
>>
>> protected ActionToken: ("Action" | 'A');
>> protected ID: ALPHA (ALPHA | DIGIT)+;
>>
>> SyntacticPredicate:
>>    (ActionToken) => (ActionToken { $setType (ActionToken); } ) |
>>    (ID) => (ID { $setType (ID); } );
>>
>> The expectation is that this rule will match either "Action" or "A" and
>> tag it as ActionToken or it will match alphanumeric string that starts
>> with a letter and mark it as ID. However when parsing a string like
>> "A12345" the rule returns neither to the parser. Here's an example
>> misparsing message that my parser emits:
>>
>> line 1:94: expecting ID, found 'A'
>>
>> It appears that the match is stuck in the middle - e.g. ActionToken rule
>> rejected the string but ID did not match it. Is that the expected
>> behavior for syntactic predicates? Are there any workarounds for this
>> problem?
>>
>> Thank you in advance for any help and/or pointers.
>>
>> Sincerely,
>> Artem Dmytrenko
>>
>
>
From mike at doublevdesign.co.uk  Thu Feb  2 15:05:40 2006
From: mike at doublevdesign.co.uk (Mike Ventham)
Date: Thu Feb  2 15:06:02 2006
Subject: [antlr-interest] One of a type in a list of many - an ANTLR grammar
	question
Message-ID: <7.0.0.16.0.20060202230328.09297dc0@doublevdesign.co.uk>

I've been using ANTLR for a couple of days and have been writing a parser for
a format for which I have the BNF. The .g file is about 2100 lines.
There are several places where there is a one of a type in a list of 
properties.
For example:-

nonCondLayers ::= '(' 'nonConductiveLayer' {nonCondLayer} ')'

nonCondLayer ::=  '(' 'layer' layerName {<nonCondLayerType> property} ')'

## The {<x> y} means 0 or 1 "x" in a list with 0 or more "y"s in any order
## e.g x y y  or y x y or x or y y

nonCondLayerType ::= '(' 'type' nonCondLayerTypeEnum ')'

nonCondLayerTypeEnum ::= "VARIANTHOLE"

property ::= noTypeProperty | integerProperty | floatingProperty | 
stringProperty

noTypeProperty ::= '(' 'property' propName propVal ')'

integerProperty ::= '(' 'propertyI' propName propVal ')'

floatingProperty ::= '(' 'propertyF' propName propVal ')'

stringProperty ::= '(' 'propertyS' propName propVal ')'

propName ::=  identifier

propVal ::= integerValue | floatingValue | string

I get nondeterminism warnings for these lines as well.

I used the rules:
nonCondLayers : LPAREN! "nonConductiveLayer" (nonCondLayer)* RPAREN!
;
nonCondLayer :  LPAREN! "layer" layerName ((nonCondLayerType)? 
property)* RPAREN!
;

However this seems to cause a hang when parsing the file but changing to

nonCondLayer :  LPAREN! "layer" layerName (nonCondLayerType)? 
(property)* RPAREN!
;
works OK but won't handle the case " property nonCondLayerType property "
Would
nonCondLayer :  LPAREN! "layer" layerName (property)* 
(nonCondLayerType)? (property)* RPAREN!
;
be any better?

Any help appreciated!

P.S. Is there any best practice dealing with nested bracket format 
files? I couldn't
      find an example.



Regards

Mike


Mike Ventham
Chief Technical Consultant
Double V Design & Support Services
Langarth, Stoke Road, Westbury-sub-Mendip
Wells, Somerset, BA5 1HD, UK.
Tel   : 44 (0)1749 871104       Fax: 44 (0)7974 141685
Mob   : 44 (0)7971 553260
Email : mike@doublevdesign.co.uk
Web   : http://www.doublevdesign.co.uk 


From sunjigang1965 at yahoo.com.cn  Thu Feb  2 15:44:44 2006
From: sunjigang1965 at yahoo.com.cn (=?gb2312?q?=CB=EF=BC=CD=B8=D5=20Jigang=20(Robert)=20Sun?=)
Date: Thu Feb  2 15:44:47 2006
Subject: [antlr-interest] unreachable code detected 
Message-ID: <20060202234444.66211.qmail@web15709.mail.cnb.yahoo.com>

The grammar is 
   
  type returns [int ty=0]
 : "int" LSQUARE RSQUARE {ty=INT_ARRAY_type;}
 | "int" {ty=INT_type;}
 | "boolean" {ty=BOOLEAN_type;}
 |  id:ID {ty=ID_type;}
   
  antlr generates
   public int  type() 
  {
  ....
    returnAST = type_AST;
  return ty;
  ASTPair.PutInstance(currentAST);
 }
   
  there is always a statement appears after return.
   
  Why?  
    

		
---------------------------------
 —≈ª¢1G√‚∑—” œ‰∞Ÿ∑÷∞Ÿ∑¿¿¨ª¯–≈
 —≈ª¢÷˙ ÷-À—À˜°¢…±∂æ°¢∑¿…ß»≈  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060203/1858da07/attachment.html
From open.zone at virgin.net  Thu Feb  2 18:14:11 2006
From: open.zone at virgin.net (Micheal J)
Date: Thu Feb  2 17:57:48 2006
Subject: [antlr-interest] unreachable code detected 
In-Reply-To: <20060202234444.66211.qmail@web15709.mail.cnb.yahoo.com>
Message-ID: <001801c62867$86e93210$6402a8c0@hercules>

What version of ANTLR are you using?. I'm guessing 2.7.5 (and that you're using C#). If so, please upgrade to 2.7.6 as that fixes issues such as this reported in 2.7.5. ASTPair management fir C# targets is definitely different.
 
Cheers,
 
Micheal

-----Original Message-----
From: antlr-interest-bounces@antlr.org [mailto:antlr-interest-bounces@antlr.org] On Behalf Of ?????? Jigang (Robert) Sun
Sent: 02 February 2006 23:45
To: antlr-interest@antlr.org
Subject: [antlr-interest] unreachable code detected 


The grammar is 
 
type returns [int ty=0]
 : "int" LSQUARE RSQUARE {ty=INT_ARRAY_type;}
 | "int" {ty=INT_type;}
 | "boolean" {ty=BOOLEAN_type;}
 |  id:ID {ty=ID_type;}
 
antlr generates
 public int  type() 
{
....
  returnAST = type_AST;
  return ty;
  ASTPair.PutInstance(currentAST);
 }
 
there is always a statement appears after return.
 
Why?  
  



  _____  

??1G??????????? <http://cn.mail.yahoo.com> 
????-????????? <http://cn.zs.yahoo.com>  

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060203/c34960d9/attachment.html
From ewbank at gmail.com  Fri Feb  3 03:00:09 2006
From: ewbank at gmail.com (Bryan Ewbank)
Date: Fri Feb  3 03:00:12 2006
Subject: [antlr-interest] Syntactic predicates question
In-Reply-To: <Pine.GSO.4.63.0602021237480.15880@alumni.engin.umich.edu>
References: <Pine.GSO.4.63.0601301353570.9406@alumni.engin.umich.edu>
	<dd3a065f0602011435gf5f0cd2rda2a73271e82ea96@mail.gmail.com>
	<Pine.GSO.4.63.0602021237480.15880@alumni.engin.umich.edu>
Message-ID: <dd3a065f0602030300l437d1b03v512ca3c7532ffcfd@mail.gmail.com>

If you use lexer states (evil! augh! :-), please consider using two
lexers instead.  There is an example in the reference book that talks
about parsing Java and Javadoc; rather than one stateful lexer, it
uses two lexers.

I don't remember the details, but that's where I'd start.
- Bryan

On 2/2/06, Artem Dmytrenko <admytren@engin.umich.edu> wrote:
> Thank you all for the very valuable explanations of lexer behavior. My
> confusion came from not properly understanding this very behavior. It
> looks like the art of ANTLR is to keep complexity of parser and lexer
> balanced. I allowed my lexer to become too complicated and do a lot of
> work that really belongs to parser.
>
> Bryan the tip in your email is very useful. I'm also trying to split my
> identifiers (~90) and value types (~30) into two different lexer states to
> minimize the use of syntactic predicates. I think those two approaches
> should resolve my non-determinism problem.
>
> Thank you again.
>
> Sincerely,
> Artem Dmytrenko
>
> On Wed, 1 Feb 2006, Bryan Ewbank wrote:
>
> > Hi Artem,
> >
> > As others have said, the core problem is keywords and identifiers.
> > Look for reference to keyword and lookup table in the ANTLR manual.
> > Essentially, you first match IDENTIFIER, but then adjust the token
> > type using a look-up table or other algorithm...
> >
> > IDENTIFIER : ALPHA ( ALPHA | DIGIT )+
> >   { $setType( grind(<string>, ID) ); }
> >
> > here, the grind function will return the second arg if the first arg
> > does not match something of interest.  it will often be a simple
> > lookup table; however, it can be as complex as you desire/need.
> >
> > On 1/30/06, Artem Dmytrenko <admytren@engin.umich.edu> wrote:
> >> Another newbie question here :)
> >>
> >> I'm running into some problems while using syntactic predicates to
> >> resolve between ambiguous grammar rules. Here's a snippet from my lexer:
> >>
> >> protected ActionToken: ("Action" | 'A');
> >> protected ID: ALPHA (ALPHA | DIGIT)+;
> >>
> >> SyntacticPredicate:
> >>    (ActionToken) => (ActionToken { $setType (ActionToken); } ) |
> >>    (ID) => (ID { $setType (ID); } );
> >>
> >> The expectation is that this rule will match either "Action" or "A" and
> >> tag it as ActionToken or it will match alphanumeric string that starts
> >> with a letter and mark it as ID. However when parsing a string like
> >> "A12345" the rule returns neither to the parser. Here's an example
> >> misparsing message that my parser emits:
> >>
> >> line 1:94: expecting ID, found 'A'
> >>
> >> It appears that the match is stuck in the middle - e.g. ActionToken rule
> >> rejected the string but ID did not match it. Is that the expected
> >> behavior for syntactic predicates? Are there any workarounds for this
> >> problem?
> >>
> >> Thank you in advance for any help and/or pointers.
> >>
> >> Sincerely,
> >> Artem Dmytrenko
> >>
> >
> >
>
From Sebastian.Kaliszewski at softax.com.pl  Fri Feb  3 04:45:25 2006
From: Sebastian.Kaliszewski at softax.com.pl (Sebastian Kaliszewski)
Date: Fri Feb  3 04:30:10 2006
Subject: [antlr-interest] added ANTLR v3 page
Message-ID: <43E35065.7040204@softax.com.pl>

On Tuesday 31 January 2006 22:47, Terence Parr wrote:

 > Howdy,
 >
 > I have finally added a description page for v3:


Something with the example parser is not right:


<quote>
grammar SimpleParser;
program : variable* method+ ;
variable: "int" ID ( =  expr)? ';  ;     // HUH???
method  : "method" ID '(' ')'
           '{'
               variable* statement+
           '}'
         ;
statement

         : ID  =  expr ';'
         :
         | "return" expr ';'

         ;
expr    : ID | INT ;
ID      : ('a'..'z'|'A'..'Z')+ ;
INT     : '0'..'9'+ ;
WS      : (' '|'\t'|'\n')+ {channel=99;}
         ;

Note that all literals are single-quoted...
</quote>

Line 3 probably has ' missing

And then which of "int" or "method" or "return" is single quoted?


rgds
--
Sebastian Kaliszewski

From gudnabrsam at yahoo.com  Fri Feb  3 06:19:25 2006
From: gudnabrsam at yahoo.com (Matt Benson)
Date: Fri Feb  3 06:19:31 2006
Subject: [antlr-interest] added ANTLR v3 page
In-Reply-To: <43E35065.7040204@softax.com.pl>
Message-ID: <20060203141925.76492.qmail@web30903.mail.mud.yahoo.com>

All places where you see the = sign, showed up as
funny blocks in Mozilla FF... I assume those were some
form of single quote.

-Matt

--- Sebastian Kaliszewski
<Sebastian.Kaliszewski@softax.com.pl> wrote:

> On Tuesday 31 January 2006 22:47, Terence Parr
> wrote:
> 
>  > Howdy,
>  >
>  > I have finally added a description page for v3:
> 
> 
> Something with the example parser is not right:
> 
> 
> <quote>
> grammar SimpleParser;
> program : variable* method+ ;
> variable: "int" ID ( =  expr)? ';  ;     // HUH???
> method  : "method" ID '(' ')'
>            '{'
>                variable* statement+
>            '}'
>          ;
> statement
> 
>          : ID  =  expr ';'
>          :
>          | "return" expr ';'
> 
>          ;
> expr    : ID | INT ;
> ID      : ('a'..'z'|'A'..'Z')+ ;
> INT     : '0'..'9'+ ;
> WS      : (' '|'\t'|'\n')+ {channel=99;}
>          ;
> 
> Note that all literals are single-quoted...
> </quote>
> 
> Line 3 probably has ' missing
> 
> And then which of "int" or "method" or "return" is
> single quoted?
> 
> 
> rgds
> --
> Sebastian Kaliszewski
> 
> 


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 
From ncuomo at gmail.com  Fri Feb  3 10:24:23 2006
From: ncuomo at gmail.com (Nicola Cuomo)
Date: Fri Feb  3 10:22:42 2006
Subject: [antlr-interest] CppCC vs ANTLR
Message-ID: <445391045.20060203192423@gmail.com>

Hi,
   a    colleague    is    working    on    a   parser   using   cppcc
(http://cppcc.sourceforge.net/) since he's having some problem with it
and i'm a "fan", i could not help myself to advocate for ANTLR.

And  that's why i need some advice on what are the differences between
CppCC and ANTLR and why would be a better to use ANTLR (apart the kind
community <-- subliminal message -_-')

Thanks to who'll answer to that naive message

Bye, bye
-- 
 Nicola                          mailto:ncuomo@gmail.com

From jens.stegemann at gmx.de  Fri Feb  3 10:52:43 2006
From: jens.stegemann at gmx.de (Jens Stegemann)
Date: Fri Feb  3 10:52:48 2006
Subject: [antlr-interest] Parsing multiple messages using one parser
Message-ID: <200602031952.43204.jens.stegemann@gmx.de>

Hello,

I am writing a client-server based application in c++ (but the problem will be 
the same in JAVA, too - i suppose). The clients send messages to the server 
which have to be parsed there to create a reply. To do so an 
interpreter-class exists within the server like this one:

class Interpreter
{
	public:
		Interpreter();
		void doParse(string message);
	
	private:
		Parser *myParser;
		Lexer *myLexer;
};

Is it possible to use the same myParser and myLexer objects in every call of 
do Parse(...) and can you tell me how I have to initialize them in the 
constructor and use them in doParse(...) to do so?

My application is working fine when I create new instances of Parser and Lexer 
for each call of doParse(...), but this is much too time-consuming for my 
purpose.

I googled a lot and searched every resource about antlr I could find for a 
solution without success. I hope you can help me.


Your's

Jens

-- 
Keep your dreams alive and live your dreams!
From sunjigang1965 at yahoo.com.cn  Fri Feb  3 13:16:55 2006
From: sunjigang1965 at yahoo.com.cn (=?gb2312?q?=CB=EF=BC=CD=B8=D5=20Jigang=20(Robert)=20Sun?=)
Date: Fri Feb  3 13:17:00 2006
Subject: [antlr-interest] problem to run antlr 2.7.6
Message-ID: <20060203211655.45787.qmail@web15705.mail.cnb.yahoo.com>

I enter a command:
  d: java -cp d:\antlr276\antlr.jar antlr.tool p.g 
   
  error message:
  Exception in thread "main" java.lang.NoClassDefFonudError:antlr/tool
   
  Could anyone tell me the reason?
   
  Cheer.
   
  Jigang

		
---------------------------------
 —≈ª¢1G√‚∑—” œ‰∞Ÿ∑÷∞Ÿ∑¿¿¨ª¯–≈
 —≈ª¢÷˙ ÷-À—À˜°¢…±∂æ°¢∑¿…ß»≈  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060204/e2da5542/attachment.html
From jsamort at sympatico.ca  Fri Feb  3 13:33:07 2006
From: jsamort at sympatico.ca (Scott Amort)
Date: Fri Feb  3 13:33:12 2006
Subject: [antlr-interest] help requested for selective whitespace
In-Reply-To: <1138880545.9733.5.camel@localhost.localdomain>
References: <1138585445.7879.16.camel@localhost>	<1138762449.7476.8.camel@localhost>
	<1138844785.2032.8.camel@localhost>
	<1138880545.9733.5.camel@localhost.localdomain>
Message-ID: <43E3CC13.3000209@sympatico.ca>

Martin Probst wrote:
> Hi,
>
> maybe I should write a bit more about my other email. As far as I
> understand it, your problem is that you want single identifiers like "a"
> or "b", always length == 1, to be separated by whitespace. This doesn't
> work if you have a rule that consumes exactly one character, as you
> cannot be sure if whitespace we're between the identifiers. So my idea
> is to just parse longer identifiers like this:
> IDENT: ('a' .. 'b')+;
> and then check in that Lexer rules if the token was actually longer than
> one character, in which case you throw an exception with the error
> message:
> IDENT: ('a' .. 'b')+ { if ($getText().length() > 1) throw ... };
> Does that work for you?
>
> Martin
>
>   
Hi Martin,

Thanks very much for the response.  I have modified the grammar a fair 
bit since that first message, and I was trying to use some simple 
examples to explain my point.  Here is the more complete and detailed 
version:

The lexer needs to recognize musical note names, upper or lower case a 
through h, as well as an alternative method of identifying the musical 
note through solfege (i.e. do, re, mi, etc.).  Then, there is a variety 
of optional data that may be appended to that note name to make up the 
full note description.  For simplicity's sake, I'll leave out the 
solfege options.  So, roughly, I have in the lexer:

NOTENAME
  : 'a'..'h' | 'A'..'H'
  ;

OCTAVE
  : ('0'..'9')+
  ;

DURATION
  : '*' ('0'..'9')+ ( '/' ('0'..'9')+ )?
  ;

DOT
  : '.'
  ;

And then in the parser:

note_desc
  : NOTENAME (OCTAVE)? (DURATION)? (DOT)?
  ;

The lexer ignores whitespace.  Now, the problem is, I require that there 
be no whitespace between any of the tokens making up note_desc, but 
currently there is no distinction made between the correct input:

a8*1/4

and the incorrect input:

a 8 *1/4

Now, I realise that I could bring the note_desc portion of the parser 
into the lexer, but then I lose the ability to easily form an AST with a 
NOTENAME node and the subsequent data as child nodes, which is very 
helpful for later transformations.  The other option is to allow the 
lexer to send WS tokens to the parser, but in all other instances it is 
safe to ignore whitespace, and I really don't want (WS)? tokens 
cluttering things up in the parser.

Looking at your suggestion, Martin, I see that it would work fine if I 
had a fixed length note_desc, but it can be of variable length depending 
on the appearance of some of the optional data.

So, you can see my dilemma!  What is the best way to approach this 
problem?  Thanks very much for you assistance!

Best,
Scott
From mdiggory at latte.harvard.edu  Fri Feb  3 13:34:52 2006
From: mdiggory at latte.harvard.edu (Mark R. Diggory)
Date: Fri Feb  3 13:35:10 2006
Subject: [antlr-interest] Help with simple Logic or Query Syntax.
Message-ID: <43E3CC7C.2030208@latte.harvard.edu>

Hello,

I'm attempting to create a parser for some simple query syntax our 
project maintains, its similar but simpler to that of Lucene. The basic 
syntax is

term op value BOOL term op value with parentheses and double quotes 
allowed around values. So for instance as an example:

(title="Something cool" AND author=foo AND date>=2001) OR "Something 
Completely Different"

I'm challenged in that while I grok BNF, I can't read write it yet: At 
least I know the basics of our syntax as a starting point, I'm unsure if 
this is correct.

query ::= term (bool term)*

term ::= (index op value) | value

term ::= word

value ::= word and quoted words

op ::= < > = <> != <= =>

bool ::= AND OR NOT

thanks for any tips,
Mark
From sunjigang1965 at yahoo.com.cn  Fri Feb  3 14:34:31 2006
From: sunjigang1965 at yahoo.com.cn (=?gb2312?q?=CB=EF=BC=CD=B8=D5=20Jigang=20(Robert)=20Sun?=)
Date: Fri Feb  3 14:34:36 2006
Subject: [antlr-interest] ReRE:problem to run antlr 2.7.6
Message-ID: <20060203223432.65199.qmail@web15703.mail.cnb.yahoo.com>

It is the same: changed from antlr.tool to antlr.Tool, it responded :
   
  Exception in thread "main" java.lang.NoClassDefFonudError:antlr/Tool
   
   
  Jigang



		
---------------------------------
 —≈ª¢1G√‚∑—” œ‰∞Ÿ∑÷∞Ÿ∑¿¿¨ª¯–≈
 —≈ª¢÷˙ ÷-À—À˜°¢…±∂æ°¢∑¿…ß»≈  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060204/6e056118/attachment.html
From parrt at cs.usfca.edu  Fri Feb  3 14:54:20 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Fri Feb  3 14:54:25 2006
Subject: [antlr-interest] added ANTLR v3 page
In-Reply-To: <43E35065.7040204@softax.com.pl>
References: <43E35065.7040204@softax.com.pl>
Message-ID: <206CCF46-3B95-48F6-99D3-19A32D95D364@cs.usfca.edu>

Hi.  Fixed it...

Ter
From parrt at cs.usfca.edu  Fri Feb  3 14:55:17 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Fri Feb  3 14:55:23 2006
Subject: [antlr-interest] ReRE:problem to run antlr 2.7.6
In-Reply-To: <20060203223432.65199.qmail@web15703.mail.cnb.yahoo.com>
References: <20060203223432.65199.qmail@web15703.mail.cnb.yahoo.com>
Message-ID: <6CA44CB9-0F09-4808-8354-51039DD84474@cs.usfca.edu>

Hi. This is a standard java thing: check your classpath.
Ter
On Feb 3, 2006, at 2:34 PM, ??? Jigang (Robert) Sun wrote:

> It is the same: changed from antlr.tool to antlr.Tool, it responded :
>
> Exception in thread "main" java.lang.NoClassDefFonudError:antlr/Tool
>
>
> Jigang
>
>
> ??1G???????????
> ????-?????????

From ury_segal at guardium.com  Fri Feb  3 15:37:28 2006
From: ury_segal at guardium.com (ury segal)
Date: Fri Feb  3 15:37:30 2006
Subject: [antlr-interest] ANTLR C++ code without std::string
Message-ID: <20060203233728.82446.qmail@web51704.mail.yahoo.com>

Hi,

Is there a way to generate ANTLR C++
code that uses some other "string" than 
std::string? I would like to use a class string
that has a different memory allocator.

Thanks

--ury


--ury
From priya.uky at gmail.com  Fri Feb  3 17:22:05 2006
From: priya.uky at gmail.com (Priya)
Date: Fri Feb  3 17:22:08 2006
Subject: [antlr-interest] Two pass parser example
Message-ID: <2b8e23150602031722j4b6eb920t8427837e878d4eb3@mail.gmail.com>

Hi Everybody,
I'm trying to parse C syntax with my ANTLR grammar.I have to parse
functions and fuction calls ,for which i'm building a two pass parser
.
Could anyone help by posting a two pass parser example ?
Thanks in advance
Priya
From open.zone at virgin.net  Fri Feb  3 18:24:35 2006
From: open.zone at virgin.net (Micheal J)
Date: Fri Feb  3 18:08:10 2006
Subject: [antlr-interest] problem to run antlr 2.7.6
In-Reply-To: <20060203211655.45787.qmail@web15705.mail.cnb.yahoo.com>
Message-ID: <002801c62932$252ce280$6402a8c0@hercules>

"antlr.tool" should be "antlr.Tool". Case matters.
 
What you have should work fine (it works on 1.4.2_05 using a fresh download of the 2.7.6 archive from the website) but, you could try this:
 
d:>java -classpath d:\antlr276\antlr.jar; antlr.Tool p.g
 
What does "java -version" report?
 
Micheal

-----Original Message-----
From: antlr-interest-bounces@antlr.org [mailto:antlr-interest-bounces@antlr.org] On Behalf Of ?????? Jigang (Robert) Sun
Sent: 03 February 2006 21:17
To: antlr-interest@antlr.org
Subject: [antlr-interest] problem to run antlr 2.7.6


I enter a command:
d: java -cp d:\antlr276\antlr.jar antlr.tool p.g 
 
error message:
Exception in thread "main" java.lang.NoClassDefFonudError:antlr/tool
 
Could anyone tell me the reason?
 
Cheer.
 
Jigang



  _____  

??1G??????????? <http://cn.mail.yahoo.com> 
????-????????? <http://cn.zs.yahoo.com>  

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060204/d8eca6ab/attachment.html
From open.zone at virgin.net  Fri Feb  3 18:31:32 2006
From: open.zone at virgin.net (Micheal J)
Date: Fri Feb  3 18:15:06 2006
Subject: [antlr-interest] Two pass parser example
In-Reply-To: <2b8e23150602031722j4b6eb920t8427837e878d4eb3@mail.gmail.com>
Message-ID: <002d01c62933$1d76be70$6402a8c0@hercules>

> Hi Everybody,
> I'm trying to parse C syntax with my ANTLR grammar.I have to 
> parse functions and fuction calls ,for which i'm building a 
> two pass parser . Could anyone help by posting a two pass 
> parser example ? Thanks in advance Priya

http://www.cc.gatech.edu/classes/AY2001/cs4240_fall/
http://www.cc.gatech.edu/classes/AY2001/cs4240_fall/prj3/more.html
http://www.cc.gatech.edu/classes/AY2001/cs4240_fall/prj3sol/

It's a multi-pass sample. It does lexing, parsing, typechecking, optimizing
and codegen. It parses once, builds a tree and then uses tree parsers for
the other "passes". Make what you can of it.

Good luck

Micheal

From mhaupt at gmail.com  Sat Feb  4 11:58:11 2006
From: mhaupt at gmail.com (Michael Haupt)
Date: Sat Feb  4 11:58:15 2006
Subject: [antlr-interest] Does ANTLR generate C?
Message-ID: <b1ba07840602041158i42058e73hb57e56909e3d2ec8@mail.gmail.com>

Hi,

is there any way to convince ANTLR to generate a parser in plain C, not C++?

Thanks,

Michael
From kroepke at dolphin-services.de  Sat Feb  4 13:57:52 2006
From: kroepke at dolphin-services.de (Kay Roepke)
Date: Sat Feb  4 13:58:00 2006
Subject: [antlr-interest] Does ANTLR generate C?
In-Reply-To: <b1ba07840602041158i42058e73hb57e56909e3d2ec8@mail.gmail.com>
References: <b1ba07840602041158i42058e73hb57e56909e3d2ec8@mail.gmail.com>
Message-ID: <3C30A812-9A29-454E-A11B-9A65914C2561@dolphin-services.de>


On 4. Feb 2006, at 20:58 Uhr, Michael Haupt wrote:

> is there any way to convince ANTLR to generate a parser in plain C,  
> not C++?

Not in version 2.x, but there will be plain C support for v3.
You might have luck looking at PCCTS (which is the ancestor of  
ANTLR). PCCTS does plain C, IIRC.
I think it is still maintained, but I've never used it.

HTH,

Kay
From parrt at cs.usfca.edu  Sat Feb  4 16:13:32 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Sat Feb  4 16:13:35 2006
Subject: [antlr-interest] generating cyclic state machines in Java
Message-ID: <ADA1C8FF-C687-4664-ABBE-E5DE32FF36AD@cs.usfca.edu>

Hi,

When generating v3 Java code, the tiny DFA class objects fit easily  
into the Java output file, but after compilation, you see hundreds  
of .class files :(  Any suggestions?  The key is that we must handle  
arbitrary cyclic DFA with heterogeneous states; i.e., each state has  
to be able to deal with semantic predicates etc...  I'm convinced  
arbitrary gotos cannot be faked in pure java without a method call...

Ugh...i hate looking at the output dir now :(

Ter
From sunjigang1965 at yahoo.com.cn  Sat Feb  4 17:11:03 2006
From: sunjigang1965 at yahoo.com.cn (=?gb2312?q?=CB=EF=BC=CD=B8=D5=20Jigang=20(Robert)=20Sun?=)
Date: Sat Feb  4 17:11:08 2006
Subject: [antlr-interest] problem with using 2.7.6
Message-ID: <20060205011103.49694.qmail@web15704.mail.cnb.yahoo.com>

Here is my grammar--
   
  primaryExp returns [object r=null] {object e;}
 :
   num:INTEGER_LITERAL {r=int.Parse(num.getText());} 
   | "true" {r=true;}
   | "false" {r=false;}
   | id:ID {r=retrive(id.getText());}
   |"new" "int" LSQUARE e=expression RSQUARE 
   {if (e is  System.Int32) 
     r=new int [(System.Int32)e];
     else
      Console.WriteLine("Integer type data expected");
    } //new int[3],
    
      | "new" idd:ID LPAREN RPAREN{}// r= new idd.getText() ();} // new a()
    
  ;
   
  Antlr 2.7.6 generates --
  ...
    try {      // for error handling
   switch ( LA(1) )
   {
   case INTEGER_LITERAL:
   {
    num = LT(1);
    num_AST = astFactory.create(num);
    astFactory.addASTChild(ref currentAST, num_AST);
    match(INTEGER_LITERAL);
    r=int.Parse(num.getText());_ttype = INTL;
    primaryExp_AST = currentAST.root;
    break;
   }
  ....
   
  C# compiler reports the following statement has some invalid argument, Argument '1' should not be passed with 'ref' keyword: 
    astFactory.addASTChild(ref currentAST, num_AST);
   
  The above grammar works ok with 2.7.5
   
  Cheers

  Jigang

		
---------------------------------
 —≈ª¢1G√‚∑—” œ‰∞Ÿ∑÷∞Ÿ∑¿¿¨ª¯–≈
 —≈ª¢÷˙ ÷-À—À˜°¢…±∂æ°¢∑¿…ß»≈  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060205/72d5b109/attachment.html
From jbarnesweb at yahoo.com  Sat Feb  4 17:27:30 2006
From: jbarnesweb at yahoo.com (Jeff Barnes)
Date: Sat Feb  4 17:27:33 2006
Subject: [antlr-interest] generating cyclic state machines in Java
In-Reply-To: <ADA1C8FF-C687-4664-ABBE-E5DE32FF36AD@cs.usfca.edu>
Message-ID: <20060205012730.7901.qmail@web54506.mail.yahoo.com>

--- Terence Parr <parrt@cs.usfca.edu> wrote:

> When generating v3 Java code, the tiny DFA class
> objects fit easily  
> into the Java output file, but after compilation,
> you see hundreds  
> of .class files :(  Any suggestions?  The key is
> that we must handle  
> arbitrary cyclic DFA with heterogeneous states;

I had a similar problem recently. Not only are more
classes ugly (sorry for the bluntness), but public
(and protected if you will) methods on classes should
be *tested*. Sheesh that's a lot of work.

I reasoned that it was better to solve the problem in
one of the meta layers and have fewer classes (more
instances).

In this solution, the work is in the initialization.
That's where the structural heirarchy of the instances
is defined. I think its more elegant to solve the
problem at the structural level.

Thanks for letting me input .02.

Jeff


From jbarnesweb at yahoo.com  Sat Feb  4 17:27:30 2006
From: jbarnesweb at yahoo.com (Jeff Barnes)
Date: Sat Feb  4 17:27:37 2006
Subject: [antlr-interest] generating cyclic state machines in Java
In-Reply-To: <ADA1C8FF-C687-4664-ABBE-E5DE32FF36AD@cs.usfca.edu>
Message-ID: <20060205012730.7901.qmail@web54506.mail.yahoo.com>

--- Terence Parr <parrt@cs.usfca.edu> wrote:

> When generating v3 Java code, the tiny DFA class
> objects fit easily  
> into the Java output file, but after compilation,
> you see hundreds  
> of .class files :(  Any suggestions?  The key is
> that we must handle  
> arbitrary cyclic DFA with heterogeneous states;

I had a similar problem recently. Not only are more
classes ugly (sorry for the bluntness), but public
(and protected if you will) methods on classes should
be *tested*. Sheesh that's a lot of work.

I reasoned that it was better to solve the problem in
one of the meta layers and have fewer classes (more
instances).

In this solution, the work is in the initialization.
That's where the structural heirarchy of the instances
is defined. I think its more elegant to solve the
problem at the structural level.

Thanks for letting me input .02.

Jeff


From inshua at gmail.com  Sat Feb  4 18:54:20 2006
From: inshua at gmail.com (=?GB2312?B?0MLC8g==?=)
Date: Sat Feb  4 18:54:22 2006
Subject: [antlr-interest] 
	Hi, is there anybody tell me how to get parse tree?
Message-ID: <2506dcb70602041854o995f0d8j@mail.gmail.com>

as (1+2) + 3
parse tree will include the "(" token, which will be ignore in AST.
so the expression (1+2) has 5 leaf : ( , 1, + , 2,  ).

for I wanna make an IDE, so locating source code is necessary, is there
anybody tell me about it?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060205/633cd912/attachment.html
From open.zone at virgin.net  Sat Feb  4 20:09:52 2006
From: open.zone at virgin.net (Micheal J)
Date: Sat Feb  4 19:53:27 2006
Subject: [antlr-interest] problem with using 2.7.6
In-Reply-To: <20060205011103.49694.qmail@web15704.mail.cnb.yahoo.com>
Message-ID: <004301c62a0a$04d69890$6402a8c0@hercules>

You're still using the 2.7.5 C# runtime assembly(ies). You need to build and use the C# runtime assembly(ies) that comes with 2.7.6 instead. There's a VS.NET solution and/or a NAnt build script to help with that in $ANTLR_DIR$\lib\csharp.
 
Cheers,
 
Micheal
 

-----Original Message-----
From: antlr-interest-bounces@antlr.org [mailto:antlr-interest-bounces@antlr.org] On Behalf Of ?????? Jigang (Robert) Sun
Sent: 05 February 2006 01:11
To: antlr-interest@antlr.org
Subject: [antlr-interest] problem with using 2.7.6


Here is my grammar--
 
primaryExp returns [object r=null] {object e;}
 :
   num:INTEGER_LITERAL {r=int.Parse(num.getText());} 
   | "true" {r=true;}
   | "false" {r=false;}
   | id:ID {r=retrive(id.getText());}
   |"new" "int" LSQUARE e=expression RSQUARE 
   {if (e is  System.Int32) 
     r=new int [(System.Int32)e];
     else
      Console.WriteLine("Integer type data expected");
    } //new int[3],
    
      | "new" idd:ID LPAREN RPAREN{}// r= new idd.getText() ();} // new a()
    
  ;
 
Antlr 2.7.6 generates --
...
  try {      // for error handling
   switch ( LA(1) )
   {
   case INTEGER_LITERAL:
   {
    num = LT(1);
    num_AST = astFactory.create(num);
    astFactory.addASTChild(ref currentAST, num_AST);
    match(INTEGER_LITERAL);
    r=int.Parse(num.getText());_ttype = INTL;
    primaryExp_AST = currentAST.root;
    break;
   }
....
 
C# compiler reports the following statement has some invalid argument, Argument '1' should not be passed with 'ref' keyword: 
  astFactory.addASTChild(ref currentAST, num_AST);
 
The above grammar works ok with 2.7.5
 
Cheers

Jigang



  _____  

??1G??????????? <http://cn.mail.yahoo.com> 
????-????????? <http://cn.zs.yahoo.com>  

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060205/92021704/attachment.html
From mdiggory at latte.harvard.edu  Sun Feb  5 10:42:09 2006
From: mdiggory at latte.harvard.edu (Mark R. Diggory)
Date: Sun Feb  5 10:42:24 2006
Subject: [antlr-interest] Handling lexical nondeterminism in Tokens
Message-ID: <43E64701.7070800@latte.harvard.edu>

I'm still working on building a Parser for our query syntax. I've 
encountered an issue with nondeterminism. I've included my grammar file:

My question is how can I assure that the boolean predicate AND not the 
quoted string literal "you AND I" do not collide? I'd be very thankful 
to anyone with comments about obvious problems with my grammar file.

thanks,
Mark

> class SearchQueryParser extends Parser;
>     options
>     {
>           k=3;
>         exportVocab=SearchQuery;
>         buildAST = true;   // uses CommonAST by default
>         
>     }
>
>
> expr
>     :    
>         mexpr ((AND|OR|NOT) mexpr)*
>     ;
>
> mexpr
>     :    
>         LITERAL^ | IDENTIFIER^ ((EQUALS|NOT_EQUALS|LT|LTE|GT|GTE) 
> LITERAL^)+
>     ;
>
>
> atom
>       :    
>           IDENTIFIER | LEFT_PAREN! expr RIGHT_PAREN!
>     ;
>
> class SearchQueryLexer extends Lexer;
>     options
>     {
>         charVocabulary='\3'..'\377';
>     }
>
> WS
>     :
>         ('\n' | ' ' | '\t' | '\r')+
>         {
>             $setType(Token.SKIP);
>         }
>     ;
>
>
> protected
> SINGLE_QUOTE_STRING
>     :
>         '\''! (~('\''))* '\''!
>     ;
>
> protected
> DOUBLE_QUOTE_STRING
>     :
>         '"'! (~('"'))* '"'!
>     ;
>
> LITERAL
>     :
>         SINGLE_QUOTE_STRING | DOUBLE_QUOTE_STRING
>     ;
>
> IDENTIFIER
>
>     options
>     {
>         testLiterals=true;
>     }
>
>     :     
>         ('\241'..'\377'|'a'..'z'|'A'..'Z'|'_') 
> ('\241'..'\377'|'a'..'z'|'A'..'Z'|'-'|'_'|'0'..'9'|'.')*    
>     ;
>
> LEFT_PAREN
>     :    '('        ;
>
> RIGHT_PAREN    
>     :    ')'        ;
>
> NOT
>     :    ("NOT"|"not")    ;
>
> AND
>     :    ("AND"|"and")    ;
>
> OR
>     :    ("OR"|"or")        ;
>
> EQUALS
>     :    '='        ;
>
> NOT_EQUALS
>     :    "<>"    ;
>
> LT
>     :    '<'        ;
>
> LTE
>     :    "<="    ;
>
> GT
>     :    '>'        ;
>
> GTE
>     :    ">="    ;


From jbarnesweb at yahoo.com  Sun Feb  5 13:41:35 2006
From: jbarnesweb at yahoo.com (Jeff Barnes)
Date: Sun Feb  5 13:41:37 2006
Subject: [antlr-interest]  Hi,
	is there anybody tell me how to get parse tree?
In-Reply-To: <2506dcb70602041854o995f0d8j@mail.gmail.com>
Message-ID: <20060205214135.58803.qmail@web54501.mail.yahoo.com>

You should probably read the fine manual again. It
took me several readings to begin to wrap my head
around the subject matter. 

To get the AST to ignore '(' your parser should have
something along the lines of

expr:
    ((LPAREN)?)! multexpr (PLUS^ multexpr)?
((RPAREN)?)!
;

Tweak until it fits...

Regards,
Jeff

--- ???? <inshua@gmail.com> wrote:

> as (1+2) + 3
> parse tree will include the "(" token, which will be
> ignore in AST.
> so the expression (1+2) has 5 leaf : ( , 1, + , 2, 
> ).
> 
> for I wanna make an IDE, so locating source code is
> necessary, is there
> anybody tell me about it?
> 

From inshua at gmail.com  Sun Feb  5 18:20:23 2006
From: inshua at gmail.com (=?GB2312?B?0MLC8g==?=)
Date: Sun Feb  5 18:20:25 2006
Subject: Fwd: [antlr-interest] Hi,
	is there anybody tell me how to get parse tree?
In-Reply-To: <2506dcb70602051819x78c0b64p@mail.gmail.com>
References: <2506dcb70602041854o995f0d8j@mail.gmail.com>
	<20060205214135.58803.qmail@web54501.mail.yahoo.com>
	<2506dcb70602051819x78c0b64p@mail.gmail.com>
Message-ID: <2506dcb70602051820g314f59a3s@mail.gmail.com>

---------- Forwarded message ----------
From: ?? <inshua@gmail.com>
Date: 2006-2-6 ??10:19
Subject: Re: [antlr-interest] Hi, is there anybody tell me how to get parse
tree?
To: Jeff Barnes <jbarnesweb@yahoo.com>


Hello,

Thank your help.

Thus my problem is,  "(" SHOULD be included in the tree,(In  classic book,
this kind of tree named parse tree, not AST). Thanks for your hint, I'v
remove the "!" symbol from rule, now "(" and ")" are included in the tree.

But, only when there isn't space in the  expression, it can works ok.
Repeat my goal :
An expression before parse:
 ( 1 + 2 ) - 3
when parse complete,user get a visible tree:
-
   +  1
      2
   3

now user click "+" node, the text  "(1+2)" will be highlighted as:

( 1 + 2 ) - 3

:) interesting?

thanks.

Shimin

2006/2/6, Jeff Barnes <jbarnesweb@yahoo.com>:
>
> You should probably read the fine manual again. It
> took me several readings to begin to wrap my head
> around the subject matter.
>
> To get the AST to ignore '(' your parser should have
> something along the lines of
>
> expr:
>    ((LPAREN)?)! multexpr (PLUS^ multexpr)?
> ((RPAREN)?)!
> ;
>
> Tweak until it fits...
>
> Regards,
> Jeff
>
> --- ???? <inshua@gmail.com> wrote:
>
> > as (1+2) + 3
> > parse tree will include the "(" token, which will be
> > ignore in AST.
> > so the expression (1+2) has 5 leaf : ( , 1, + , 2,
> > ).
> >
> > for I wanna make an IDE, so locating source code is
> > necessary, is there
> > anybody tell me about it?
> >
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060206/29382995/attachment.html
From kroepke at dolphin-services.de  Sun Feb  5 19:54:30 2006
From: kroepke at dolphin-services.de (Kay Roepke)
Date: Sun Feb  5 19:54:41 2006
Subject: [antlr-interest] [v3] not including text in token. Still possible?
Message-ID: <1F4404A0-4EDD-49F5-A3F9-75FC2EE0905E@dolphin-services.de>

Hi!

Am I mistaken, have I missed anything, or am I plain stupid? (Quite a  
possibility...;))

In v2 one could suffix a literal or tokenref with a '!' and keep that  
(token's) text from being included in the token, like this:

BAREWORD
	:	'<'! ID (PACKAGEDELIM ID)* '>'!
	{token = null;}
	;

protected PACKAGEDELIM
	:	'::'
	;


protected ID	:	('a'..'z' | 'A'..'Z' | '_')+
	;


Running this with tonight's version of v3 from the depot I get:
classDump:~/Projects/examples-v3/java/perl kroepke$ java Main  
Test_input.txt
tokens=package <openBC::Debug>;


seen packageStmt
seen declaration
tree=(PACKAGE <openBC::Debug>)

The angle brackets are still being included in the token.
This example is a bit contrived - what I was actually looking for was  
to force the PACKAGEDELIM and ID rules not to
generate a token by themselves. I want all the text to end up in a  
single BAREWORD token. For this I currently have to
nullify the token after matching 'ID (PACKAGEDELIM ID)*'. Is there an  
easier way to do this? I'd rather not generate
all those tokens just to discard them later on.
If I don't set 'token = null' I end up with an ID token which causes  
big trouble in the parser later on. This is obviously
not what I want. I ask the lexer for a BAREWORD token and get back an  
ID token...

Also, is there a way to get back the behavior of EA7 when it comes to  
printing the tokens of a CommonTokenStream? It used
to show a lot of extra information about the tokens. A first glance  
at CommonTokenStream.java didn't reveal the secret to me :(

Thanks,

Kay
From parrt at cs.usfca.edu  Sun Feb  5 20:05:53 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Sun Feb  5 20:05:56 2006
Subject: [antlr-interest] [v3] not including text in token. Still possible?
In-Reply-To: <1F4404A0-4EDD-49F5-A3F9-75FC2EE0905E@dolphin-services.de>
References: <1F4404A0-4EDD-49F5-A3F9-75FC2EE0905E@dolphin-services.de>
Message-ID: <A7E1D589-75F6-4C11-8CC9-C6AF8957FD31@cs.usfca.edu>


On Feb 5, 2006, at 7:54 PM, Kay Roepke wrote:

> Hi!
>
> Am I mistaken, have I missed anything, or am I plain stupid? (Quite  
> a possibility...;))
>
> In v2 one could suffix a literal or tokenref with a '!' and keep  
> that (token's) text from being included in the token, like this:

Hi!  I haven't figured out to make it do that for v3 yet.  I don't  
create strings for a token (just indexes into the char buffer) so  
it's hard to do modifications.  I definitely need it though.

> Also, is there a way to get back the behavior of EA7 when it comes  
> to printing the tokens of a CommonTokenStream? It used
> to show a lot of extra information about the tokens. A first glance  
> at CommonTokenStream.java didn't reveal the secret to me :(

I think it's toDebugString or something...

Ter
From kroepke at dolphin-services.de  Sun Feb  5 20:26:18 2006
From: kroepke at dolphin-services.de (Kay Roepke)
Date: Sun Feb  5 20:26:26 2006
Subject: [antlr-interest] [v3] not including text in token. Still possible?
In-Reply-To: <A7E1D589-75F6-4C11-8CC9-C6AF8957FD31@cs.usfca.edu>
References: <1F4404A0-4EDD-49F5-A3F9-75FC2EE0905E@dolphin-services.de>
	<A7E1D589-75F6-4C11-8CC9-C6AF8957FD31@cs.usfca.edu>
Message-ID: <131D3874-9B94-42BD-95A2-BA0EF4CB291B@dolphin-services.de>


On 6. Feb 2006, at 5:05 Uhr, Terence Parr wrote:

> Hi!  I haven't figured out to make it do that for v3 yet.  I don't  
> create strings for a token (just indexes into the char buffer) so  
> it's hard to do modifications.  I definitely need it though.

Couldn't you fiddle with the indices into the buffer? Aah no you  
can't. Blimey. This really is a problem of non-contiguous ranges, is  
it not?
If the tokens/text to ignore is always at the start or end of the  
current token it's easy, but once you get one of those in the middle  
you are
SOL. So I guess it's either storing ranges or coming up with some  
really clever idea ;)
Of course, you could argue that the storing of indices is really an  
implementation detail of the CommonToken class and it could copy the
token text if need be without having to tell anyone (i.e. the user).  
One possibility would be to copy the text if you use the not-include- 
this-tokens-text
feature.
OTOH, using ranges shouldn't that much of a problem either. It just  
makes the actual returning of the text a bit more complicated. That's  
probably
still a lot cheaper than to copy it.

>> Also, is there a way to get back the behavior of EA7 when it comes  
>> to printing the tokens of a CommonTokenStream? It used
>> to show a lot of extra information about the tokens. A first  
>> glance at CommonTokenStream.java didn't reveal the secret to me :(
>
> I think it's toDebugString or something...

aah now I see it. The new version does .getText() on each token. ea7  
was doing toString() on them. Ok, just gotta do it manually
then. No trouble.

Thanks,
Kay
From ric.klaren at gmail.com  Mon Feb  6 00:26:28 2006
From: ric.klaren at gmail.com (Ric Klaren)
Date: Mon Feb  6 00:26:35 2006
Subject: [antlr-interest] ANTLR C++ code without std::string
In-Reply-To: <20060203233728.82446.qmail@web51704.mail.yahoo.com>
References: <20060203233728.82446.qmail@web51704.mail.yahoo.com>
Message-ID: <bc607a4e0602060026s43598455r102ad0263200c893@mail.gmail.com>

Hi,

On 2/4/06, ury segal <ury_segal@guardium.com> wrote:
> Is there a way to generate ANTLR C++
> code that uses some other "string" than
> std::string? I would like to use a class string
> that has a different memory allocator.

With antlr2 you'd have to modify the codegenerator and support library.

Cheers,

Ric
From mail at martin-probst.com  Mon Feb  6 01:43:12 2006
From: mail at martin-probst.com (Martin Probst)
Date: Mon Feb  6 02:01:16 2006
Subject: [antlr-interest] help requested for selective whitespace
In-Reply-To: <43E3CC13.3000209@sympatico.ca>
References: <1138585445.7879.16.camel@localhost>
	<1138762449.7476.8.camel@localhost> <1138844785.2032.8.camel@localhost>
	<1138880545.9733.5.camel@localhost.localdomain>
	<43E3CC13.3000209@sympatico.ca>
Message-ID: <1139218992.7782.18.camel@localhost.localdomain>

> note_desc
>   : NOTENAME (OCTAVE)? (DURATION)? (DOT)?
>   ;

What about:

note_desc
    : NOTENAME WS (OCTAVE)? WS (DURATION)? WS (DOT)?
    ;

and in the Lexer

WS
    : ( ' ' | '\t' | '\n' | '\r' )+;
(no $setType(Token.SKIP) here!).

This way you can explicitly ask for white space to be between your
tokens.

Martin

From mail at martin-probst.com  Mon Feb  6 02:16:36 2006
From: mail at martin-probst.com (Martin Probst)
Date: Mon Feb  6 03:28:40 2006
Subject: Fwd: [antlr-interest] Hi, is there anybody tell me how to get
	parse tree?
In-Reply-To: <2506dcb70602051820g314f59a3s@mail.gmail.com>
References: <2506dcb70602041854o995f0d8j@mail.gmail.com>
	<20060205214135.58803.qmail@web54501.mail.yahoo.com>
	<2506dcb70602051819x78c0b64p@mail.gmail.com>
	<2506dcb70602051820g314f59a3s@mail.gmail.com>
Message-ID: <1139220996.7782.23.camel@localhost.localdomain>

I think you call it parse tree if you include a tree node for each rule
you're passing through, not only for each token. ANTLR doesn't do this,
and to me it's pretty obscure for what parse trees might be useful.

 
> Thus my problem is,  "(" SHOULD be included in the tree,(In  classic
> book, this kind of tree named parse tree, not AST). Thanks for your
> hint, I'v remove the "!" symbol from rule, now "(" and ")" are
> included in the tree. 

> 

From gabriel.adrian.radu at googlemail.com  Mon Feb  6 03:40:47 2006
From: gabriel.adrian.radu at googlemail.com (Gabriel Radu)
Date: Mon Feb  6 03:40:49 2006
Subject: [antlr-interest] Handling lexical nondeterminism in Tokens
In-Reply-To: <43E64701.7070800@latte.harvard.edu>
References: <43E64701.7070800@latte.harvard.edu>
Message-ID: <67e2ed240602060340i11c6e102m@mail.gmail.com>

Dear Mark,

I suggest using syntactic predicates. Also increasing the lexers look
ahead to 2 (k=2) for example may sort out the ambiguity between LT and
LTE, and GT and GTE. However, if you use syntactic predicates for all
tokens, increasing the look ahead may not be necessary.

An example of using syntactic predicates for your grammar is following:


class SearchQueryLexer extends Lexer;
    options
    {
        charVocabulary='\3'..'\377';
    }


MAIN_LEXER_RULE
  : ( LITERAL ) => ( LITERAL { $setType( LITERAL ); } )

  | ( NOT_EQUALS ) => ( NOT_EQUALS { $setType( NOT_EQUALS ); } )
  | ( LTE ) => ( LTE { $setType( LTE ); } )
  | ( GTE ) => ( GTE { $setType( GTE ); } )

  | ( LT ) => ( LT { $setType( LT ); } )
  | ( GT ) => ( GT { $setType( GT ); } )

  | ( NOT ) => ( NOT { $setType( NOT ); } )
  | ( AND ) => ( AND { $setType( AND ); } )
  | ( OR ) => ( OR { $setType( OR ); } )

  | ( LEFT_PAREN ) => ( LEFT_PAREN { $setType( LEFT_PAREN ); } )
  | ( RIGHT_PAREN ) => ( RIGHT_PAREN { $setType( RIGHT_PAREN ); } )

  | ( EQUALS ) => ( EQUALS { $setType( EQUALS ); } )

  | ( IDENTIFIER ) => ( IDENTIFIER { $setType( IDENTIFIER ); } )

  | ( WS ) => WS

  ;

protected
WS
    :
        ('\n' | ' ' | '\t' | '\r')+
        {
            $setType(Token.SKIP);
        }
    ;


protected
SINGLE_QUOTE_STRING
    :
        '\''! (~('\''))* '\''!
    ;

protected
DOUBLE_QUOTE_STRING
    :
        '"'! (~('"'))* '"'!
    ;

protected
LITERAL
    :
        SINGLE_QUOTE_STRING | DOUBLE_QUOTE_STRING
    ;

protected
IDENTIFIER

    options
    {
        testLiterals=true;
    }

    :
        ('\241'..'\377'|'a'..'z'|'A'..'Z'|'_')
('\241'..'\377'|'a'..'z'|'A'..'Z'|'-'|'_'|'0'..'9'|'.')*
    ;

protected
LEFT_PAREN
    :    '('        ;

protected
RIGHT_PAREN
    :    ')'        ;

protected
NOT
    :    ("NOT"|"not")    ;

protected
AND
    :    ("AND"|"and")    ;

protected
OR
    :    ("OR"|"or")        ;

protected
EQUALS
    :    '='        ;

protected
NOT_EQUALS
    :    "<>"    ;

protected
LT
    :    '<'        ;

protected
LTE
    :    "<="    ;

protected
GT
    :    '>'        ;

protected
GTE
    :    ">="    ;


The syntactic predicates are in MAIN_LEXER_RULE. The order of
productions (alternative rules) in MAIN_LEXER_RULE is important,
because the lexer will try to match them in the order they are
declared and will stop as soon as it finds a match. So for example LTE
must be above LT because other ways the lexer will match the LT and
then an EQUALS in stead of LTE.

Let me know if this has solved your problem.


Best regards,
Gabriel




On 05/02/06, Mark R. Diggory <mdiggory@latte.harvard.edu> wrote:
> I'm still working on building a Parser for our query syntax. I've
> encountered an issue with nondeterminism. I've included my grammar file:
>
> My question is how can I assure that the boolean predicate AND not the
> quoted string literal "you AND I" do not collide? I'd be very thankful
> to anyone with comments about obvious problems with my grammar file.
>
> thanks,
> Mark
>
> > class SearchQueryParser extends Parser;
> >     options
> >     {
> >           k=3;
> >         exportVocab=SearchQuery;
> >         buildAST = true;   // uses CommonAST by default
> >
> >     }
> >
> >
> > expr
> >     :
> >         mexpr ((AND|OR|NOT) mexpr)*
> >     ;
> >
> > mexpr
> >     :
> >         LITERAL^ | IDENTIFIER^ ((EQUALS|NOT_EQUALS|LT|LTE|GT|GTE)
> > LITERAL^)+
> >     ;
> >
> >
> > atom
> >       :
> >           IDENTIFIER | LEFT_PAREN! expr RIGHT_PAREN!
> >     ;
> >
> > class SearchQueryLexer extends Lexer;
> >     options
> >     {
> >         charVocabulary='\3'..'\377';
> >     }
> >
> > WS
> >     :
> >         ('\n' | ' ' | '\t' | '\r')+
> >         {
> >             $setType(Token.SKIP);
> >         }
> >     ;
> >
> >
> > protected
> > SINGLE_QUOTE_STRING
> >     :
> >         '\''! (~('\''))* '\''!
> >     ;
> >
> > protected
> > DOUBLE_QUOTE_STRING
> >     :
> >         '"'! (~('"'))* '"'!
> >     ;
> >
> > LITERAL
> >     :
> >         SINGLE_QUOTE_STRING | DOUBLE_QUOTE_STRING
> >     ;
> >
> > IDENTIFIER
> >
> >     options
> >     {
> >         testLiterals=true;
> >     }
> >
> >     :
> >         ('\241'..'\377'|'a'..'z'|'A'..'Z'|'_')
> > ('\241'..'\377'|'a'..'z'|'A'..'Z'|'-'|'_'|'0'..'9'|'.')*
> >     ;
> >
> > LEFT_PAREN
> >     :    '('        ;
> >
> > RIGHT_PAREN
> >     :    ')'        ;
> >
> > NOT
> >     :    ("NOT"|"not")    ;
> >
> > AND
> >     :    ("AND"|"and")    ;
> >
> > OR
> >     :    ("OR"|"or")        ;
> >
> > EQUALS
> >     :    '='        ;
> >
> > NOT_EQUALS
> >     :    "<>"    ;
> >
> > LT
> >     :    '<'        ;
> >
> > LTE
> >     :    "<="    ;
> >
> > GT
> >     :    '>'        ;
> >
> > GTE
> >     :    ">="    ;
>
>
>
From kroepke at dolphin-services.de  Mon Feb  6 04:34:42 2006
From: kroepke at dolphin-services.de (Kay Roepke)
Date: Mon Feb  6 04:34:50 2006
Subject: [antlr-interest] [v3] not including text in token. Still possible?
In-Reply-To: <A7E1D589-75F6-4C11-8CC9-C6AF8957FD31@cs.usfca.edu>
References: <1F4404A0-4EDD-49F5-A3F9-75FC2EE0905E@dolphin-services.de>
	<A7E1D589-75F6-4C11-8CC9-C6AF8957FD31@cs.usfca.edu>
Message-ID: <69667D34-0823-4156-B128-A242A12718FA@dolphin-services.de>


On 6. Feb 2006, at 5:05 Uhr, Terence Parr wrote:

> Hi!  I haven't figured out to make it do that for v3 yet.  I don't  
> create strings for a token (just indexes into the char buffer) so  
> it's hard to do modifications.  I definitely need it though.

Hi Ter!

I'd like to give this one a try just for the sake of it. It really  
doesn't matter to me whether it'll end up in ANTLR or not. I just  
like to
try to implement it to familiarize myself with the source.
As far as I can tell, I would need to have a look at antlr.g (to see  
if it is correctly recognizing the '!') and then add the supporting code
to codegen.g. After that I have to figure out how to do the actual  
codegeneration in Java.stg.
Is that correct?

Regards,

Kay
From mdiggory at latte.harvard.edu  Mon Feb  6 07:25:43 2006
From: mdiggory at latte.harvard.edu (Mark R. Diggory)
Date: Mon Feb  6 07:26:58 2006
Subject: [antlr-interest] Handling lexical nondeterminism in Tokens
In-Reply-To: <67e2ed240602060340i11c6e102m@mail.gmail.com>
References: <43E64701.7070800@latte.harvard.edu>
	<67e2ed240602060340i11c6e102m@mail.gmail.com>
Message-ID: <43E76A77.5070208@latte.harvard.edu>

Thanks, I think I understand how this will help in the Lexer. I'm 
currently having problems how to capture how to properly represent the 
syntax in the Parser

Here's a clarification of what I should be able to do with the query 
language:

The smallest "atom" is a LITERAL string, currently this can be in quotes 
or not in quotes. For example:

> United States
> "Untied States"

Alternatively a "atom" can be an equivalence relation. For instance:

> title="Untied States"
> title<>"Untied States"
> date>=2006

Each atom can have parentheses around it.

> (title="Untied States")

equivalence relations can be joined using boolean relations

> title="Untied States" AND date>=2006
> title="Untied States" OR date>=2006
> title="Untied States" NOT date>=2006

boolean relations can be wrapped in parentheses to control precedence.

> title="Untied States" AND (date>=2006 OR author=Steven King)

I've been trying to capture this using the following parser, but its 
clear now that I'm missing the mark:

>class SearchQueryParser extends Parser;
>    options
>    {
>          k=3;
>        exportVocab=SearchQuery;
>        buildAST = true;   // uses CommonAST by default
>
>    }
>
>expr
>    :
>        mexpr ((AND|OR|NOT) mexpr)*
>    ;
>
>mexpr
>    :
>        LITERAL | (IDENTIFIER (EQUALS|NOT_EQUALS|LT|LTE|GT|GTE) LITERAL)+ 
>    ;
>
>atom
>      :
>          LEFT_PAREN! mexpr RIGHT_PAREN! | LEFT_PAREN! expr RIGHT_PAREN!
>    ;
>
thanks again for your advice,
Mark

Gabriel Radu wrote:

>Dear Mark,
>
>I suggest using syntactic predicates. Also increasing the lexers look
>ahead to 2 (k=2) for example may sort out the ambiguity between LT and
>LTE, and GT and GTE. However, if you use syntactic predicates for all
>tokens, increasing the look ahead may not be necessary.
>
>An example of using syntactic predicates for your grammar is following:
>
>
>class SearchQueryLexer extends Lexer;
>    options
>    {
>        charVocabulary='\3'..'\377';
>    }
>
>
>MAIN_LEXER_RULE
>  : ( LITERAL ) => ( LITERAL { $setType( LITERAL ); } )
>
>  | ( NOT_EQUALS ) => ( NOT_EQUALS { $setType( NOT_EQUALS ); } )
>  | ( LTE ) => ( LTE { $setType( LTE ); } )
>  | ( GTE ) => ( GTE { $setType( GTE ); } )
>
>  | ( LT ) => ( LT { $setType( LT ); } )
>  | ( GT ) => ( GT { $setType( GT ); } )
>
>  | ( NOT ) => ( NOT { $setType( NOT ); } )
>  | ( AND ) => ( AND { $setType( AND ); } )
>  | ( OR ) => ( OR { $setType( OR ); } )
>
>  | ( LEFT_PAREN ) => ( LEFT_PAREN { $setType( LEFT_PAREN ); } )
>  | ( RIGHT_PAREN ) => ( RIGHT_PAREN { $setType( RIGHT_PAREN ); } )
>
>  | ( EQUALS ) => ( EQUALS { $setType( EQUALS ); } )
>
>  | ( IDENTIFIER ) => ( IDENTIFIER { $setType( IDENTIFIER ); } )
>
>  | ( WS ) => WS
>
>  ;
>
>protected
>WS
>    :
>        ('\n' | ' ' | '\t' | '\r')+
>        {
>            $setType(Token.SKIP);
>        }
>    ;
>
>
>protected
>SINGLE_QUOTE_STRING
>    :
>        '\''! (~('\''))* '\''!
>    ;
>
>protected
>DOUBLE_QUOTE_STRING
>    :
>        '"'! (~('"'))* '"'!
>    ;
>
>protected
>LITERAL
>    :
>        SINGLE_QUOTE_STRING | DOUBLE_QUOTE_STRING
>    ;
>
>protected
>IDENTIFIER
>
>    options
>    {
>        testLiterals=true;
>    }
>
>    :
>        ('\241'..'\377'|'a'..'z'|'A'..'Z'|'_')
>('\241'..'\377'|'a'..'z'|'A'..'Z'|'-'|'_'|'0'..'9'|'.')*
>    ;
>
>protected
>LEFT_PAREN
>    :    '('        ;
>
>protected
>RIGHT_PAREN
>    :    ')'        ;
>
>protected
>NOT
>    :    ("NOT"|"not")    ;
>
>protected
>AND
>    :    ("AND"|"and")    ;
>
>protected
>OR
>    :    ("OR"|"or")        ;
>
>protected
>EQUALS
>    :    '='        ;
>
>protected
>NOT_EQUALS
>    :    "<>"    ;
>
>protected
>LT
>    :    '<'        ;
>
>protected
>LTE
>    :    "<="    ;
>
>protected
>GT
>    :    '>'        ;
>
>protected
>GTE
>    :    ">="    ;
>
>
>The syntactic predicates are in MAIN_LEXER_RULE. The order of
>productions (alternative rules) in MAIN_LEXER_RULE is important,
>because the lexer will try to match them in the order they are
>declared and will stop as soon as it finds a match. So for example LTE
>must be above LT because other ways the lexer will match the LT and
>then an EQUALS in stead of LTE.
>
>Let me know if this has solved your problem.
>
>
>Best regards,
>Gabriel
>
>
>
>
>On 05/02/06, Mark R. Diggory <mdiggory@latte.harvard.edu> wrote:
>  
>
>>I'm still working on building a Parser for our query syntax. I've
>>encountered an issue with nondeterminism. I've included my grammar file:
>>
>>My question is how can I assure that the boolean predicate AND not the
>>quoted string literal "you AND I" do not collide? I'd be very thankful
>>to anyone with comments about obvious problems with my grammar file.
>>
>>thanks,
>>Mark
>>
>>    
>>
>>>class SearchQueryParser extends Parser;
>>>    options
>>>    {
>>>          k=3;
>>>        exportVocab=SearchQuery;
>>>        buildAST = true;   // uses CommonAST by default
>>>
>>>    }
>>>
>>>
>>>expr
>>>    :
>>>        mexpr ((AND|OR|NOT) mexpr)*
>>>    ;
>>>
>>>mexpr
>>>    :
>>>        LITERAL^ | IDENTIFIER^ ((EQUALS|NOT_EQUALS|LT|LTE|GT|GTE)
>>>LITERAL^)+
>>>    ;
>>>
>>>
>>>atom
>>>      :
>>>          IDENTIFIER | LEFT_PAREN! expr RIGHT_PAREN!
>>>    ;
>>>
>>>class SearchQueryLexer extends Lexer;
>>>    options
>>>    {
>>>        charVocabulary='\3'..'\377';
>>>    }
>>>
>>>WS
>>>    :
>>>        ('\n' | ' ' | '\t' | '\r')+
>>>        {
>>>            $setType(Token.SKIP);
>>>        }
>>>    ;
>>>
>>>
>>>protected
>>>SINGLE_QUOTE_STRING
>>>    :
>>>        '\''! (~('\''))* '\''!
>>>    ;
>>>
>>>protected
>>>DOUBLE_QUOTE_STRING
>>>    :
>>>        '"'! (~('"'))* '"'!
>>>    ;
>>>
>>>LITERAL
>>>    :
>>>        SINGLE_QUOTE_STRING | DOUBLE_QUOTE_STRING
>>>    ;
>>>
>>>IDENTIFIER
>>>
>>>    options
>>>    {
>>>        testLiterals=true;
>>>    }
>>>
>>>    :
>>>        ('\241'..'\377'|'a'..'z'|'A'..'Z'|'_')
>>>('\241'..'\377'|'a'..'z'|'A'..'Z'|'-'|'_'|'0'..'9'|'.')*
>>>    ;
>>>
>>>LEFT_PAREN
>>>    :    '('        ;
>>>
>>>RIGHT_PAREN
>>>    :    ')'        ;
>>>
>>>NOT
>>>    :    ("NOT"|"not")    ;
>>>
>>>AND
>>>    :    ("AND"|"and")    ;
>>>
>>>OR
>>>    :    ("OR"|"or")        ;
>>>
>>>EQUALS
>>>    :    '='        ;
>>>
>>>NOT_EQUALS
>>>    :    "<>"    ;
>>>
>>>LT
>>>    :    '<'        ;
>>>
>>>LTE
>>>    :    "<="    ;
>>>
>>>GT
>>>    :    '>'        ;
>>>
>>>GTE
>>>    :    ">="    ;
>>>      
>>>
>>
>>    
>>
From gabriel.adrian.radu at googlemail.com  Mon Feb  6 08:38:11 2006
From: gabriel.adrian.radu at googlemail.com (Gabriel Radu)
Date: Mon Feb  6 08:38:14 2006
Subject: [antlr-interest] Handling lexical nondeterminism in Tokens
In-Reply-To: <43E76A77.5070208@latte.harvard.edu>
References: <43E64701.7070800@latte.harvard.edu>
	<67e2ed240602060340i11c6e102m@mail.gmail.com>
	<43E76A77.5070208@latte.harvard.edu>
Message-ID: <67e2ed240602060838j17b98d09l@mail.gmail.com>

Dear Mark,

What about:

> class SearchQueryParser extends Parser;
>     options
>     {
>         k=3;
>         exportVocab=SearchQuery;
>         buildAST = true;   // uses CommonAST by default
>
>     }
>
> statement
>     : LEFT_PAREN! expr RIGHT_PAREN! EOST
>     | expr EOST
>     ;
>
> expr
>     : mexpr ( bool_relations LEFT_PAREN! expr RIGHT_PAREN! )*
>     ;
>
> mexpr
>     : atom ( bool_relations atom )*
>     ;
>
> atom
>     : IDENTIFIER equivalence_relation LITERAL
>     ;
>
> bool_relations : AND|OR|NOT ;
>
> equivalence_relation : EQUALS|NOT_EQUALS|LT|LTE|GT|GTE ;

where EOST is a token which marks the end of a statement. It can be
something like end of line or semicolon. Don't forget to add it to the
lexer as well.

Let me know how you are getting on.


Best regards,
Gabriel




On 06/02/06, Mark R. Diggory <mdiggory@latte.harvard.edu> wrote:
> Thanks, I think I understand how this will help in the Lexer. I'm
> currently having problems how to capture how to properly represent the
> syntax in the Parser
>
> Here's a clarification of what I should be able to do with the query
> language:
>
> The smallest "atom" is a LITERAL string, currently this can be in quotes
> or not in quotes. For example:
>
> > United States
> > "Untied States"
>
> Alternatively a "atom" can be an equivalence relation. For instance:
>
> > title="Untied States"
> > title<>"Untied States"
> > date>=2006
>
> Each atom can have parentheses around it.
>
> > (title="Untied States")
>
> equivalence relations can be joined using boolean relations
>
> > title="Untied States" AND date>=2006
> > title="Untied States" OR date>=2006
> > title="Untied States" NOT date>=2006
>
> boolean relations can be wrapped in parentheses to control precedence.
>
> > title="Untied States" AND (date>=2006 OR author=Steven King)
>
> I've been trying to capture this using the following parser, but its
> clear now that I'm missing the mark:
>
> >class SearchQueryParser extends Parser;
> >    options
> >    {
> >          k=3;
> >        exportVocab=SearchQuery;
> >        buildAST = true;   // uses CommonAST by default
> >
> >    }
> >
> >expr
> >    :
> >        mexpr ((AND|OR|NOT) mexpr)*
> >    ;
> >
> >mexpr
> >    :
> >        LITERAL | (IDENTIFIER (EQUALS|NOT_EQUALS|LT|LTE|GT|GTE) LITERAL)+
> >    ;
> >
> >atom
> >      :
> >          LEFT_PAREN! mexpr RIGHT_PAREN! | LEFT_PAREN! expr RIGHT_PAREN!
> >    ;
> >
> thanks again for your advice,
> Mark
>
> Gabriel Radu wrote:
>
> >Dear Mark,
> >
> >I suggest using syntactic predicates. Also increasing the lexers look
> >ahead to 2 (k=2) for example may sort out the ambiguity between LT and
> >LTE, and GT and GTE. However, if you use syntactic predicates for all
> >tokens, increasing the look ahead may not be necessary.
> >
> >An example of using syntactic predicates for your grammar is following:
> >
> >
> >class SearchQueryLexer extends Lexer;
> >    options
> >    {
> >        charVocabulary='\3'..'\377';
> >    }
> >
> >
> >MAIN_LEXER_RULE
> >  : ( LITERAL ) => ( LITERAL { $setType( LITERAL ); } )
> >
> >  | ( NOT_EQUALS ) => ( NOT_EQUALS { $setType( NOT_EQUALS ); } )
> >  | ( LTE ) => ( LTE { $setType( LTE ); } )
> >  | ( GTE ) => ( GTE { $setType( GTE ); } )
> >
> >  | ( LT ) => ( LT { $setType( LT ); } )
> >  | ( GT ) => ( GT { $setType( GT ); } )
> >
> >  | ( NOT ) => ( NOT { $setType( NOT ); } )
> >  | ( AND ) => ( AND { $setType( AND ); } )
> >  | ( OR ) => ( OR { $setType( OR ); } )
> >
> >  | ( LEFT_PAREN ) => ( LEFT_PAREN { $setType( LEFT_PAREN ); } )
> >  | ( RIGHT_PAREN ) => ( RIGHT_PAREN { $setType( RIGHT_PAREN ); } )
> >
> >  | ( EQUALS ) => ( EQUALS { $setType( EQUALS ); } )
> >
> >  | ( IDENTIFIER ) => ( IDENTIFIER { $setType( IDENTIFIER ); } )
> >
> >  | ( WS ) => WS
> >
> >  ;
> >
> >protected
> >WS
> >    :
> >        ('\n' | ' ' | '\t' | '\r')+
> >        {
> >            $setType(Token.SKIP);
> >        }
> >    ;
> >
> >
> >protected
> >SINGLE_QUOTE_STRING
> >    :
> >        '\''! (~('\''))* '\''!
> >    ;
> >
> >protected
> >DOUBLE_QUOTE_STRING
> >    :
> >        '"'! (~('"'))* '"'!
> >    ;
> >
> >protected
> >LITERAL
> >    :
> >        SINGLE_QUOTE_STRING | DOUBLE_QUOTE_STRING
> >    ;
> >
> >protected
> >IDENTIFIER
> >
> >    options
> >    {
> >        testLiterals=true;
> >    }
> >
> >    :
> >        ('\241'..'\377'|'a'..'z'|'A'..'Z'|'_')
> >('\241'..'\377'|'a'..'z'|'A'..'Z'|'-'|'_'|'0'..'9'|'.')*
> >    ;
> >
> >protected
> >LEFT_PAREN
> >    :    '('        ;
> >
> >protected
> >RIGHT_PAREN
> >    :    ')'        ;
> >
> >protected
> >NOT
> >    :    ("NOT"|"not")    ;
> >
> >protected
> >AND
> >    :    ("AND"|"and")    ;
> >
> >protected
> >OR
> >    :    ("OR"|"or")        ;
> >
> >protected
> >EQUALS
> >    :    '='        ;
> >
> >protected
> >NOT_EQUALS
> >    :    "<>"    ;
> >
> >protected
> >LT
> >    :    '<'        ;
> >
> >protected
> >LTE
> >    :    "<="    ;
> >
> >protected
> >GT
> >    :    '>'        ;
> >
> >protected
> >GTE
> >    :    ">="    ;
> >
> >
> >The syntactic predicates are in MAIN_LEXER_RULE. The order of
> >productions (alternative rules) in MAIN_LEXER_RULE is important,
> >because the lexer will try to match them in the order they are
> >declared and will stop as soon as it finds a match. So for example LTE
> >must be above LT because other ways the lexer will match the LT and
> >then an EQUALS in stead of LTE.
> >
> >Let me know if this has solved your problem.
> >
> >
> >Best regards,
> >Gabriel
> >
> >
> >
> >
> >On 05/02/06, Mark R. Diggory <mdiggory@latte.harvard.edu> wrote:
> >
> >
> >>I'm still working on building a Parser for our query syntax. I've
> >>encountered an issue with nondeterminism. I've included my grammar file:
> >>
> >>My question is how can I assure that the boolean predicate AND not the
> >>quoted string literal "you AND I" do not collide? I'd be very thankful
> >>to anyone with comments about obvious problems with my grammar file.
> >>
> >>thanks,
> >>Mark
> >>
> >>
> >>
> >>>class SearchQueryParser extends Parser;
> >>>    options
> >>>    {
> >>>          k=3;
> >>>        exportVocab=SearchQuery;
> >>>        buildAST = true;   // uses CommonAST by default
> >>>
> >>>    }
> >>>
> >>>
> >>>expr
> >>>    :
> >>>        mexpr ((AND|OR|NOT) mexpr)*
> >>>    ;
> >>>
> >>>mexpr
> >>>    :
> >>>        LITERAL^ | IDENTIFIER^ ((EQUALS|NOT_EQUALS|LT|LTE|GT|GTE)
> >>>LITERAL^)+
> >>>    ;
> >>>
> >>>
> >>>atom
> >>>      :
> >>>          IDENTIFIER | LEFT_PAREN! expr RIGHT_PAREN!
> >>>    ;
> >>>
> >>>class SearchQueryLexer extends Lexer;
> >>>    options
> >>>    {
> >>>        charVocabulary='\3'..'\377';
> >>>    }
> >>>
> >>>WS
> >>>    :
> >>>        ('\n' | ' ' | '\t' | '\r')+
> >>>        {
> >>>            $setType(Token.SKIP);
> >>>        }
> >>>    ;
> >>>
> >>>
> >>>protected
> >>>SINGLE_QUOTE_STRING
> >>>    :
> >>>        '\''! (~('\''))* '\''!
> >>>    ;
> >>>
> >>>protected
> >>>DOUBLE_QUOTE_STRING
> >>>    :
> >>>        '"'! (~('"'))* '"'!
> >>>    ;
> >>>
> >>>LITERAL
> >>>    :
> >>>        SINGLE_QUOTE_STRING | DOUBLE_QUOTE_STRING
> >>>    ;
> >>>
> >>>IDENTIFIER
> >>>
> >>>    options
> >>>    {
> >>>        testLiterals=true;
> >>>    }
> >>>
> >>>    :
> >>>        ('\241'..'\377'|'a'..'z'|'A'..'Z'|'_')
> >>>('\241'..'\377'|'a'..'z'|'A'..'Z'|'-'|'_'|'0'..'9'|'.')*
> >>>    ;
> >>>
> >>>LEFT_PAREN
> >>>    :    '('        ;
> >>>
> >>>RIGHT_PAREN
> >>>    :    ')'        ;
> >>>
> >>>NOT
> >>>    :    ("NOT"|"not")    ;
> >>>
> >>>AND
> >>>    :    ("AND"|"and")    ;
> >>>
> >>>OR
> >>>    :    ("OR"|"or")        ;
> >>>
> >>>EQUALS
> >>>    :    '='        ;
> >>>
> >>>NOT_EQUALS
> >>>    :    "<>"    ;
> >>>
> >>>LT
> >>>    :    '<'        ;
> >>>
> >>>LTE
> >>>    :    "<="    ;
> >>>
> >>>GT
> >>>    :    '>'        ;
> >>>
> >>>GTE
> >>>    :    ">="    ;
> >>>
> >>>
> >>
> >>
> >>
>
From parrt at cs.usfca.edu  Mon Feb  6 10:39:08 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Mon Feb  6 10:39:10 2006
Subject: [antlr-interest] [v3] not including text in token. Still possible?
In-Reply-To: <69667D34-0823-4156-B128-A242A12718FA@dolphin-services.de>
References: <1F4404A0-4EDD-49F5-A3F9-75FC2EE0905E@dolphin-services.de>
	<A7E1D589-75F6-4C11-8CC9-C6AF8957FD31@cs.usfca.edu>
	<69667D34-0823-4156-B128-A242A12718FA@dolphin-services.de>
Message-ID: <D13EAFB5-D619-4C9E-ACDC-9D20FF749E79@cs.usfca.edu>


On Feb 6, 2006, at 4:34 AM, Kay Roepke wrote:
>> Hi!  I haven't figured out to make it do that for v3 yet.  I don't  
>> create strings for a token (just indexes into the char buffer) so  
>> it's hard to do modifications.  I definitely need it though.
>
> Hi Ter!

Howdy do!

> I'd like to give this one a try just for the sake of it. It really  
> doesn't matter to me whether it'll end up in ANTLR or not. I just  
> like to
> try to implement it to familiarize myself with the source.
> As far as I can tell, I would need to have a look at antlr.g (to  
> see if it is correctly recognizing the '!') and then add the  
> supporting code
> to codegen.g. After that I have to figure out how to do the actual  
> codegeneration in Java.stg.
> Is that correct?

All of the grammars should be already to go. I think the code  
generation templates are the only problem.   you need to modify the  
code generator grammar So that it pays attention of the !  for  
lexers.  I have already anticipated this problem and added a text  
pointer in the common token.  The getText  method returns the text  
pointer if not null else it looks for the indices into the text buffer.

Any rule that has a bang modifier must Create a local string to fill.  
Code must be inserted after the match routines to add the matched  
char to the local char buffer.  I suppose that the emit method must  
be altered to accept a string argument representing the text for the  
token.

Ter
From open.zone at virgin.net  Mon Feb  6 11:08:29 2006
From: open.zone at virgin.net (Micheal J)
Date: Mon Feb  6 10:52:08 2006
Subject: [antlr-interest] ANN: C# StringTemplate - ST# v2.3b5 now available
Message-ID: <000801c62b50$b99055e0$6402a8c0@hercules>

A beta version of ST# v2.3b5 - a new template library written in C# that
enforces Model-View separation - has been released on the
www.stringtemplate.org website. ST# is developed in C# (using ANTLR 2.7.6)
but can be used with projects developed in other languages such as VB.NET,
C++.NET, J# etc.

For those unfamiliar with them, a template engine is at it's most basic, a
code generator that emits text using templates. These templates are really
just "documents with holes". The "holes" are markers for where you can stick
values.

"C# StringTemplate" (or ST#) is a new template library that breaks up your
templates into chunks of text and attribute expressions, which are by
default enclosed in dollar signs (e.g. $attribute-expression$). Everything
except attribute expressions is treated as literal text and copied verbatim
to the output when you call the method ToString() on a StringTemplate
instance.

ST# v2.3b5 is feature complete with respect to StringTemplate v2.3b5 for
Java and includes an *alpha* release of a StringTemplate visualizer. It has
a C#-fied API and features a unique and useful template loader abstraction.
You can download it from this page on the StringTemplate website where you
can also find more information about the StringTemplate template library:

http://www.stringtemplate.org/share/list


-------------- next part --------------
C# StringTemplate v2.3b5 - a template library that enforces Model-View separation

5 February, 2006

Kunle Odutola		: kunle UNDERSCORE odutola AT hotmail DOT com
Micheal Jordan


1. INTRODUCTION 

A template engine is at it's most basic, a code generator that emits text 
using templates. These templates are really just "documents with holes".
The "holes" are markers for where you can stick values. 

"C# StringTemplate" (or ST#) is a template library that breaks up your 
templates into chunks of text and attribute expressions, which are by 
default enclosed in dollar signs (e.g. $attribute-expression$). It ignores 
everything except attribute expressions. Everthing else is treating it as 
just text to and is simply copied verbatim to the output when you call the 
method ToString() on a StringTemplate instance.

We hope you find ST# delightful and useful even but, as per the license 
under which you may use it, this software is not guaranteed to work. 
See LICENSE.TXT for the full text of the license.

----------------------------------------------------------------------
THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
----------------------------------------------------------------------


2. WHAT'S IN THE PACK?

This distribution contains four projects and the project files needed to 
build them with Microsoft Visual Studio 2003. The projects are:

	1. StringTemplate			- the core ST# runtime library

	2. StringTemplateTests		- unit tests for the ST# library above

	3. StringTemplateTreeView	- a library for visualizing StringTemplates
								  [Alpha quality release - not reliable]

	4. StringTemplateViewer		- a StringTemplateTreeView demo app
	
In addition the Lib sub-directory contains copies of the ANTLR 2.7.6 runtime 
assemblies. ST# *needs* ANTLR version 2.7.6 or later but, you should probably 
use your own versions of these assemblies if you already have ANTLR 2.7.6.

2.1 Dependenicies

All projects have a dependence on ANTLR 2.7.6 as stated above. In addition, 
StringTemplateTests has a dependency on NUnit v2.2+.


3. BUILDING ST#

If you wish to re-build ST# for any reason, this is what you ned to know.

a) This release of ST# was built with ANTLR 2.7.6. If you change any of the 
ANTLR grammar files supplied with ST#, you will need to use the ANTLR tool to 
regenerate the corresponding C# source files for the Lexer/Parser/TreeParsers. 
The grammar files - all named <something>.g - are in:
	%ST_DIR%\StringTemplate\Antlr.StringTemplate.Language\

b) Then, just use the supplied VS.NET project files to build the projects. 

NOTE: Some of the ANTLR grammar files above trigger a curious bug in ANTLR 2.x 
that can only by fixed by hand. The errors are related to the redefinition of 
a variable. There are about 4-6 such manual fixes required although the number 
of error/warning messages you get may be more than that. Errors are:

	CS0128: A local variable named 'variable' is already defined in this scope
	CS0136: A local variable named 'var' cannot be declared in this scope because 
	        it would give a different meaning to 'var', which is already used in 
	        a 'parent or current' scope to denote something else


4. ST# STATUS

This release of ST# is a beta release (ST# TreeView visualizer is an Alpha release). 
ST# itself is mostly feature complete for the upcoming 2.3 release but expect a few 
rough edges. 

There are currently about 2-3 failures in the unit test suite out of about 190 cases.


Don't forget to visit the www.stringtemplate.org for further info. The mailing list is 
(currently) very low volume but has a very high Signal-to-Noise ratio. We'd like to 
hear about how you're using ST#.


Enjoy!

Kunle Odutola
From jasonw at justuni.org  Mon Feb  6 11:58:34 2006
From: jasonw at justuni.org (Jason Wood)
Date: Mon Feb  6 12:02:42 2006
Subject: [antlr-interest] skiping the rest of a line
Message-ID: <29943.70.239.54.225.1139255914.squirrel@www.justuni.org>

Newbie question

I have the following line in a text file 
 ~Another Section. The ~A part
is of interest but the rest is not, also it is not guaranteed that
anything after the ~A will be present. So, I have created a rule to look
for ~A. After the ~A is located I want to skip the rest of the line and
proceed to the next line. How do I go about doing that?

I tried the following and it works but this gives me a nondeterministic
warning, which it understandable because matched everything but newline
characters.

IGNORE: ':'(~('\n'|'\r'))* ('\n'|'\r'('\n')?){$setType(Token.SKIP);
newline();};

J


From jsamort at sympatico.ca  Mon Feb  6 13:42:47 2006
From: jsamort at sympatico.ca (Scott Amort)
Date: Mon Feb  6 13:42:51 2006
Subject: [antlr-interest] help requested for selective whitespace
In-Reply-To: <1139218992.7782.18.camel@localhost.localdomain>
References: <1138585445.7879.16.camel@localhost>	<1138762449.7476.8.camel@localhost>
	<1138844785.2032.8.camel@localhost>	<1138880545.9733.5.camel@localhost.localdomain>	<43E3CC13.3000209@sympatico.ca>
	<1139218992.7782.18.camel@localhost.localdomain>
Message-ID: <43E7C2D7.5080600@sympatico.ca>

Martin Probst wrote:
> What about:
>
> note_desc
>     : NOTENAME WS (OCTAVE)? WS (DURATION)? WS (DOT)?
>     ;
>
> and in the Lexer
>
> WS
>     : ( ' ' | '\t' | '\n' | '\r' )+;
> (no $setType(Token.SKIP) here!).
>
> This way you can explicitly ask for white space to be between your
> tokens.
>
> Martin
>
>   
Hi Martin,

Thanks again for taking the time to respond.  Your suggestion is much 
like my first idea, looking like this:

note_desc
    : NOTENAME (OCTAVE)? (DURATION)? (DOT)? WS
    ;

as I only need to require trailing WS after note descriptions.  But, if 
I allow the lexer to pass white space to the parser, I then have to 
account for it in all my other rules (whitespace can be safely ignored 
in all other instances).  It seems a bit inelegant to me to then have to 
put (WS)? all throughout my parser rules.  But, perhaps that is the only 
way.

Best,
Scott
From jsamort at sympatico.ca  Mon Feb  6 13:57:59 2006
From: jsamort at sympatico.ca (Scott Amort)
Date: Mon Feb  6 13:58:02 2006
Subject: [antlr-interest] skiping the rest of a line
In-Reply-To: <29943.70.239.54.225.1139255914.squirrel@www.justuni.org>
References: <29943.70.239.54.225.1139255914.squirrel@www.justuni.org>
Message-ID: <43E7C667.6050706@sympatico.ca>

Jason Wood wrote:
> Newbie question
>
> I have the following line in a text file ? ~Another Section. The ~A part
> is of interest but the rest is not, also it is not guaranteed that
> anything after the ~A will be present. So, I have created a rule to look
> for ~A. After the ~A is located I want to skip the rest of the line and
> proceed to the next line. How do I go about doing that?
>
> I tried the following and it works but this gives me a nondeterministic
> warning, which it understandable because matched everything but newline
> characters.
>
> IGNORE: ':'(~('\n'|'\r'))* ('\n'|'\r'('\n')?){$setType(Token.SKIP);
> newline();};
>
> J
>
>
>   
Hi Jason,

I'm pretty new at this too, but I'll give it a stab...

couldn't you just have this in your lexer:

ANOTHER_SECTION
: "~A" ((~('\n' | '\r'))*)! ('\n' | '\r' ('\n')?)!
;

It will match anything after ~A that is not a newline, and terminate the 
rule at a newline. The exclamation point prevents that portion from 
being included in the token, so all that gets passed on to the parser is 
the initial ~A.

Hope this helps!

Best,
Scott
From jens.bartelheimer at gmx.de  Mon Feb  6 14:22:33 2006
From: jens.bartelheimer at gmx.de (Jens Bartelheimer)
Date: Mon Feb  6 14:22:39 2006
Subject: [antlr-interest] Problem with *
Message-ID: <43E7CC29.2000808@gmx.de>

Hi,

I am new to antlr and I have a problem with the Star *.

If I only parse a String with a star the first rule recognize the star, 
the second with a token not.

Why?

1st:
----

getTest
{
}
    :   "*"
        {
    System.out.println("Star gefunden");
        }
    ;


2nd:
getTest
{
}
    :   STAR
        {
    System.out.println("Star found");
        }
    ;

Lexer:
STAR: '*';

raises: line 1:1: expecting STAR, found '*'


From seclib at seclib.com  Mon Feb  6 14:52:28 2006
From: seclib at seclib.com (Xue Yong Zhi)
Date: Mon Feb  6 14:53:19 2006
Subject: [antlr-interest] Re: skiping the rest of a line
In-Reply-To: <29943.70.239.54.225.1139255914.squirrel@www.justuni.org>
References: <29943.70.239.54.225.1139255914.squirrel@www.justuni.org>
Message-ID: <43E7D32C.1000803@seclib.com>


> I tried the following and it works but this gives me a nondeterministic
> warning, which it understandable because matched everything but newline
> characters.
> 
> IGNORE: ':'(~('\n'|'\r'))* ('\n'|'\r'('\n')?){$setType(Token.SKIP);
> newline();};
> 

I guess the warning comes from here:
('\n'|'\r'('\n')?)

If I am right, you have a public lexer rule(probabally called 
LINE_BREAK) which matches '\n'. Since antlr assumes "whatever followes" 
when computing the exit branch, it does not know if '\n' followed by 
'\r' should be matched right away, or matched as another token(LINE_BREAK).

In your case, you do want the lexer be greedy, so just add the following:
('\n'|'\r'(options {greedy=true;} :'\n')?)

-- 
Xue Yong Zhi
http://seclib.blogspot.com

From jasonw at justuni.org  Mon Feb  6 14:12:17 2006
From: jasonw at justuni.org (Jason Wood)
Date: Mon Feb  6 15:02:56 2006
Subject: [antlr-interest] table rows
Message-ID: <33950.70.239.54.225.1139263937.squirrel@www.justuni.org>

Hello again, I think I am picking this up pretty quick ;)

I have a table that contains rows that need to be in a specific order. For
example:

column1 column2 column3
A       name    john doe
B       address 1600 Penn. Ave.
C       phone   123-456-7890

So by the specification I have been given, A must come before B and C. and
A,B,C must be present. Now I have written a lexer rule for each because I
thought this was the only way to tell antlr that order matters, but I
thought I would get some opinions on it.

Thanks for any help :)
J

From kroepke at dolphin-services.de  Mon Feb  6 15:11:35 2006
From: kroepke at dolphin-services.de (Kay Roepke)
Date: Mon Feb  6 15:11:41 2006
Subject: [antlr-interest] [v3] not including text in token. Still possible?
In-Reply-To: <D13EAFB5-D619-4C9E-ACDC-9D20FF749E79@cs.usfca.edu>
References: <1F4404A0-4EDD-49F5-A3F9-75FC2EE0905E@dolphin-services.de>
	<A7E1D589-75F6-4C11-8CC9-C6AF8957FD31@cs.usfca.edu>
	<69667D34-0823-4156-B128-A242A12718FA@dolphin-services.de>
	<D13EAFB5-D619-4C9E-ACDC-9D20FF749E79@cs.usfca.edu>
Message-ID: <C7CC0181-C03D-4CDF-8F7A-339E43F942DD@dolphin-services.de>


On 6. Feb 2006, at 19:39 Uhr, Terence Parr wrote:

> All of the grammars should be already to go. I think the code  
> generation templates are the only problem.   you need to modify the  
> code generator grammar So that it pays attention of the !  for  
> lexers.  I have already anticipated this problem and added a text  
> pointer in the common token.  The getText  method returns the text  
> pointer if not null else it looks for the indices into the text  
> buffer.

Yeah, that's cool. The ast_suffix ruleref seems to be present in all  
relevant places.

> Any rule that has a bang modifier must Create a local string to  
> fill. Code must be inserted after the match routines to add the  
> matched char to the local char buffer.  I suppose that the emit  
> method must be altered to accept a string argument representing the  
> text for the token.

The change to emit should be easy, but I have one conceptual problem  
with the bang modifier and the placement of the code after the match  
code:

Suppose I have the following lexer rule:

FOO	:	'"'! ID '"'!	;

with ID being some canonical ID-rule.

I'm seeing the ast_suffix.type==ANTLRParser.BANG in the rule 'atom'  
of codegen.g. But I also need to add code to the FOO lexer rule to  
set up
the local string buffer to collect the chars from the ID subrule.  
Simply adding code to the charRef ST (or rather using the new  
charRefBang) after
the match won't do it.
Now if I'd written "FOO! : ... " I'd be all set, but if the bang  
occurs in of the atoms inside the rule I have to look inside first  
and instantiate
the appropriate ST for this. The one with the string buffer setup code.

Any ideas?

- k
From parrt at cs.usfca.edu  Mon Feb  6 15:20:42 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Mon Feb  6 15:20:44 2006
Subject: [antlr-interest] [v3] not including text in token. Still possible?
In-Reply-To: <C7CC0181-C03D-4CDF-8F7A-339E43F942DD@dolphin-services.de>
References: <1F4404A0-4EDD-49F5-A3F9-75FC2EE0905E@dolphin-services.de>
	<A7E1D589-75F6-4C11-8CC9-C6AF8957FD31@cs.usfca.edu>
	<69667D34-0823-4156-B128-A242A12718FA@dolphin-services.de>
	<D13EAFB5-D619-4C9E-ACDC-9D20FF749E79@cs.usfca.edu>
	<C7CC0181-C03D-4CDF-8F7A-339E43F942DD@dolphin-services.de>
Message-ID: <935ECFA3-3D26-47A1-8793-C659C9726AB7@cs.usfca.edu>


On Feb 6, 2006, at 3:11 PM, Kay Roepke wrote:
> Suppose I have the following lexer rule:
>
> FOO	:	'"'! ID '"'!	;
>
> with ID being some canonical ID-rule.
>
> I'm seeing the ast_suffix.type==ANTLRParser.BANG in the rule 'atom'  
> of codegen.g. But I also need to add code to the FOO lexer rule to  
> set up
> the local string buffer to collect the chars from the ID subrule.  
> Simply adding code to the charRef ST (or rather using the new  
> charRefBang) after
> the match won't do it.

yeah some setup is needed.

> Now if I'd written "FOO! : ... " I'd be all set, but if the bang  
> occurs in of the atoms inside the rule I have to look inside first  
> and instantiate
> the appropriate ST for this. The one with the string buffer setup  
> code.

Hmm...well i used to just record the start index before every element  
(token or rule) and then if not a bang, add chars from saved index to  
current index into buffer.  If a bang, then don't add.  Would that work?

Ter
From kroepke at dolphin-services.de  Mon Feb  6 15:32:50 2006
From: kroepke at dolphin-services.de (Kay Roepke)
Date: Mon Feb  6 15:32:56 2006
Subject: [antlr-interest] [v3] not including text in token. Still possible?
In-Reply-To: <935ECFA3-3D26-47A1-8793-C659C9726AB7@cs.usfca.edu>
References: <1F4404A0-4EDD-49F5-A3F9-75FC2EE0905E@dolphin-services.de>
	<A7E1D589-75F6-4C11-8CC9-C6AF8957FD31@cs.usfca.edu>
	<69667D34-0823-4156-B128-A242A12718FA@dolphin-services.de>
	<D13EAFB5-D619-4C9E-ACDC-9D20FF749E79@cs.usfca.edu>
	<C7CC0181-C03D-4CDF-8F7A-339E43F942DD@dolphin-services.de>
	<935ECFA3-3D26-47A1-8793-C659C9726AB7@cs.usfca.edu>
Message-ID: <EF5ED4B6-54F9-4CF5-951C-D47100C65F4D@dolphin-services.de>


On 7. Feb 2006, at 0:20 Uhr, Terence Parr wrote:

> Hmm...well i used to just record the start index before every  
> element (token or rule) and then if not a bang, add chars from  
> saved index to current index into buffer.  If a bang, then don't  
> add.  Would that work?

It sure would, but wouldn't this mean we'd always create a buffer and  
copy the string? I'd rather not lose the ability to use the indexing  
into the input
buffer. Just recording the indices and copy to buffer once I see a  
bang and pick up after that was the first idea I had...
I could probably set some flag if I've seen a bang and only then  
really copy the buffer. Yeah, that might work...

-k
From parrt at cs.usfca.edu  Mon Feb  6 15:50:23 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Mon Feb  6 15:50:27 2006
Subject: [antlr-interest] [v3] not including text in token. Still possible?
In-Reply-To: <EF5ED4B6-54F9-4CF5-951C-D47100C65F4D@dolphin-services.de>
References: <1F4404A0-4EDD-49F5-A3F9-75FC2EE0905E@dolphin-services.de>
	<A7E1D589-75F6-4C11-8CC9-C6AF8957FD31@cs.usfca.edu>
	<69667D34-0823-4156-B128-A242A12718FA@dolphin-services.de>
	<D13EAFB5-D619-4C9E-ACDC-9D20FF749E79@cs.usfca.edu>
	<C7CC0181-C03D-4CDF-8F7A-339E43F942DD@dolphin-services.de>
	<935ECFA3-3D26-47A1-8793-C659C9726AB7@cs.usfca.edu>
	<EF5ED4B6-54F9-4CF5-951C-D47100C65F4D@dolphin-services.de>
Message-ID: <98CA1BA7-3A5A-4338-B031-4434A97B6FCE@cs.usfca.edu>


On Feb 6, 2006, at 3:32 PM, Kay Roepke wrote:

>
> On 7. Feb 2006, at 0:20 Uhr, Terence Parr wrote:
>
>> Hmm...well i used to just record the start index before every  
>> element (token or rule) and then if not a bang, add chars from  
>> saved index to current index into buffer.  If a bang, then don't  
>> add.  Would that work?
>
> It sure would, but wouldn't this mean we'd always create a buffer  
> and copy the string? I'd rather not lose the ability to use the  
> indexing into the input
> buffer.

Well, you need a pure flat simple string for the overall token you  
are creating.  You need to copy from the buffer anyway into the new  
stirng, right?

> Just recording the indices and copy to buffer once I see a bang and  
> pick up after that was the first idea I had...
> I could probably set some flag if I've seen a bang and only then  
> really copy the buffer. Yeah, that might work...

True, but messier I suppose.  Perhaps we should think about the  
common case like removing the quotes off of string and char  
literals...how complicated do you want the average case to be...

Ter

From kroepke at dolphin-services.de  Mon Feb  6 16:36:23 2006
From: kroepke at dolphin-services.de (Kay Roepke)
Date: Mon Feb  6 16:36:31 2006
Subject: [antlr-interest] [v3] not including text in token. Still possible?
In-Reply-To: <98CA1BA7-3A5A-4338-B031-4434A97B6FCE@cs.usfca.edu>
References: <1F4404A0-4EDD-49F5-A3F9-75FC2EE0905E@dolphin-services.de>
	<A7E1D589-75F6-4C11-8CC9-C6AF8957FD31@cs.usfca.edu>
	<69667D34-0823-4156-B128-A242A12718FA@dolphin-services.de>
	<D13EAFB5-D619-4C9E-ACDC-9D20FF749E79@cs.usfca.edu>
	<C7CC0181-C03D-4CDF-8F7A-339E43F942DD@dolphin-services.de>
	<935ECFA3-3D26-47A1-8793-C659C9726AB7@cs.usfca.edu>
	<EF5ED4B6-54F9-4CF5-951C-D47100C65F4D@dolphin-services.de>
	<98CA1BA7-3A5A-4338-B031-4434A97B6FCE@cs.usfca.edu>
Message-ID: <43D0898E-811E-44FA-A9CC-6721B472161E@dolphin-services.de>


On 7. Feb 2006, at 0:50 Uhr, Terence Parr wrote:

>> It sure would, but wouldn't this mean we'd always create a buffer  
>> and copy the string? I'd rather not lose the ability to use the  
>> indexing into the input
>> buffer.
>
> Well, you need a pure flat simple string for the overall token you  
> are creating.  You need to copy from the buffer anyway into the new  
> stirng, right?

Oh, I was talking about the case where I don't have any bangs in the  
rule. But from entering the rule I cannot look forward onto all the  
atoms within
the rule, can I? (Or rather, the tree walker isn't doing that.)
So in the general case without any bangs, I don't want to create any  
string. I want to rely on the indices into the input buffer.

>> Just recording the indices and copy to buffer once I see a bang  
>> and pick up after that was the first idea I had...
>> I could probably set some flag if I've seen a bang and only then  
>> really copy the buffer. Yeah, that might work...
>
> True, but messier I suppose.  Perhaps we should think about the  
> common case like removing the quotes off of string and char  
> literals...how complicated do you want the average case to be...

As straightforward as possible ;) The first thing that should would  
work are the literals, I agree. The rest should be quite similar,  
though.

-k
From parrt at cs.usfca.edu  Mon Feb  6 16:44:59 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Mon Feb  6 16:45:03 2006
Subject: [antlr-interest] [v3] not including text in token. Still possible?
In-Reply-To: <43D0898E-811E-44FA-A9CC-6721B472161E@dolphin-services.de>
References: <1F4404A0-4EDD-49F5-A3F9-75FC2EE0905E@dolphin-services.de>
	<A7E1D589-75F6-4C11-8CC9-C6AF8957FD31@cs.usfca.edu>
	<69667D34-0823-4156-B128-A242A12718FA@dolphin-services.de>
	<D13EAFB5-D619-4C9E-ACDC-9D20FF749E79@cs.usfca.edu>
	<C7CC0181-C03D-4CDF-8F7A-339E43F942DD@dolphin-services.de>
	<935ECFA3-3D26-47A1-8793-C659C9726AB7@cs.usfca.edu>
	<EF5ED4B6-54F9-4CF5-951C-D47100C65F4D@dolphin-services.de>
	<98CA1BA7-3A5A-4338-B031-4434A97B6FCE@cs.usfca.edu>
	<43D0898E-811E-44FA-A9CC-6721B472161E@dolphin-services.de>
Message-ID: <1F28593B-DDCE-4B1F-9555-233705A31981@cs.usfca.edu>


On Feb 6, 2006, at 4:36 PM, Kay Roepke wrote:

>
> On 7. Feb 2006, at 0:50 Uhr, Terence Parr wrote:
>
>>> It sure would, but wouldn't this mean we'd always create a buffer  
>>> and copy the string? I'd rather not lose the ability to use the  
>>> indexing into the input
>>> buffer.
>>
>> Well, you need a pure flat simple string for the overall token you  
>> are creating.  You need to copy from the buffer anyway into the  
>> new stirng, right?
>
> Oh, I was talking about the case where I don't have any bangs in  
> the rule. But from entering the rule I cannot look forward onto all  
> the atoms within
> the rule, can I? (Or rather, the tree walker isn't doing that.)

If there are no bangs lexically present in the rule, don't generate  
the special code. :)

> So in the general case without any bangs, I don't want to create  
> any string. I want to rely on the indices into the input buffer.

Yep.  Only do new stuff if you see a !.  Even if it's in a (..)? block.

>>> Just recording the indices and copy to buffer once I see a bang  
>>> and pick up after that was the first idea I had...
>>> I could probably set some flag if I've seen a bang and only then  
>>> really copy the buffer. Yeah, that might work...
>>
>> True, but messier I suppose.  Perhaps we should think about the  
>> common case like removing the quotes off of string and char  
>> literals...how complicated do you want the average case to be...
>
> As straightforward as possible ;) The first thing that should would  
> work are the literals, I agree. The rest should be quite similar,  
> though.

:)

Ter

From kalle at snigel.net  Mon Feb  6 18:42:39 2006
From: kalle at snigel.net (karl wettin)
Date: Mon Feb  6 18:41:05 2006
Subject: [antlr-interest] line 0:0: expecting ALPHA, found ''
Message-ID: <2F482633-296D-4E2C-ABA1-9C6577F955C4@snigel.net>

Hello list,

I'm new to antlr. Just ported my javacc-grammar and get this funky  
error. I get it even with the most simple tests, so I guess I do  
something really silly. All the examples bundled works great, even  
with my StringReader. Greatfull for any help.

header { package se.snigel.tpb.analysis.antlr; }
class ANTLRParser extends Parser;
expr: ALPHA;
class ANTLRLexer extends Lexer;
protected ALPHA :  'a'..'z';

package se.snigel.tpb.analysis.antlr;
import java.io.StringReader;
public class Main {
	public static void main(String[] args) throws Exception {
		ANTLRLexer l = new ANTLRLexer(new StringReader("a"));
		ANTLRParser p = new ANTLRParser(l);
		p.expr();
	}
}

line 0:0: expecting ALPHA, found ''


-- 
karl
From kroepke at dolphin-services.de  Mon Feb  6 19:59:43 2006
From: kroepke at dolphin-services.de (Kay Roepke)
Date: Mon Feb  6 19:59:52 2006
Subject: [antlr-interest] line 0:0: expecting ALPHA, found ''
In-Reply-To: <2F482633-296D-4E2C-ABA1-9C6577F955C4@snigel.net>
References: <2F482633-296D-4E2C-ABA1-9C6577F955C4@snigel.net>
Message-ID: <25F47C03-6CD3-4307-9B43-8C2F587583DD@dolphin-services.de>


On 7. Feb 2006, at 3:42 Uhr, karl wettin wrote:

> I'm new to antlr. Just ported my javacc-grammar and get this funky  
> error. I get it even with the most simple tests, so I guess I do  
> something really silly. All the examples bundled works great, even  
> with my StringReader. Greatfull for any help.
>
> header { package se.snigel.tpb.analysis.antlr; }
> class ANTLRParser extends Parser;
> expr: ALPHA;
> class ANTLRLexer extends Lexer;
> protected ALPHA :  'a'..'z';

Hi Karl!

Your problem is the protected lexer rule ALPHA. "protected" means  
that the lexer rule is internal to the lexer. This rule doesn't give
you a token (i.e. it will never come out of a nextToken call on the  
lexer). Thus the parser doesn't get a token and complains that it needs
an ALPHA token but hasn't received one from the lexer.
Just drop the "protected" keyword and all is well.

protected lexer rules can be used to implement "helper" rules for the  
lexer. I think there are a couple of examples in the docs over at
http://www.antlr.org/doc/index.html
specifically look for http://www.antlr.org/doc/lexer.html#lexicalrules
and http://www.jguru.com/faq/view.jsp?EID=125 has a nice explanation  
of this, too.

HTH,

Kay

P.S.: Welcome aboard ;)
From sunjigang1965 at yahoo.com.cn  Tue Feb  7 00:39:52 2006
From: sunjigang1965 at yahoo.com.cn (=?gb2312?q?=CB=EF=BC=CD=B8=D5=20Jigang=20(Robert)=20Sun?=)
Date: Tue Feb  7 00:39:58 2006
Subject: [antlr-interest] A problem with loading AST Node type occured.
Message-ID: <20060207083952.89529.qmail@web15703.mail.cnb.yahoo.com>

A problem with loading AST Node type occured.
   
  Here is my simplest grammar:
   
   primaryExp
  :
   INTEGER_LITERAL <AST=INTNode>
  ;

   
  INTNode class
   
   public abstract class Expr : antlr.BaseAST{
  public abstract int value();
 }
   
   public class INTNode:Expr{
  int val=0;
  public INTNode(Token tok){
   val=int.Parse(tok.getText());
   }
  public override int value(){
   return val;
  }
  
  public override  void initialize(AST t){
  }
  public override  void initialize(IToken t){
  }
  public override  void initialize(int i,string s){
  }
 }
   
  I have just newly downloaded Microsoft Framework 2.0, but the problem is still persisted.
   
  Jigang

		
---------------------------------
 —≈ª¢1G√‚∑—” œ‰∞Ÿ∑÷∞Ÿ∑¿¿¨ª¯–≈
 —≈ª¢÷˙ ÷-À—À˜°¢…±∂æ°¢∑¿…ß»≈  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060207/1ecf0843/attachment.html
From open.zone at virgin.net  Tue Feb  7 02:15:29 2006
From: open.zone at virgin.net (Micheal J)
Date: Tue Feb  7 01:59:00 2006
Subject: [antlr-interest] A problem with loading AST Node type occured.
In-Reply-To: <20060207083952.89529.qmail@web15703.mail.cnb.yahoo.com>
Message-ID: <000901c62bcf$6cb8e8c0$6402a8c0@hercules>

Does the heteroAST example work on your system?. If yes, that would be a good starting point for developing your own language processor using heterogenous AST node class(es).
 
Also not sure that (off the top of my head) it's a good idea to override the initialize() methods to do nothing.
 
Micheal

-----Original Message-----
From: antlr-interest-bounces@antlr.org [mailto:antlr-interest-bounces@antlr.org] On Behalf Of ?????? Jigang (Robert) Sun
Sent: 07 February 2006 08:40
To: antlr-interest@antlr.org
Subject: [antlr-interest] A problem with loading AST Node type occured.


A problem with loading AST Node type occured.
 
Here is my simplest grammar:
 
 primaryExp
  :
   INTEGER_LITERAL <AST=INTNode>
  ;

 
INTNode class
 
 public abstract class Expr : antlr.BaseAST{
  public abstract int value();
 }
 
 public class INTNode:Expr{
  int val=0;
  public INTNode(Token tok){
   val=int.Parse(tok.getText());
   }
  public override int value(){
   return val;
  }
  
  public override  void initialize(AST t){
  }
  public override  void initialize(IToken t){
  }
  public override  void initialize(int i,string s){
  }
 }
 
I have just newly downloaded Microsoft Framework 2.0, but the problem is still persisted.
 
Jigang



  _____  

??1G??????????? <http://cn.mail.yahoo.com> 
????-????????? <http://cn.zs.yahoo.com>  

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060207/7add03ba/attachment.html
From Ulrich.Frank at dlr.de  Tue Feb  7 06:10:55 2006
From: Ulrich.Frank at dlr.de (Ulrich Frank)
Date: Tue Feb  7 06:10:59 2006
Subject: [antlr-interest] $FIRST $FOLLOW
Message-ID: <43E8AA6F.4080607@dlr.de>

Hello InterestGroup.

I've the following problem and perhaps you can help me. I hope so. I 
have to build an application which should recognice some kind of OQL 
(Object Query Language) grammar. Ok, thats not the problem. I wrote an 
appopriate grammar. If I parse a sample String like "select attr from 
obj" I get the information if the String respects the OQL grammar or not.

But what i want to do is the following: When I write the String "Select 
sdf" and push then CTRL-Space there shoult be a context menu which shows 
me all the posibilities which are correct at this position (just like in 
Eclipse f.e.). In this case  only "from" should be shown. If I write 
something like "select" and push CTRL-Space, the shown list should 
include 'ATTR_ID' and 'from', whereas ATTR_ID is the Token (Symbol) for 
an attribute at this position in the grammar. The rule looks like "query 
: "select" (ATTR_ID)? "from" OBJ_ID ("where" ...)?.

So how can I realize this?? I know I have to access  $FIRST and $FOLLOW 
respectively which is accessible in the grammar file. But I firstly need 
this information in the main java class where i create a parser object 
and my gui and secondly I do not need the BitSet (=$FIRST,$FOLLOW) but 
the names of the Tokens (Symbols), ATTR_ID f.e. When I'm right, i can 
get the last thing by matching it with the entries in the 
...TokenTypes.txt file but isn't there a better/faster way?

Thanks,
Ulrich Frank
From jens.stegemann at gmx.de  Tue Feb  7 06:14:36 2006
From: jens.stegemann at gmx.de (Jens Stegemann)
Date: Tue Feb  7 06:15:46 2006
Subject: [antlr-interest] Parsing multiple messages using one parser
Message-ID: <200602071514.36112.jens.stegemann@gmx.de>

Hello,

I am writing a client-server based application in c++ (but the problem will be 
the same in JAVA, too - i suppose). The clients send messages to the server 
which have to be parsed there to create a reply. To do so an 
interpreter-class exists within the server like this one:

class Interpreter
{
	public:
		Interpreter();
		void doParse(string message);
	
	private:
		Parser *myParser;
		Lexer *myLexer;
};

Is it possible to use the same myParser and myLexer objects in every call of 
do Parse(...) and can you tell me how I have to initialize them in the 
constructor and use them in doParse(...) to do so?

My application is working fine when I create new instances of Parser and Lexer 
for each call of doParse(...), but this is much too time-consuming for my 
purpose.

I googled a lot and searched every resource about antlr I could find for a 
solution without success. I hope you can help me.


Your's

Jens

-- 
Keep your dreams alive and live your dreams!
From ric.klaren at gmail.com  Tue Feb  7 06:33:08 2006
From: ric.klaren at gmail.com (Ric Klaren)
Date: Tue Feb  7 06:33:16 2006
Subject: [antlr-interest] Parsing multiple messages using one parser
In-Reply-To: <200602071514.36112.jens.stegemann@gmx.de>
References: <200602071514.36112.jens.stegemann@gmx.de>
Message-ID: <bc607a4e0602070633o2220581td2d270b90d98c0e6@mail.gmail.com>

On 2/7/06, Jens Stegemann <jens.stegemann@gmx.de> wrote:
> Is it possible to use the same myParser and myLexer objects in every call of
> do Parse(...) and can you tell me how I have to initialize them in the
> constructor and use them in doParse(...) to do so?

Yes, you should be able to dig up multiple posts from the mailinglist
archive send by me with instructions to do this. You have to use the
more explicit constructors from lexer and parser. The baseclasses for
lexer/parser/inputbuffer have some methods to reset/initialize stuff
for a new stream.

If you can't find it bother me again and I'll try and dig some example
snippets up. (Very swamped with work currently)

Cheers,

Ric
From mdiggory at latte.harvard.edu  Tue Feb  7 08:45:14 2006
From: mdiggory at latte.harvard.edu (Mark R. Diggory)
Date: Tue Feb  7 08:45:35 2006
Subject: [antlr-interest] Handling lexical nondeterminism in Tokens
In-Reply-To: <67e2ed240602060838j17b98d09l@mail.gmail.com>
References: <43E64701.7070800@latte.harvard.edu>	<67e2ed240602060340i11c6e102m@mail.gmail.com>	<43E76A77.5070208@latte.harvard.edu>
	<67e2ed240602060838j17b98d09l@mail.gmail.com>
Message-ID: <43E8CE9A.3030505@latte.harvard.edu>

Thanks, that is very close to what I need.

Seems not to work on the following cases, which should all be valid.

"((foo='bar')AND bim='bam');"
"(foo='bar' AND bim='bam');"
"foo='bar' AND bim='bam';"

I've tried different combinations of defining the parethises and the 
white space. Along the lines of the following

    : LEFT_PAREN! expr RIGHT_PAREN!
    | expr

But can't seem to get it right.

-Mark

Gabriel Radu wrote:

>Dear Mark,
>
>What about:
>
>  
>
>>class SearchQueryParser extends Parser;
>>    options
>>    {
>>        k=3;
>>        exportVocab=SearchQuery;
>>        buildAST = true;   // uses CommonAST by default
>>
>>    }
>>
>>statement
>>    : LEFT_PAREN! expr RIGHT_PAREN! EOST
>>    | expr EOST
>>    ;
>>
>>expr
>>    : mexpr ( bool_relations LEFT_PAREN! expr RIGHT_PAREN! )*
>>    ;
>>
>>mexpr
>>    : atom ( bool_relations atom )*
>>    ;
>>
>>atom
>>    : IDENTIFIER equivalence_relation LITERAL
>>    ;
>>
>>bool_relations : AND|OR|NOT ;
>>
>>equivalence_relation : EQUALS|NOT_EQUALS|LT|LTE|GT|GTE ;
>>    
>>
>
>where EOST is a token which marks the end of a statement. It can be
>something like end of line or semicolon. Don't forget to add it to the
>lexer as well.
>
>Let me know how you are getting on.
>
>
>Best regards,
>Gabriel
>
>
>
>
>On 06/02/06, Mark R. Diggory <mdiggory@latte.harvard.edu> wrote:
>  
>
>>Thanks, I think I understand how this will help in the Lexer. I'm
>>currently having problems how to capture how to properly represent the
>>syntax in the Parser
>>
>>Here's a clarification of what I should be able to do with the query
>>language:
>>
>>The smallest "atom" is a LITERAL string, currently this can be in quotes
>>or not in quotes. For example:
>>
>>    
>>
>>>United States
>>>"Untied States"
>>>      
>>>
>>Alternatively a "atom" can be an equivalence relation. For instance:
>>
>>    
>>
>>>title="Untied States"
>>>title<>"Untied States"
>>>date>=2006
>>>      
>>>
>>Each atom can have parentheses around it.
>>
>>    
>>
>>>(title="Untied States")
>>>      
>>>
>>equivalence relations can be joined using boolean relations
>>
>>    
>>
>>>title="Untied States" AND date>=2006
>>>title="Untied States" OR date>=2006
>>>title="Untied States" NOT date>=2006
>>>      
>>>
>>boolean relations can be wrapped in parentheses to control precedence.
>>
>>    
>>
>>>title="Untied States" AND (date>=2006 OR author=Steven King)
>>>      
>>>
>>I've been trying to capture this using the following parser, but its
>>clear now that I'm missing the mark:
>>
>>    
>>
>>>class SearchQueryParser extends Parser;
>>>   options
>>>   {
>>>         k=3;
>>>       exportVocab=SearchQuery;
>>>       buildAST = true;   // uses CommonAST by default
>>>
>>>   }
>>>
>>>expr
>>>   :
>>>       mexpr ((AND|OR|NOT) mexpr)*
>>>   ;
>>>
>>>mexpr
>>>   :
>>>       LITERAL | (IDENTIFIER (EQUALS|NOT_EQUALS|LT|LTE|GT|GTE) LITERAL)+
>>>   ;
>>>
>>>atom
>>>     :
>>>         LEFT_PAREN! mexpr RIGHT_PAREN! | LEFT_PAREN! expr RIGHT_PAREN!
>>>   ;
>>>
>>>      
>>>
>>thanks again for your advice,
>>Mark
>>
>>Gabriel Radu wrote:
>>
>>    
>>
>>>Dear Mark,
>>>
>>>I suggest using syntactic predicates. Also increasing the lexers look
>>>ahead to 2 (k=2) for example may sort out the ambiguity between LT and
>>>LTE, and GT and GTE. However, if you use syntactic predicates for all
>>>tokens, increasing the look ahead may not be necessary.
>>>
>>>An example of using syntactic predicates for your grammar is following:
>>>
>>>
>>>class SearchQueryLexer extends Lexer;
>>>   options
>>>   {
>>>       charVocabulary='\3'..'\377';
>>>   }
>>>
>>>
>>>MAIN_LEXER_RULE
>>> : ( LITERAL ) => ( LITERAL { $setType( LITERAL ); } )
>>>
>>> | ( NOT_EQUALS ) => ( NOT_EQUALS { $setType( NOT_EQUALS ); } )
>>> | ( LTE ) => ( LTE { $setType( LTE ); } )
>>> | ( GTE ) => ( GTE { $setType( GTE ); } )
>>>
>>> | ( LT ) => ( LT { $setType( LT ); } )
>>> | ( GT ) => ( GT { $setType( GT ); } )
>>>
>>> | ( NOT ) => ( NOT { $setType( NOT ); } )
>>> | ( AND ) => ( AND { $setType( AND ); } )
>>> | ( OR ) => ( OR { $setType( OR ); } )
>>>
>>> | ( LEFT_PAREN ) => ( LEFT_PAREN { $setType( LEFT_PAREN ); } )
>>> | ( RIGHT_PAREN ) => ( RIGHT_PAREN { $setType( RIGHT_PAREN ); } )
>>>
>>> | ( EQUALS ) => ( EQUALS { $setType( EQUALS ); } )
>>>
>>> | ( IDENTIFIER ) => ( IDENTIFIER { $setType( IDENTIFIER ); } )
>>>
>>> | ( WS ) => WS
>>>
>>> ;
>>>
>>>protected
>>>WS
>>>   :
>>>       ('\n' | ' ' | '\t' | '\r')+
>>>       {
>>>           $setType(Token.SKIP);
>>>       }
>>>   ;
>>>
>>>
>>>protected
>>>SINGLE_QUOTE_STRING
>>>   :
>>>       '\''! (~('\''))* '\''!
>>>   ;
>>>
>>>protected
>>>DOUBLE_QUOTE_STRING
>>>   :
>>>       '"'! (~('"'))* '"'!
>>>   ;
>>>
>>>protected
>>>LITERAL
>>>   :
>>>       SINGLE_QUOTE_STRING | DOUBLE_QUOTE_STRING
>>>   ;
>>>
>>>protected
>>>IDENTIFIER
>>>
>>>   options
>>>   {
>>>       testLiterals=true;
>>>   }
>>>
>>>   :
>>>       ('\241'..'\377'|'a'..'z'|'A'..'Z'|'_')
>>>('\241'..'\377'|'a'..'z'|'A'..'Z'|'-'|'_'|'0'..'9'|'.')*
>>>   ;
>>>
>>>protected
>>>LEFT_PAREN
>>>   :    '('        ;
>>>
>>>protected
>>>RIGHT_PAREN
>>>   :    ')'        ;
>>>
>>>protected
>>>NOT
>>>   :    ("NOT"|"not")    ;
>>>
>>>protected
>>>AND
>>>   :    ("AND"|"and")    ;
>>>
>>>protected
>>>OR
>>>   :    ("OR"|"or")        ;
>>>
>>>protected
>>>EQUALS
>>>   :    '='        ;
>>>
>>>protected
>>>NOT_EQUALS
>>>   :    "<>"    ;
>>>
>>>protected
>>>LT
>>>   :    '<'        ;
>>>
>>>protected
>>>LTE
>>>   :    "<="    ;
>>>
>>>protected
>>>GT
>>>   :    '>'        ;
>>>
>>>protected
>>>GTE
>>>   :    ">="    ;
>>>
>>>
>>>The syntactic predicates are in MAIN_LEXER_RULE. The order of
>>>productions (alternative rules) in MAIN_LEXER_RULE is important,
>>>because the lexer will try to match them in the order they are
>>>declared and will stop as soon as it finds a match. So for example LTE
>>>must be above LT because other ways the lexer will match the LT and
>>>then an EQUALS in stead of LTE.
>>>
>>>Let me know if this has solved your problem.
>>>
>>>
>>>Best regards,
>>>Gabriel
>>>
>>>
>>>
>>>
>>>On 05/02/06, Mark R. Diggory <mdiggory@latte.harvard.edu> wrote:
>>>
>>>
>>>      
>>>
>>>>I'm still working on building a Parser for our query syntax. I've
>>>>encountered an issue with nondeterminism. I've included my grammar file:
>>>>
>>>>My question is how can I assure that the boolean predicate AND not the
>>>>quoted string literal "you AND I" do not collide? I'd be very thankful
>>>>to anyone with comments about obvious problems with my grammar file.
>>>>
>>>>thanks,
>>>>Mark
>>>>
>>>>
>>>>
>>>>        
>>>>
>>>>>class SearchQueryParser extends Parser;
>>>>>   options
>>>>>   {
>>>>>         k=3;
>>>>>       exportVocab=SearchQuery;
>>>>>       buildAST = true;   // uses CommonAST by default
>>>>>
>>>>>   }
>>>>>
>>>>>
>>>>>expr
>>>>>   :
>>>>>       mexpr ((AND|OR|NOT) mexpr)*
>>>>>   ;
>>>>>
>>>>>mexpr
>>>>>   :
>>>>>       LITERAL^ | IDENTIFIER^ ((EQUALS|NOT_EQUALS|LT|LTE|GT|GTE)
>>>>>LITERAL^)+
>>>>>   ;
>>>>>
>>>>>
>>>>>atom
>>>>>     :
>>>>>         IDENTIFIER | LEFT_PAREN! expr RIGHT_PAREN!
>>>>>   ;
>>>>>
>>>>>class SearchQueryLexer extends Lexer;
>>>>>   options
>>>>>   {
>>>>>       charVocabulary='\3'..'\377';
>>>>>   }
>>>>>
>>>>>WS
>>>>>   :
>>>>>       ('\n' | ' ' | '\t' | '\r')+
>>>>>       {
>>>>>           $setType(Token.SKIP);
>>>>>       }
>>>>>   ;
>>>>>
>>>>>
>>>>>protected
>>>>>SINGLE_QUOTE_STRING
>>>>>   :
>>>>>       '\''! (~('\''))* '\''!
>>>>>   ;
>>>>>
>>>>>protected
>>>>>DOUBLE_QUOTE_STRING
>>>>>   :
>>>>>       '"'! (~('"'))* '"'!
>>>>>   ;
>>>>>
>>>>>LITERAL
>>>>>   :
>>>>>       SINGLE_QUOTE_STRING | DOUBLE_QUOTE_STRING
>>>>>   ;
>>>>>
>>>>>IDENTIFIER
>>>>>
>>>>>   options
>>>>>   {
>>>>>       testLiterals=true;
>>>>>   }
>>>>>
>>>>>   :
>>>>>       ('\241'..'\377'|'a'..'z'|'A'..'Z'|'_')
>>>>>('\241'..'\377'|'a'..'z'|'A'..'Z'|'-'|'_'|'0'..'9'|'.')*
>>>>>   ;
>>>>>
>>>>>LEFT_PAREN
>>>>>   :    '('        ;
>>>>>
>>>>>RIGHT_PAREN
>>>>>   :    ')'        ;
>>>>>
>>>>>NOT
>>>>>   :    ("NOT"|"not")    ;
>>>>>
>>>>>AND
>>>>>   :    ("AND"|"and")    ;
>>>>>
>>>>>OR
>>>>>   :    ("OR"|"or")        ;
>>>>>
>>>>>EQUALS
>>>>>   :    '='        ;
>>>>>
>>>>>NOT_EQUALS
>>>>>   :    "<>"    ;
>>>>>
>>>>>LT
>>>>>   :    '<'        ;
>>>>>
>>>>>LTE
>>>>>   :    "<="    ;
>>>>>
>>>>>GT
>>>>>   :    '>'        ;
>>>>>
>>>>>GTE
>>>>>   :    ">="    ;
>>>>>
>>>>>
>>>>>          
>>>>>
>>>>
>>>>        
>>>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060207/fa427fd3/attachment-0001.html
From Thomas_Krebs at gmx.de  Tue Feb  7 08:46:59 2006
From: Thomas_Krebs at gmx.de (Thomas Krebs)
Date: Tue Feb  7 08:47:04 2006
Subject: [antlr-interest] literal and string distinction
Message-ID: <43E8CF03.9090403@gmx.de>

hi,

A file format I have to read does not distiguish between literals and
strings. So at any time a string value can have the value of a literal.
Is there any reasonable way of dealing with that?

I'm thinking of something like what is accomplished with the
options "testLiterals" of the lexer which I would like to be able to set
in rules from the parser.

Currently my rules in the parser honour the literals wherever a
string can occur, which is quite ugly.

Any solution?
Thomas

From sunjigang1965 at yahoo.com.cn  Tue Feb  7 09:38:38 2006
From: sunjigang1965 at yahoo.com.cn (=?gb2312?q?=CB=EF=BC=CD=B8=D5=20Jigang=20(Robert)=20Sun?=)
Date: Tue Feb  7 09:38:56 2006
Subject: [antlr-interest] A problem with loading AST Node type (screen pic
	attached)
Message-ID: <20060207173838.91230.qmail@web15701.mail.cnb.yahoo.com>

Skipped content of type multipart/alternative-------------- next part --------------
A non-text attachment was scrubbed...
Name: node_loading_problem copy.jpg
Type: image/pjpeg
Size: 26727 bytes
Desc: 2675539902-node_loading_problem copy.jpg
Url : http://www.antlr.org/pipermail/antlr-interest/attachments/20060208/0bbbc57c/node_loading_problemcopy-0001.bin
From open.zone at virgin.net  Tue Feb  7 10:02:24 2006
From: open.zone at virgin.net (Micheal J)
Date: Tue Feb  7 09:45:57 2006
Subject: [antlr-interest] A problem with loading AST Node type (screen
	picattached)
In-Reply-To: <20060207173838.91230.qmail@web15701.mail.cnb.yahoo.com>
Message-ID: <002201c62c10$a76857d0$6402a8c0@hercules>

Nothing springs to mind that can help directly. I can only confirm that the heteroAST examples works fine here (.NET 1.1) and it's doing exactly what you are.
 
- Does that example work on your system?
 
- Did you build a .NET 2.0 version of the antlr.runtime.dll?
 
Micheal

-----Original Message-----
From: antlr-interest-bounces@antlr.org [mailto:antlr-interest-bounces@antlr.org] On Behalf Of ?????? Jigang (Robert) Sun
Sent: 07 February 2006 17:39
To: antlr-interest@antlr.org
Subject: [antlr-interest] A problem with loading AST Node type (screen picattached)


A problem with loading AST Node type occured.

Here is my simplest grammar:

primaryExp
:
INTEGER_LITERAL <AST=INTNode>
;


INTNode class under my namespace (all generated classes and main class are all in the same name space)

public abstract class Expr : antlr.BaseAST{
      public abstract int value();
}

public class INTNode:Expr{
  int val=0;
  public INTNode(Token tok){
   val=int.Parse(tok.getText());
   }
  public override int value(){
   return val;
  }
  
  public override  void initialize(AST t){
  }
  public override  void initialize(IToken t){
  }
  public override  void initialize(int i,string s){
  }
 }
Error occurs when the following method of class ASTFactor y was trying to load my INTNode:


  private Type loadNodeTypeObject(string nodeTypeName)
  {
   Type nodeTypeObject = null;
   bool typeCreated  = false;
   if (nodeTypeName != null)
   {
    foreach (Assembly assem in AppDomain.CurrentDomain.GetAssemblies())
    {
     try
     {
      nodeTypeObject = assem.GetType(nodeTypeName);
      if (nodeTypeObject != null)
      {
       typeCreated = true;
       break;
      }
     }
     catch
     {
      typeCreated = false;
     }
    }
   }
   if (!typeCreated)
   {
    throw new TypeLoadException("Unable to load AST Node Type: '" + nodeTypeName + "'");
   }
   return nodeTypeObject;
  }


the error message is "Unable to load AST Node". I checked locals windows (stepping run mode), found that the node INTNode is "non_public member" as showed on attched picture. I got puzzuled since my class was declared as public.

Jigang





  _____  

??1G??????????? <http://cn.mail.yahoo.com> 
????-????????? <http://cn.zs.yahoo.com>  

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060207/a77206f4/attachment.html
From gabriel.adrian.radu at googlemail.com  Tue Feb  7 10:06:09 2006
From: gabriel.adrian.radu at googlemail.com (Gabriel Radu)
Date: Tue Feb  7 10:06:11 2006
Subject: [antlr-interest] Handling lexical nondeterminism in Tokens
In-Reply-To: <43E8CE9A.3030505@latte.harvard.edu>
References: <43E64701.7070800@latte.harvard.edu>
	<67e2ed240602060340i11c6e102m@mail.gmail.com>
	<43E76A77.5070208@latte.harvard.edu>
	<67e2ed240602060838j17b98d09l@mail.gmail.com>
	<43E8CE9A.3030505@latte.harvard.edu>
Message-ID: <67e2ed240602071006j6e4d4a14w@mail.gmail.com>

Do you have any test cases which work? And what is the generated
parser complaining about when you run the test cases mentioned in your
previous email?

Best regards,
Gabriel



On 07/02/06, Mark R. Diggory <mdiggory@latte.harvard.edu> wrote:
>  Thanks, that is very close to what I need.
>
>  Seems not to work on the following cases, which should all be valid.
>
>  "((foo='bar')AND bim='bam');"
>  "(foo='bar' AND bim='bam');"
>  "foo='bar' AND bim='bam';"
>
>  I've tried different combinations of defining the parethises and the white
> space. Along the lines of the following
>
>  : LEFT_PAREN! expr RIGHT_PAREN!
>  | expr
>  But can't seem to get it right.
>
>  -Mark
>
>
>  Gabriel Radu wrote:
>  Dear Mark,
>
> What about:
>
>
>
>  class SearchQueryParser extends Parser;
>  options
>  {
>  k=3;
>  exportVocab=SearchQuery;
>  buildAST = true; // uses CommonAST by default
>
>  }
>
> statement
>  : LEFT_PAREN! expr RIGHT_PAREN! EOST
>  | expr EOST
>  ;
>
> expr
>  : mexpr ( bool_relations LEFT_PAREN! expr RIGHT_PAREN! )*
>  ;
>
> mexpr
>  : atom ( bool_relations atom )*
>  ;
>
> atom
>  : IDENTIFIER equivalence_relation LITERAL
>  ;
>
> bool_relations : AND|OR|NOT ;
>
> equivalence_relation : EQUALS|NOT_EQUALS|LT|LTE|GT|GTE ;
>
>  where EOST is a token which marks the end of a statement. It can be
> something like end of line or semicolon. Don't forget to add it to the
> lexer as well.
>
> Let me know how you are getting on.
>
>
> Best regards,
> Gabriel
>
>
>
>
> On 06/02/06, Mark R. Diggory <mdiggory@latte.harvard.edu> wrote:
>
>
>  Thanks, I think I understand how this will help in the Lexer. I'm
> currently having problems how to capture how to properly represent the
> syntax in the Parser
>
> Here's a clarification of what I should be able to do with the query
> language:
>
> The smallest "atom" is a LITERAL string, currently this can be in quotes
> or not in quotes. For example:
>
>
>
>  United States
> "Untied States"
>
>  Alternatively a "atom" can be an equivalence relation. For instance:
>
>
>
>  title="Untied States"
> title<>"Untied States"
> date>=2006
>
>  Each atom can have parentheses around it.
>
>
>
>  (title="Untied States")
>
>  equivalence relations can be joined using boolean relations
>
>
>
>  title="Untied States" AND date>=2006
> title="Untied States" OR date>=2006
> title="Untied States" NOT date>=2006
>
>  boolean relations can be wrapped in parentheses to control precedence.
>
>
>
>  title="Untied States" AND (date>=2006 OR author=Steven King)
>
>  I've been trying to capture this using the following parser, but its
> clear now that I'm missing the mark:
>
>
>
>  class SearchQueryParser extends Parser;
>  options
>  {
>  k=3;
>  exportVocab=SearchQuery;
>  buildAST = true; // uses CommonAST by default
>
>  }
>
> expr
>  :
>  mexpr ((AND|OR|NOT) mexpr)*
>  ;
>
> mexpr
>  :
>  LITERAL | (IDENTIFIER (EQUALS|NOT_EQUALS|LT|LTE|GT|GTE)
> LITERAL)+
>  ;
>
> atom
>  :
>  LEFT_PAREN! mexpr RIGHT_PAREN! | LEFT_PAREN! expr RIGHT_PAREN!
>  ;
>
>
>  thanks again for your advice,
> Mark
>
> Gabriel Radu wrote:
>
>
>
>  Dear Mark,
>
> I suggest using syntactic predicates. Also increasing the lexers look
> ahead to 2 (k=2) for example may sort out the ambiguity between LT and
> LTE, and GT and GTE. However, if you use syntactic predicates for all
> tokens, increasing the look ahead may not be necessary.
>
> An example of using syntactic predicates for your grammar is following:
>
>
> class SearchQueryLexer extends Lexer;
>  options
>  {
>  charVocabulary='\3'..'\377';
>  }
>
>
> MAIN_LEXER_RULE
>  : ( LITERAL ) => ( LITERAL { $setType( LITERAL ); } )
>
>  | ( NOT_EQUALS ) => ( NOT_EQUALS { $setType( NOT_EQUALS ); } )
>  | ( LTE ) => ( LTE { $setType( LTE ); } )
>  | ( GTE ) => ( GTE { $setType( GTE ); } )
>
>  | ( LT ) => ( LT { $setType( LT ); } )
>  | ( GT ) => ( GT { $setType( GT ); } )
>
>  | ( NOT ) => ( NOT { $setType( NOT ); } )
>  | ( AND ) => ( AND { $setType( AND ); } )
>  | ( OR ) => ( OR { $setType( OR ); } )
>
>  | ( LEFT_PAREN ) => ( LEFT_PAREN { $setType( LEFT_PAREN ); } )
>  | ( RIGHT_PAREN ) => ( RIGHT_PAREN { $setType( RIGHT_PAREN ); } )
>
>  | ( EQUALS ) => ( EQUALS { $setType( EQUALS ); } )
>
>  | ( IDENTIFIER ) => ( IDENTIFIER { $setType( IDENTIFIER ); } )
>
>  | ( WS ) => WS
>
>  ;
>
> protected
> WS
>  :
>  ('\n' | ' ' | '\t' | '\r')+
>  {
>  $setType(Token.SKIP);
>  }
>  ;
>
>
> protected
> SINGLE_QUOTE_STRING
>  :
>  '\''! (~('\''))* '\''!
>  ;
>
> protected
> DOUBLE_QUOTE_STRING
>  :
>  '"'! (~('"'))* '"'!
>  ;
>
> protected
> LITERAL
>  :
>  SINGLE_QUOTE_STRING | DOUBLE_QUOTE_STRING
>  ;
>
> protected
> IDENTIFIER
>
>  options
>  {
>  testLiterals=true;
>  }
>
>  :
>  ('\241'..'\377'|'a'..'z'|'A'..'Z'|'_')
> ('\241'..'\377'|'a'..'z'|'A'..'Z'|'-'|'_'|'0'..'9'|'.')*
>  ;
>
> protected
> LEFT_PAREN
>  : '(' ;
>
> protected
> RIGHT_PAREN
>  : ')' ;
>
> protected
> NOT
>  : ("NOT"|"not") ;
>
> protected
> AND
>  : ("AND"|"and") ;
>
> protected
> OR
>  : ("OR"|"or") ;
>
> protected
> EQUALS
>  : '=' ;
>
> protected
> NOT_EQUALS
>  : "<>" ;
>
> protected
> LT
>  : '<' ;
>
> protected
> LTE
>  : "<=" ;
>
> protected
> GT
>  : '>' ;
>
> protected
> GTE
>  : ">=" ;
>
>
> The syntactic predicates are in MAIN_LEXER_RULE. The order of
> productions (alternative rules) in MAIN_LEXER_RULE is important,
> because the lexer will try to match them in the order they are
> declared and will stop as soon as it finds a match. So for example LTE
> must be above LT because other ways the lexer will match the LT and
> then an EQUALS in stead of LTE.
>
> Let me know if this has solved your problem.
>
>
> Best regards,
> Gabriel
>
>
>
>
> On 05/02/06, Mark R. Diggory <mdiggory@latte.harvard.edu> wrote:
>
>
>
>
>  I'm still working on building a Parser for our query syntax. I've
> encountered an issue with nondeterminism. I've included my grammar file:
>
> My question is how can I assure that the boolean predicate AND not the
> quoted string literal "you AND I" do not collide? I'd be very thankful
> to anyone with comments about obvious problems with my grammar file.
>
> thanks,
> Mark
>
>
>
>
>
>  class SearchQueryParser extends Parser;
>  options
>  {
>  k=3;
>  exportVocab=SearchQuery;
>  buildAST = true; // uses CommonAST by default
>
>  }
>
>
> expr
>  :
>  mexpr ((AND|OR|NOT) mexpr)*
>  ;
>
> mexpr
>  :
>  LITERAL^ | IDENTIFIER^ ((EQUALS|NOT_EQUALS|LT|LTE|GT|GTE)
> LITERAL^)+
>  ;
>
>
> atom
>  :
>  IDENTIFIER | LEFT_PAREN! expr RIGHT_PAREN!
>  ;
>
> class SearchQueryLexer extends Lexer;
>  options
>  {
>  charVocabulary='\3'..'\377';
>  }
>
> WS
>  :
>  ('\n' | ' ' | '\t' | '\r')+
>  {
>  $setType(Token.SKIP);
>  }
>  ;
>
>
> protected
> SINGLE_QUOTE_STRING
>  :
>  '\''! (~('\''))* '\''!
>  ;
>
> protected
> DOUBLE_QUOTE_STRING
>  :
>  '"'! (~('"'))* '"'!
>  ;
>
> LITERAL
>  :
>  SINGLE_QUOTE_STRING | DOUBLE_QUOTE_STRING
>  ;
>
> IDENTIFIER
>
>  options
>  {
>  testLiterals=true;
>  }
>
>  :
>  ('\241'..'\377'|'a'..'z'|'A'..'Z'|'_')
> ('\241'..'\377'|'a'..'z'|'A'..'Z'|'-'|'_'|'0'..'9'|'.')*
>  ;
>
> LEFT_PAREN
>  : '(' ;
>
> RIGHT_PAREN
>  : ')' ;
>
> NOT
>  : ("NOT"|"not") ;
>
> AND
>  : ("AND"|"and") ;
>
> OR
>  : ("OR"|"or") ;
>
> EQUALS
>  : '=' ;
>
> NOT_EQUALS
>  : "<>" ;
>
> LT
>  : '<' ;
>
> LTE
>  : "<=" ;
>
> GT
>  : '>' ;
>
> GTE
>  : ">=" ;
>
>
>
>
>
>
From parrt at cs.usfca.edu  Tue Feb  7 10:32:09 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Tue Feb  7 10:32:14 2006
Subject: [antlr-interest] $FIRST $FOLLOW
In-Reply-To: <43E8AA6F.4080607@dlr.de>
References: <43E8AA6F.4080607@dlr.de>
Message-ID: <6C394AFC-1C2E-488E-868D-8F45F3E4F51B@cs.usfca.edu>


On Feb 7, 2006, at 6:10 AM, Ulrich Frank wrote:
> So how can I realize this?? I know I have to access  $FIRST and  
> $FOLLOW respectively which is accessible in the grammar file. But I  
> firstly need this information in the main java class where i create  
> a parser object and my gui and secondly I do not need the BitSet (= 
> $FIRST,$FOLLOW) but the names of the Tokens (Symbols), ATTR_ID f.e.  
> When I'm right, i can get the last thing by matching it with the  
> entries in the ...TokenTypes.txt file but isn't there a better/ 
> faster way?

I think there might be a toString() method for bitset that takes a  
token names table, which is in every generated parser.

Ter
From antlr at jazillian.com  Tue Feb  7 12:17:21 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Tue Feb  7 12:17:23 2006
Subject: [antlr-interest] Parsing multiple messages using one parser
In-Reply-To: <200602071514.36112.jens.stegemann@gmx.de>
References: <200602071514.36112.jens.stegemann@gmx.de>
Message-ID: <43E90051.2010007@jazillian.com>

Here are my ReusableJavaParser and ReusableJavaLexer classes.
The comments refer to the relevant mailing list post.
Call resetState() and prepareNextInput() rather than creating new
parser and lexer objects.

Andy

/**
 * The <code>ReusableJavaParser</code> class allows you to create
 * one instanceofan ANTLR-generated parser that you
* can reuse over and over. see
* http://www.antlr.org/pipermail/antlr-interest/2003-April/003631.html
 *
 * @author  Andy Tripp
 */

public class ReusableJavaParser extends JavaRecognizer {

        public ReusableJavaParser(TokenStream lexer) {
                super(lexer);
        }

        public void resetState() {
                // no set method for this protected field.
                this.traceDepth = 0;
                this.getInputState().reset();
        }
}

/**
 * The <code>ReusableJavaLexer</code> class allows you to create one
 * instanceof an ANTLR-generated lexer that you
 * can reuse over and over. See
 * <a 
href="http://www.antlr.org/pipermail/antlr-interest/2003-April/003631.html">here</a>.
  *
 * @author  Andy Tripp
 */
public class ReusableJavaLexer extends JavaLexer {
        private boolean savedCaseSensitive;
        private boolean savedCaseSensitiveLiterals;

        public ReusableJavaLexer(Reader in) {
                super(in);
                savedCaseSensitive = getCaseSensitive();
                savedCaseSensitiveLiterals = getCaseSensitiveLiterals();
        }

        public void prepareNextInput(Reader in) {

                LexerSharedInputState state = new LexerSharedInputState(in);
                this.setInputState(state);

                this.setCaseSensitive(savedCaseSensitive);

                // no set method for this protected field.
                this.caseSensitiveLiterals = savedCaseSensitiveLiterals;
        }
}

From kroepke at dolphin-services.de  Tue Feb  7 13:51:39 2006
From: kroepke at dolphin-services.de (Kay Roepke)
Date: Tue Feb  7 13:51:45 2006
Subject: [antlr-interest] [v3] not including text in token. Still possible?
In-Reply-To: <1F28593B-DDCE-4B1F-9555-233705A31981@cs.usfca.edu>
References: <1F4404A0-4EDD-49F5-A3F9-75FC2EE0905E@dolphin-services.de>
	<A7E1D589-75F6-4C11-8CC9-C6AF8957FD31@cs.usfca.edu>
	<69667D34-0823-4156-B128-A242A12718FA@dolphin-services.de>
	<D13EAFB5-D619-4C9E-ACDC-9D20FF749E79@cs.usfca.edu>
	<C7CC0181-C03D-4CDF-8F7A-339E43F942DD@dolphin-services.de>
	<935ECFA3-3D26-47A1-8793-C659C9726AB7@cs.usfca.edu>
	<EF5ED4B6-54F9-4CF5-951C-D47100C65F4D@dolphin-services.de>
	<98CA1BA7-3A5A-4338-B031-4434A97B6FCE@cs.usfca.edu>
	<43D0898E-811E-44FA-A9CC-6721B472161E@dolphin-services.de>
	<1F28593B-DDCE-4B1F-9555-233705A31981@cs.usfca.edu>
Message-ID: <39A2B1E7-7E9B-44ED-A748-D88347360249@dolphin-services.de>

Moin moin people!

On 7. Feb 2006, at 1:44 Uhr, Terence Parr wrote:
> Some time ago, I fell on my keyboard, yielding:
>> Oh, I was talking about the case where I don't have any bangs in  
>> the rule. But from entering the rule I cannot look forward onto  
>> all the atoms within
>> the rule, can I? (Or rather, the tree walker isn't doing that.)
>
> If there are no bangs lexically present in the rule, don't generate  
> the special code. :)

In my infinite naivet? I actually succeded ;)

>> So in the general case without any bangs, I don't want to create  
>> any string. I want to rely on the indices into the input buffer.
>
> Yep.  Only do new stuff if you see a !.  Even if it's in a (..)?  
> block.

Alright, the first version is now working.
What I do is the following:
Upon entering a rule (in codegen.g) I do a #rule.findFirstType(BANG)  
to determine whether this rule has a bang somewhere inside.
If that's true (i.e. the result non-null) I turn on a flag that gets  
set as an attribute in the lexerRule template.
Then I create a new empty StringBuffer.
If I see a bang attached to an atom I grab the text from start to  
getCharIndex()-1 and put that into the StringBuffer. After the
match I set start=getCharIndex(). Repeat.
At the end of the rule I emit a token with the new emit method that  
takes a String as parameter instead of start,stop.

Done. Works beautifully. Does it sound the least sensible, or did I  
do something horrible? ;)

-k 
From parrt at cs.usfca.edu  Tue Feb  7 13:59:21 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Tue Feb  7 13:59:24 2006
Subject: [antlr-interest] [v3] not including text in token. Still possible?
In-Reply-To: <39A2B1E7-7E9B-44ED-A748-D88347360249@dolphin-services.de>
References: <1F4404A0-4EDD-49F5-A3F9-75FC2EE0905E@dolphin-services.de>
	<A7E1D589-75F6-4C11-8CC9-C6AF8957FD31@cs.usfca.edu>
	<69667D34-0823-4156-B128-A242A12718FA@dolphin-services.de>
	<D13EAFB5-D619-4C9E-ACDC-9D20FF749E79@cs.usfca.edu>
	<C7CC0181-C03D-4CDF-8F7A-339E43F942DD@dolphin-services.de>
	<935ECFA3-3D26-47A1-8793-C659C9726AB7@cs.usfca.edu>
	<EF5ED4B6-54F9-4CF5-951C-D47100C65F4D@dolphin-services.de>
	<98CA1BA7-3A5A-4338-B031-4434A97B6FCE@cs.usfca.edu>
	<43D0898E-811E-44FA-A9CC-6721B472161E@dolphin-services.de>
	<1F28593B-DDCE-4B1F-9555-233705A31981@cs.usfca.edu>
	<39A2B1E7-7E9B-44ED-A748-D88347360249@dolphin-services.de>
Message-ID: <B8AF4ED1-18D6-46F0-8DCF-13D7F565F42E@cs.usfca.edu>


On Feb 7, 2006, at 1:51 PM, Kay Roepke wrote:
>> If there are no bangs lexically present in the rule, don't  
>> generate the special code. :)
>
> In my infinite naivet? I actually succeded ;)

Hooray!

>>> So in the general case without any bangs, I don't want to create  
>>> any string. I want to rely on the indices into the input buffer.
>>
>> Yep.  Only do new stuff if you see a !.  Even if it's in a (..)?  
>> block.
>
> Alright, the first version is now working.

Great!

> What I do is the following:
> Upon entering a rule (in codegen.g) I do a #rule.findFirstType 
> (BANG) to determine whether this rule has a bang somewhere inside.
> If that's true (i.e. the result non-null) I turn on a flag that  
> gets set as an attribute in the lexerRule template.

Hi wonder if you would be better to create a separate template called  
lecture lexerRuleModifiedTest or something.

> Then I create a new empty StringBuffer.
> If I see a bang attached to an atom I grab the text from start to  
> getCharIndex()-1 and put that into the StringBuffer. After the
> match I set start=getCharIndex(). Repeat.

Nice!

> At the end of the rule I emit a token with the new emit method that  
> takes a String as parameter instead of start,stop.

hooray!

> Done. Works beautifully. Does it sound the least sensible, or did I  
> do something horrible? ;)

  Sensible :)  and correct minus the caveat above about the separate  
rule.  You can toss me your modified codegen.g and template file if  
you want and I'll take a look for inclusion.

Ter
From AdamB at datacom.co.nz  Tue Feb  7 14:16:53 2006
From: AdamB at datacom.co.nz (Adam Bishop (DSLWN))
Date: Tue Feb  7 14:17:04 2006
Subject: [antlr-interest] Languages where keywords can be used as identifiers
Message-ID: <46562C5EECFA8C47AADDF029EE11D73D02709F17@dnzwgex1.datacom.co.nz>

I am parsing a language where "loop" is a keyword, however a label can
be named loop.  The rule for label expects an identifier token, but the
lexer will return a loop token.  Is there any way to switch testLiterals
for a particular rule?

 

Ideally the Lexer shouldn't be doing testLiterals for any usage of the
token ID in the parser.

 

NOTE:  To make things worse, I am having this problem wherever I have a
rule in the parser that expects an identifier

e.g.

 

"goto" ID

 

Will fail for input "goto loop"

 

And 

 

datatype ID 

 

will fail for "Number length" (since length is a keyword in another
rule)

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060208/4c209697/attachment.html
From parrt at cs.usfca.edu  Tue Feb  7 14:25:44 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Tue Feb  7 14:25:53 2006
Subject: [antlr-interest] Languages where keywords can be used as
	identifiers
In-Reply-To: <46562C5EECFA8C47AADDF029EE11D73D02709F17@dnzwgex1.datacom.co.nz>
References: <46562C5EECFA8C47AADDF029EE11D73D02709F17@dnzwgex1.datacom.co.nz>
Message-ID: <C31D13A9-CC0E-40B3-8546-D25E2E16BF68@cs.usfca.edu>


On Feb 7, 2006, at 2:16 PM, Adam Bishop (DSLWN) wrote:

> I am parsing a language where ?loop? is a keyword, however a label  
> can be named loop.  The rule for label expects an identifier token,  
> but the lexer will return a loop token.  Is there any way to switch  
> testLiterals for a particular rule?
>
>
>
> Ideally the Lexer shouldn?t be doing testLiterals for any usage of  
> the token ID in the parser.
>
>
>
> NOTE:  To make things worse, I am having this problem wherever I  
> have a rule in the parser that expects an identifier
>
> e.g.
>
>
>
> ?goto? ID
>
>
>
> Will fail for input ?goto loop?
I would not use "loop" as a keyword ever.  Then when you have a  
statement that uses loop as a keyword, use a semantic predicate:

stat : {LT(1).getText().equals("loop")}? ID ...
        | "if" ...
       ...
        ;

Ter
From kroepke at dolphin-services.de  Tue Feb  7 14:46:59 2006
From: kroepke at dolphin-services.de (Kay Roepke)
Date: Tue Feb  7 14:47:05 2006
Subject: [antlr-dev] Re: [antlr-interest] [v3] not including text in
	token. Still possible?
In-Reply-To: <B8AF4ED1-18D6-46F0-8DCF-13D7F565F42E@cs.usfca.edu>
References: <1F4404A0-4EDD-49F5-A3F9-75FC2EE0905E@dolphin-services.de>
	<A7E1D589-75F6-4C11-8CC9-C6AF8957FD31@cs.usfca.edu>
	<69667D34-0823-4156-B128-A242A12718FA@dolphin-services.de>
	<D13EAFB5-D619-4C9E-ACDC-9D20FF749E79@cs.usfca.edu>
	<C7CC0181-C03D-4CDF-8F7A-339E43F942DD@dolphin-services.de>
	<935ECFA3-3D26-47A1-8793-C659C9726AB7@cs.usfca.edu>
	<EF5ED4B6-54F9-4CF5-951C-D47100C65F4D@dolphin-services.de>
	<98CA1BA7-3A5A-4338-B031-4434A97B6FCE@cs.usfca.edu>
	<43D0898E-811E-44FA-A9CC-6721B472161E@dolphin-services.de>
	<1F28593B-DDCE-4B1F-9555-233705A31981@cs.usfca.edu>
	<39A2B1E7-7E9B-44ED-A748-D88347360249@dolphin-services.de>
	<B8AF4ED1-18D6-46F0-8DCF-13D7F565F42E@cs.usfca.edu>
Message-ID: <176FA18E-870B-4B0F-9182-91ED2BB78B56@dolphin-services.de>


On 7. Feb 2006, at 22:59 Uhr, Terence Parr wrote:

>  Sensible :)  and correct minus the caveat above about the separate  
> rule.  You can toss me your modified codegen.g and template file if  
> you want and I'll take a look for inclusion.

:)
I'll add the extra template and will add the missing code for the  
string literals and tokenrefs.
Probably later tonight ;)
From greenj at ix.netcom.com  Tue Feb  7 15:13:14 2006
From: greenj at ix.netcom.com (John Green)
Date: Tue Feb  7 15:13:20 2006
Subject: [antlr-interest] Languages where keywords can be used as
	identifiers
In-Reply-To: <46562C5EECFA8C47AADDF029EE11D73D02709F17@dnzwgex1.datacom.co.nz>
References: <46562C5EECFA8C47AADDF029EE11D73D02709F17@dnzwgex1.datacom.co.nz>
Message-ID: <43E9298A.7060307@ix.netcom.com>

I went through the same thing a long time ago. To do it similar to what I did:

The lexer would always recognize "loop" as a keyword token LOOP.

The grammar would have a rule like:
  unreservedkeyword: loop | etc | etc ;

The grammar would use a rule named "id":
  id: ID | unreservedkeyword ;

But enhance that last rule a bit, so that when you add it to the tree, you change the type from LOOP (or whatever keyword) to ID:
  id: ID | urk:unreservedkeyword { #urk.setType(ID); }
I probably have the syntax wrong for setType, sorry, this is off the top of my head.

Now your grammar can use:
  "goto" id
and
  datatype id


HTH,
John
john at joanju dot com


Adam Bishop (DSLWN) wrote:
> I am parsing a language where ?loop? is a keyword, however a label can 
> be named loop.  The rule for label expects an identifier token, but the 
> lexer will return a loop token.  Is there any way to switch testLiterals 
> for a particular rule?
> 
>  
> 
> Ideally the Lexer shouldn?t be doing testLiterals for any usage of the 
> token ID in the parser.
> 
>  
> 
> NOTE:  To make things worse, I am having this problem wherever I have a 
> rule in the parser that expects an identifier
> 
> e.g.
> 
>  
> 
> ?goto? ID
> 
>  
> 
> Will fail for input ?goto loop?
> 
>  
> 
> And
> 
>  
> 
> datatype ID
> 
>  
> 
> will fail for ?Number length? (since length is a keyword in another rule)
> 
>  
> 

From AdamB at datacom.co.nz  Tue Feb  7 15:37:08 2006
From: AdamB at datacom.co.nz (Adam Bishop (DSLWN))
Date: Tue Feb  7 15:37:22 2006
Subject: [antlr-interest] Languages where keywords can be used as
	identifiers
Message-ID: <46562C5EECFA8C47AADDF029EE11D73D02709F8E@dnzwgex1.datacom.co.nz>

Thanks.
The problem with this is that the list of (unreserved) keywords is
expanding, so I would need to maintain the unreservedKeyword rule.  I
need some way of guaranteeing that all of the keywords are in the rule,
so I could use the literals txt file generated to generate the
unreservedKeyword rule and import that rule into the grammar...

I have been trying a different approach, and have made a method that
(greedily) fetches and matches the next token

	/**
	  * Returns the string of the identifier.
	  * <p>Should be used instead of the ID token, since the ID
token will only be returned
	  * by the lexer if the identifier is not a keyword
	  * <p>Show caution in the use of this method, particularly if
ID is only one of many options.  
	  * If it is then getID should be the last option, as it will
physically force the parser to chew up the next token regardless (i.e.
always matches)
	  * @throws TokenStreamException 
	  * @throws MismatchedTokenException 
	  **/
	private Token getID() throws MismatchedTokenException,
TokenStreamException{
		Token result = LT(1);
		match(result.getType());
		return result;
	}

It works in the case that the rule actually can be greedy, but the
obvious downsides of this are that the getID needs to be the last option
within any selection, and if it is part of an optional clause it will
fail.  I could modify it to stop it calling match 100% of the time
(possibly by passing in an exception set of tokens)

But both of these approaches seem to be... less than elegant.

Are there any hooks (from the parser) into the lexer, to tell it to
switch off testLiterals, or (due to lookahead) is it already too late
once the parser is parsing a rule?

P.S. I'm leaning towards your solution.


-----Original Message-----
From: John Green [mailto:greenj@ix.netcom.com] 
Sent: Wednesday, 8 February 2006 12:13 p.m.
To: Adam Bishop (DSLWN)
Cc: antlr-interest@antlr.org
Subject: Re: [antlr-interest] Languages where keywords can be used as
identifiers

I went through the same thing a long time ago. To do it similar to what
I did:

The lexer would always recognize "loop" as a keyword token LOOP.

The grammar would have a rule like:
  unreservedkeyword: loop | etc | etc ;

The grammar would use a rule named "id":
  id: ID | unreservedkeyword ;

But enhance that last rule a bit, so that when you add it to the tree,
you change the type from LOOP (or whatever keyword) to ID:
  id: ID | urk:unreservedkeyword { #urk.setType(ID); }
I probably have the syntax wrong for setType, sorry, this is off the top
of my head.

Now your grammar can use:
  "goto" id
and
  datatype id


HTH,
John
john at joanju dot com


Adam Bishop (DSLWN) wrote:
> I am parsing a language where "loop" is a keyword, however a label can

> be named loop.  The rule for label expects an identifier token, but
the 
> lexer will return a loop token.  Is there any way to switch
testLiterals 
> for a particular rule?
> 
>  
> 
> Ideally the Lexer shouldn't be doing testLiterals for any usage of the

> token ID in the parser.
> 
>  
> 
> NOTE:  To make things worse, I am having this problem wherever I have
a 
> rule in the parser that expects an identifier
> 
> e.g.
> 
>  
> 
> "goto" ID
> 
>  
> 
> Will fail for input "goto loop"
> 
>  
> 
> And
> 
>  
> 
> datatype ID
> 
>  
> 
> will fail for "Number length" (since length is a keyword in another
rule)
> 
>  
> 


From greenj at ix.netcom.com  Tue Feb  7 16:14:40 2006
From: greenj at ix.netcom.com (John Green)
Date: Tue Feb  7 16:15:29 2006
Subject: [antlr-interest] Languages where keywords can be used as
	identifiers
In-Reply-To: <46562C5EECFA8C47AADDF029EE11D73D02709F8E@dnzwgex1.datacom.co.nz>
References: <46562C5EECFA8C47AADDF029EE11D73D02709F8E@dnzwgex1.datacom.co.nz>
Message-ID: <43E937F0.5080707@ix.netcom.com>

> Are there any hooks (from the parser) into the lexer, to tell it to
> switch off testLiterals, or (due to lookahead) is it already too late
> once the parser is parsing a rule?

Due to the lookahead, it's already too late. Having the parser trigger state switches in the lexer just leads to a world of hurt.

I agree about the maintenance issue with regard to keeping a list of unreserved keywords. The grammar I maintain (I wrote a parser for a language called ABL from Progress Software) has over 1000 token types now, most of those are unreserved keywords. I had hoped that your situation was different.

I don't know of any way around the fact that all of the unreserved keywords need to be listed as a rule in your grammar. The parser that Antlr generates needs that rule so that it can deal with lookahead issues.

John at joanju dot com


Adam Bishop (DSLWN) wrote:
> Thanks.
> The problem with this is that the list of (unreserved) keywords is
> expanding, so I would need to maintain the unreservedKeyword rule.  I
> need some way of guaranteeing that all of the keywords are in the rule,
> so I could use the literals txt file generated to generate the
> unreservedKeyword rule and import that rule into the grammar...
> 
> I have been trying a different approach, and have made a method that
> (greedily) fetches and matches the next token
> 
> 	/**
> 	  * Returns the string of the identifier.
> 	  * <p>Should be used instead of the ID token, since the ID
> token will only be returned
> 	  * by the lexer if the identifier is not a keyword
> 	  * <p>Show caution in the use of this method, particularly if
> ID is only one of many options.  
> 	  * If it is then getID should be the last option, as it will
> physically force the parser to chew up the next token regardless (i.e.
> always matches)
> 	  * @throws TokenStreamException 
> 	  * @throws MismatchedTokenException 
> 	  **/
> 	private Token getID() throws MismatchedTokenException,
> TokenStreamException{
> 		Token result = LT(1);
> 		match(result.getType());
> 		return result;
> 	}
> 
> It works in the case that the rule actually can be greedy, but the
> obvious downsides of this are that the getID needs to be the last option
> within any selection, and if it is part of an optional clause it will
> fail.  I could modify it to stop it calling match 100% of the time
> (possibly by passing in an exception set of tokens)
> 
> But both of these approaches seem to be... less than elegant.
> 
> Are there any hooks (from the parser) into the lexer, to tell it to
> switch off testLiterals, or (due to lookahead) is it already too late
> once the parser is parsing a rule?
> 
> P.S. I'm leaning towards your solution.
> 
> 
> -----Original Message-----
> From: John Green [mailto:greenj@ix.netcom.com] 
> Sent: Wednesday, 8 February 2006 12:13 p.m.
> To: Adam Bishop (DSLWN)
> Cc: antlr-interest@antlr.org
> Subject: Re: [antlr-interest] Languages where keywords can be used as
> identifiers
> 
> I went through the same thing a long time ago. To do it similar to what
> I did:
> 
> The lexer would always recognize "loop" as a keyword token LOOP.
> 
> The grammar would have a rule like:
>   unreservedkeyword: loop | etc | etc ;
> 
> The grammar would use a rule named "id":
>   id: ID | unreservedkeyword ;
> 
> But enhance that last rule a bit, so that when you add it to the tree,
> you change the type from LOOP (or whatever keyword) to ID:
>   id: ID | urk:unreservedkeyword { #urk.setType(ID); }
> I probably have the syntax wrong for setType, sorry, this is off the top
> of my head.
> 
> Now your grammar can use:
>   "goto" id
> and
>   datatype id
> 
> 
> HTH,
> John
> john at joanju dot com
> 
> 
> Adam Bishop (DSLWN) wrote:
>> I am parsing a language where "loop" is a keyword, however a label can
> 
>> be named loop.  The rule for label expects an identifier token, but
> the 
>> lexer will return a loop token.  Is there any way to switch
> testLiterals 
>> for a particular rule?
>>
>>  
>>
>> Ideally the Lexer shouldn't be doing testLiterals for any usage of the
> 
>> token ID in the parser.
>>
>>  
>>
>> NOTE:  To make things worse, I am having this problem wherever I have
> a 
>> rule in the parser that expects an identifier
>>
>> e.g.
>>
>>  
>>
>> "goto" ID
>>
>>  
>>
>> Will fail for input "goto loop"
>>
>>  
>>
>> And
>>
>>  
>>
>> datatype ID
>>
>>  
>>
>> will fail for "Number length" (since length is a keyword in another
> rule)
>>  
>>
> 
> 
> 

From kalle at snigel.net  Tue Feb  7 16:49:42 2006
From: kalle at snigel.net (karl wettin)
Date: Tue Feb  7 16:47:58 2006
Subject: [antlr-interest] more newbie help required
Message-ID: <921F860C-7105-48FA-9367-9A42322A0482@snigel.net>

Hi again,

thanks for the inital help. I'm really happy to see that the list is  
active. It was quite impossible to figure out or get help with JavaCC.

(I presume I want to use a tree later on, but for a starter I'll just  
try to get my grammar to work.)

Here is my current problems:

1. I can't figure out why I can't get the matched value of  
expressions within one expression. It's all null. It obviously match.

2. The NUM expression does not work. Try to uncomment the meta:(/*NUM  
|*/ ALPHANUMWORD | LETTER | DIGIT)

3. I have plenty of nondeterminism warnings I presume are related  
with the above, but why they are nondeterminal I have no idea.

Any other comments on the grammar is of course also welcome.


Output from my Main:

null
["s1e9-10",<6>,line=1,col=1]
null
null
null
null
null
["evilpirates",<18>,line=1,col=1]


package se.snigel.tpb.analysis.tvshow;
import java.io.StringReader;
public class Main {	
	public static final void main (String[] args) throws Exception {
		String val = "some.show.s1e9-10.xvid.ac3.5.1.hdtv-evilpirates";
		new TVShowParser(new TVShowLexer(new StringReader(val))).expr();
	}
}



header
{
   package se.snigel.tpb.analysis.tvshow;
   import java.util.*;
}
class TVShowParser extends Parser;

expr :
	WELL_FORMATTED
	| BAD_FORMATTED
     ;
	
class TVShowLexer extends Lexer;

options {
     k=3; // presumed needed for SEASON_AND_EPISODE
}

WELL_FORMATTED : 	
	show:(		
		options { greedy=false; } :
		ALPHANUMWORD ('.' | ('-' ALPHANUMWORD '.')) 		
	)+
	{System.out.println(show);}
	
	sae:SEASON_AND_EPISODE
	{System.out.println(sae);}
	
	((
		options { greedy=false; } :		
		'.'
		meta:(/*NUM |*/ ALPHANUMWORD | LETTER | DIGIT)
		{System.out.println(meta);}
	)+)?
	
	'-'
	group:RELEASE_GROUP
	{System.out.println(group);}
	
	;

BAD_FORMATTED :
	(	
		options { greedy=false; } :
		ALPHANUMWORD ((' ' | PUNCT)+)?
	)+
	SEASON_AND_EPISODE
	;

SEASON_AND_EPISODE :		
	STANDARD
	| COMPOSITE
	| SXE
	;
	
STANDARD :
	STANDARD_SEASON (('.' | ' ')+)? STANDARD_EPISODE	
	(	
		STANDARD_VECTOR
		| STANDARD_SEQUENCE
	)?
	;
	
STANDARD_SEASON :
	("season" | "s?song" | 's')
	(('.' | ' ')+)?
	SEASON_NUMBER
	;

STANDARD_EPISODE :
	("episode" | ('e'('p'('s')?)?) | "avsnitt")
	(('.' | ' ')+)?
	EPISODE_NUMBER
	;
	
STANDARD_SEQUENCE :
	'-'
	(STANDARD_SEASON)?
	(STANDARD_EPISODE | EPISODE_NUMBER)
	;

STANDARD_VECTOR : 	
	(
		(' ' | '+' | '.' | ',')
		(STANDARD_SEASON)?
		STANDARD_EPISODE
	)+
	;
		
SXE :
	SEASON_NUMBER 'x' EPISODE_NUMBER
	;	

/** 1 - 49 */
SEASON_NUMBER: 	
	('0')? '1'..'9'
	| '1'..'4' '0'..'9'
	;

/** 1 - 39 */
EPISODE_NUMBER:
	('0')? '1'..'9'
	| '1'..'3' '0'..'9'
	;

/** 109 */
COMPOSITE :
	COMPOSITE_SEASON COMPOSITE_EPISODE
	;
	
	
/** 1 - 9 */
COMPOSITE_SEASON :
	'1'..'9'
	;

/** 1 - 39 */
COMPOSITE_EPISODE :
	'0' '1'..'9'
	| '1'..'3' '0'..'9'
	;

RELEASE_GROUP :	
	(ALPHANUMWORD | ACRONYM)
	;

/** unicode roman letters */
LETTER:					
     '\u0041'..'\u005a'
     | '\u0061'..'\u007a'
     | '\u00c0'..'\u00d6'
     | '\u00d8'..'\u00f6'
     | '\u00f8'..'\u00ff'
     | '\u0100'..'\u1fff'
	;
	
/** unicode korean */
KOREAN :
	'\uac00' .. '\ud7af'
	;
	
/** chinese and japanese */
CJ :
	'\u3040'..'\u318f'
     | '\u3300'..'\u337f'
     | '\u3400'..'\u3d2d'
     | '\u4e00'..'\u9fff'
     | '\uf900'..'\ufaff'
	;


/** basic word: a sequence of digits & letters */
ALPHANUMWORD :
	(LETTER | DIGIT | KOREAN)+
     ;

/** I.B.M., C.S.I. et.c. becomes IBM, CSI.. */
ACRONYM :
	LETTER '.'! (LETTER '.'!)+ 	
	;

/** word with at least one digit */
HAS_DIGIT :
     (LETTER | DIGIT)*
     DIGIT
     (LETTER | DIGIT)*
	;
	
PUNCT :
	'_'
	|'-'
	|'/'
	|'.'
	|','
	;	

/** floating point, serial, model numbers, ip addresses, et.c.
  	every other segment must have at least one digit */
NUM :	
	ALPHANUMWORD PUNCT HAS_DIGIT
	| HAS_DIGIT PUNCT ALPHANUMWORD
	| ALPHANUMWORD (PUNCT HAS_DIGIT PUNCT ALPHANUMWORD)+
	| HAS_DIGIT (PUNCT ALPHANUMWORD PUNCT HAS_DIGIT)+
	| ALPHANUMWORD PUNCT HAS_DIGIT (PUNCT ALPHANUMWORD PUNCT HAS_DIGIT)+
	| HAS_DIGIT PUNCT ALPHANUMWORD (PUNCT HAS_DIGIT PUNCT ALPHANUMWORD)+
	;
	
/** unicode digits */
DIGIT :
     '\u0030'..'\u0039'
     | '\u0660'..'\u0669'
     | '\u06f0'..'\u06f9'
     | '\u0966'..'\u096f'
     | '\u09e6'..'\u09ef'
     | '\u0a66'..'\u0a6f'
     | '\u0ae6'..'\u0aef'
     | '\u0b66'..'\u0b6f'
     | '\u0be7'..'\u0bef'
     | '\u0c66'..'\u0c6f'
     | '\u0ce6'..'\u0cef'
     | '\u0d66'..'\u0d6f'
     | '\u0e50'..'\u0e59'
     | '\u0ed0'..'\u0ed9'
     | '\u1040'..'\u1049'
	;
	
	



From Anil.Srikantham at ips.invensys.com  Tue Feb  7 20:06:33 2006
From: Anil.Srikantham at ips.invensys.com (Srikantham, Anil)
Date: Tue Feb  7 20:05:47 2006
Subject: [antlr-interest] Help Needed on throwing exceptions
Message-ID: <EFF5C5151B047043BA1CEFD9CBA62C3D042347F6@inidchydxch001.inidchydpdc>

Hi,

I'm currently working on a compiler for IEC 61131 languages.
I'm using ANTLR 2.7.2 and things look fine till now.
But I see a problem when I throw explicitly an exception based on a
condition in the parser. 

I use a default try-catch block and the catch block has a function
consumeUntil which consumes some tokens when this exception is raised.

To negate this I used mark and rewind.

Can there be a better solution??? Or is it a problem with this version of
ANTLR.

function_call! {int funcNameMark = 0; } :

r2:function_name  LEFT_PAREN! p2:param_value_list { funcNameMark = mark(); }
RIGHT_PAREN!
		{ 

//-----this is the exception that I throw -----
			if(gPositionalParamsCnt != 0 &&  gNamedParamsCnt !=
0)
			{
				gPositionalParamsCnt = 0;
				gNamedParamsCnt = 0;
				rewind(funcNameMark);
				throw new RecognitionException( "Function
call to " + r2_AST.ToString() + " has both positional and named arguments");

			}

			#function_call = #(#[FUNCTION_CALL,"FUNCTION_CALL"],
r2, p2 ); 
			
		}


Thanks --- Anil




Confidentiality Notice: The information contained in this electronic message
and any attachment(s) to this message are intended for the exclusive use of
the recipient(s) and may contain confidential, privileged or proprietary
information. If you are not the intended recipient, please notify the sender
immediately, delete all copies of this message and any attachment(s). Any
other use of the E-Mail by you is prohibited.



From Thomas_Krebs at gmx.de  Wed Feb  8 00:11:40 2006
From: Thomas_Krebs at gmx.de (Thomas Krebs)
Date: Wed Feb  8 00:11:48 2006
Subject: [antlr-interest] Languages where keywords can be used
	as	identifiers
In-Reply-To: <43E937F0.5080707@ix.netcom.com>
References: <46562C5EECFA8C47AADDF029EE11D73D02709F8E@dnzwgex1.datacom.co.nz>
	<43E937F0.5080707@ix.netcom.com>
Message-ID: <43E9A7BC.5070703@gmx.de>

John Green wrote:
>> Are there any hooks (from the parser) into the lexer, to tell it to
>> switch off testLiterals, or (due to lookahead) is it already too late
>> once the parser is parsing a rule?
> 
> 
> Due to the lookahead, it's already too late. Having the parser trigger 
> state switches in the lexer just leads to a world of hurt.
> 
> I agree about the maintenance issue with regard to keeping a list of 
> unreserved keywords. The grammar I maintain (I wrote a parser for a 
> language called ABL from Progress Software) has over 1000 token types 
> now, most of those are unreserved keywords. I had hoped that your 
> situation was different.
> 
> I don't know of any way around the fact that all of the unreserved 
> keywords need to be listed as a rule in your grammar. The parser that 
> Antlr generates needs that rule so that it can deal with lookahead issues.
> 
> John at joanju dot com
> 

Facing the same problem at the same time (see my post: "literal and
string distinction", I got an idea:
Wouldn't it make sense (if possible?) to switch between different lexers
with one dealing with keywords and the other not?
Is switching of lexers possible/supported or does lookahead render this
impossible?

Thomas
From kalle at snigel.net  Wed Feb  8 03:19:26 2006
From: kalle at snigel.net (karl wettin)
Date: Wed Feb  8 03:17:44 2006
Subject: [antlr-interest] more newbie help required
In-Reply-To: <921F860C-7105-48FA-9367-9A42322A0482@snigel.net>
References: <921F860C-7105-48FA-9367-9A42322A0482@snigel.net>
Message-ID: <99CD2E17-1813-46CC-B358-49987ED03D53@snigel.net>


8 feb 2006 kl. 01.49 skrev karl wettin:

> 1. I can't figure out why I can't get the matched value of  
> expressions within one expression. It's all null. It obviously match.
>

So it seems as I must call other grammar in order to get a value?  
E.g. foo:BAR and not foo:(BAR | SHAKE) ? At least that gives me some  
data.

Howver, I can't figure out who to extract the show grammar. Is it  
possible to break in grammar? E.g. if new expression SHOW contains a  
SEASON_AND_EPISODE, then it should break. That is the only way I can  
think of.


New output:
null
["s1e9-10",<7>,line=1,col=1]
["xvid",<6>,line=1,col=1]
["ac3.5.1",<6>,line=1,col=1]
["hdtv",<6>,line=1,col=1]
["evilpirates",<19>,line=1,col=1]


WELL_FORMATTED : 	
	show:(		
		options { greedy=false; } :
		ALPHANUMWORD ('.' | ('-' ALPHANUMWORD '.'))
	)+
	{System.out.println(show);}
	
	sae:SEASON_AND_EPISODE
	{System.out.println(sae);}
	
	((
		options { greedy=false; } :		
		'.'
		meta:META_TAG
		{System.out.println(meta);}
	)+)?
	
	'-'
	group:RELEASE_GROUP
	{System.out.println(group);}
	
	;

META_TAG :
	ALPHANUMWORD (('.' (DIGIT)+)+)?
	;


From jens.stegemann at gmx.de  Wed Feb  8 06:06:57 2006
From: jens.stegemann at gmx.de (Jens Stegemann)
Date: Wed Feb  8 06:07:01 2006
Subject: [antlr-interest] Parsing multiple messages using one parser
In-Reply-To: <bc607a4e0602070633o2220581td2d270b90d98c0e6@mail.gmail.com>
References: <200602071514.36112.jens.stegemann@gmx.de>
	<bc607a4e0602070633o2220581td2d270b90d98c0e6@mail.gmail.com>
Message-ID: <200602081506.57247.jens.stegemann@gmx.de>

Hi Ric,

first: thank you very much for your answer. I again searched the archive of 
this list as much as possible (for me), but could not find code how to reuse 
existing Lexer/Parser - instances to parse another stream. All I found is 
that others had the same problems earlier, but no solution.

Would you please be so kind to send some to me or post it on the mailing-list? 
This would be a great help!


Your's

Jens

-- 
Keep your dreams alive and live your dreams!
From mail at martin-probst.com  Wed Feb  8 06:17:25 2006
From: mail at martin-probst.com (Martin Probst)
Date: Wed Feb  8 06:17:40 2006
Subject: [antlr-interest] Recommendation for Lexer
Message-ID: <1139408246.6072.24.camel@localhost.localdomain>

Hi all,
it's me again, the guy with the problem called XQuery. I'm currently
having the following situation:
- we have an ANTLR 2.x parser that is working well even if the code is
  by now a bit cryptic
- we have a handwritten Lexer that is fast, but sucks wrt
  maintainability
We originally went for a handwritten Lexer because my precursor didn't
get ANTLR to produce anything usable for a stateful language like
XQuery. The Lexer works, but had quite a lot of bugs in the seldomly
used code paths as it's a huge pain to maintain (think: unending
switches over characters, matching, guessing etc. all done by hand).
Adding keywords and states requires a lot of work and testing.

Now I'm going to add several language extensions and I'm ready to dump
the handwritten Lexer. The problem is: I can't go with ANTLR the way it
currently is - the language is keyword less and in addition to that
requires several states (~16). Switching lexers after each token is not
an option, plus we also need stackable states.

I tricked Terence into doing the language islands feature for ANTLR 3,
but unfortunately I need a new lexer long before the summer (and ANTLR 3
will only be in beta in the summer, no?).

So can anyone recommend me an alternative? I'm currently toying around
with JFlex which looks good (feature wise, the syntax less so). There
seems to be an abundance of tools, has anyone made experiences there?

Thanks,
Martin

From ric.klaren at gmail.com  Wed Feb  8 07:00:00 2006
From: ric.klaren at gmail.com (Ric Klaren)
Date: Wed Feb  8 07:00:03 2006
Subject: [antlr-interest] Parsing multiple messages using one parser
In-Reply-To: <200602081506.57247.jens.stegemann@gmx.de>
References: <200602071514.36112.jens.stegemann@gmx.de>
	<bc607a4e0602070633o2220581td2d270b90d98c0e6@mail.gmail.com>
	<200602081506.57247.jens.stegemann@gmx.de>
Message-ID: <bc607a4e0602080700k2248ef60p353f111f0481cd93@mail.gmail.com>

On 2/8/06, Jens Stegemann <jens.stegemann@gmx.de> wrote:
> first: thank you very much for your answer. I again searched the archive of
> this list as much as possible (for me), but could not find code how to reuse
> existing Lexer/Parser - instances to parse another stream. All I found is
> that others had the same problems earlier, but no solution.

It looks like the search on antlr.org does not cover the mailing list
anymore? Anyway I tried finding the post again via:

http://www.onelist.com/archives/antlr-interest

But failed :(

> Would you please be so kind to send some to me or post it on the mailing-list?
> This would be a great help!

I'll dig up the code at home and repost.

Cheers,

Ric
From parrt at cs.usfca.edu  Wed Feb  8 09:15:20 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Wed Feb  8 09:15:21 2006
Subject: [antlr-interest] Parsing multiple messages using one parser
In-Reply-To: <bc607a4e0602080700k2248ef60p353f111f0481cd93@mail.gmail.com>
References: <200602071514.36112.jens.stegemann@gmx.de>
	<bc607a4e0602070633o2220581td2d270b90d98c0e6@mail.gmail.com>
	<200602081506.57247.jens.stegemann@gmx.de>
	<bc607a4e0602080700k2248ef60p353f111f0481cd93@mail.gmail.com>
Message-ID: <A8ED9BF7-757D-43C5-956F-A1932EB7451F@cs.usfca.edu>


On Feb 8, 2006, at 7:00 AM, Ric Klaren wrote:
> It looks like the search on antlr.org does not cover the mailing list
> anymore? Anyway I tried finding the post again via:

Does for me...I just did a search.

Ter

From seclib at seclib.com  Wed Feb  8 09:42:41 2006
From: seclib at seclib.com (Xue Yong Zhi)
Date: Wed Feb  8 09:49:15 2006
Subject: [antlr-interest] Re: Recommendation for Lexer
In-Reply-To: <1139408246.6072.24.camel@localhost.localdomain>
References: <1139408246.6072.24.camel@localhost.localdomain>
Message-ID: <dsdaie$d9j$1@sea.gmane.org>


> 
> Now I'm going to add several language extensions and I'm ready to dump
> the handwritten Lexer. The problem is: I can't go with ANTLR the way it
> currently is - the language is keyword less and in addition to that
> requires several states (~16). Switching lexers after each token is not
> an option, plus we also need stackable states.
> 
> I tricked Terence into doing the language islands feature for ANTLR 3,
> but unfortunately I need a new lexer long before the summer (and ANTLR 3
> will only be in beta in the summer, no?).
> 

I do not know your particular problem, but whatever tool you choose, no 
one can give you a off-the-shelf solution for the state problem. The 
logic for maintaining state has to be implemented by you. Other tools 
may provide better syntax for this, but I think antlr is very good as well.

I am using antlr to prase ruby, which requires lots of states in lexer 
also. I find the problem is manageable: for simple things you can use 
semantic predict, for more complicated ones you can override the 
generated lexer and use all the traditional OO techniques.

Here is simple example: in ruby, '/' can be the DIVIDE operator, or 
start of regular expression (same syntax as in perl), so you can have 
the following lexer rule:
DIV_OR_REGEX
: {exprect_div()}? '/' {$setType(DIV);}
| '/' REGEX_CONTENT '/' {$setType(REGEX);}
;

It is still very readable. sure you need to implment exprect_div(), but 
as I said, this is something you have to do anyway.

HereDoc is more complicated, so I overide nextToken() and macth heredoc 
content based on the current state.

Using multiple lexers is another good choice.

-- 
Xue Yong Zhi
http://seclib.blogspot.com

From mail at martin-probst.com  Wed Feb  8 10:17:57 2006
From: mail at martin-probst.com (Martin Probst)
Date: Wed Feb  8 10:18:09 2006
Subject: [antlr-interest] Re: Recommendation for Lexer
In-Reply-To: <dsdaie$d9j$1@sea.gmane.org>
References: <1139408246.6072.24.camel@localhost.localdomain>
	<dsdaie$d9j$1@sea.gmane.org>
Message-ID: <1139422677.6072.36.camel@localhost.localdomain>

> Here is simple example: in ruby, '/' can be the DIVIDE operator, or 
> start of regular expression (same syntax as in perl), so you can have 
> the following lexer rule:
> DIV_OR_REGEX
> : {exprect_div()}? '/' {$setType(DIV);}
> | '/' REGEX_CONTENT '/' {$setType(REGEX);}
> ;

This works if you've got 5 or 6 single ambiguities. In my language,
every keyword (and there are about 50) is ambiguous as it could also be
an identifier. Plus some other ambiguities unrelated to that. Plus XML
as an island language (directly embeddable but you can again call out to
XQuery). I tried going with ANTLR some time ago, but it all ends up in a
mess. The above code from you also only works for a fixed k == 1 without
predicates (this can bite you really ugly!).

JFlex looks good at the moment. It doesn't impose any class inheritance
on you and the generated lexer is completely standalone, so it should be
easy to integrate with ANTLR. Plus it brings native support for the
issues I have. The only thing I'm missing is a deeper control about what
parts of the token end up in the tokens text, but maybe I've just not
found that yet.

Martin

From ric.klaren at gmail.com  Wed Feb  8 13:32:11 2006
From: ric.klaren at gmail.com (Ric Klaren)
Date: Wed Feb  8 13:32:17 2006
Subject: [antlr-interest] Parsing multiple messages using one parser
In-Reply-To: <A8ED9BF7-757D-43C5-956F-A1932EB7451F@cs.usfca.edu>
References: <200602071514.36112.jens.stegemann@gmx.de>
	<bc607a4e0602070633o2220581td2d270b90d98c0e6@mail.gmail.com>
	<200602081506.57247.jens.stegemann@gmx.de>
	<bc607a4e0602080700k2248ef60p353f111f0481cd93@mail.gmail.com>
	<A8ED9BF7-757D-43C5-956F-A1932EB7451F@cs.usfca.edu>
Message-ID: <bc607a4e0602081332s6016a5d0tae05a932586561df@mail.gmail.com>

On 2/8/06, Terence Parr <parrt@cs.usfca.edu> wrote:
> On Feb 8, 2006, at 7:00 AM, Ric Klaren wrote:
> > It looks like the search on antlr.org does not cover the mailing list
> > anymore? Anyway I tried finding the post again via:
>
> Does for me...I just did a search.

I don't seem to find the same things as the gmane thing though :( (at
least when I use that 'search bar in the middle' that redirects to
google. Actually a few tries now don't turn up any results of the
webserver on port 8080.

Cheers,

Ric
From ric.klaren at gmail.com  Wed Feb  8 13:37:35 2006
From: ric.klaren at gmail.com (Ric Klaren)
Date: Wed Feb  8 13:37:39 2006
Subject: [antlr-interest] Parsing multiple messages using one parser
In-Reply-To: <bc607a4e0602080700k2248ef60p353f111f0481cd93@mail.gmail.com>
References: <200602071514.36112.jens.stegemann@gmx.de>
	<bc607a4e0602070633o2220581td2d270b90d98c0e6@mail.gmail.com>
	<200602081506.57247.jens.stegemann@gmx.de>
	<bc607a4e0602080700k2248ef60p353f111f0481cd93@mail.gmail.com>
Message-ID: <bc607a4e0602081337x3c5ff51ev5a97014118728f95@mail.gmail.com>

On 2/8/06, Ric Klaren <ric.klaren@gmail.com> wrote:
> > Would you please be so kind to send some to me or post it on the mailing-list?
> > This would be a great help!
>
> I'll dig up the code at home and repost.

Here it is:

One time setup:

		// if we don't have a file we use stdin (cin)
		lexer = new MyLexer(std::cin);
		my_nodes_factory = new antlr::ASTFactory("MyAST", MyAST::factory );

		// Create a parser that reads from the scanner
		parser = new MyParser( *lexer );

		// Initialize it with factory and setup the factory and other trivia
		parser->setASTNodeFactory( my_nodes_factory );
		parser->initializeASTFactory( *my_nodes_factory );
		parser->setFilename("stdin");

Per file:
		// get our hands on the input state...
		antlr::LexerSharedInputState lex_input = lexer->getInputState();

		// and reinitialize it with the new file
		lex_input->initialize(file, filename);

		// and reset parser (antlr) internal state
		parser->getInputState()->reset();
		parser->setFilename(filename);

		// start parsing at the 'start' rule
		parser->start();

This code is from the 2.7.4 version. Might need some minor tweaking.

Cheers,

Ric
From jens.bartelheimer at gmx.de  Wed Feb  8 13:43:38 2006
From: jens.bartelheimer at gmx.de (Jens Bartelheimer)
Date: Wed Feb  8 13:43:44 2006
Subject: [antlr-interest] Problem with *
In-Reply-To: <43E7CC29.2000808@gmx.de>
References: <43E7CC29.2000808@gmx.de>
Message-ID: <43EA660A.5070305@gmx.de>

Hi again,

has nobody a solution for my problem?

I have recognized that the same problem exist if I define only one 
single token in my rule.

Jens

Jens Bartelheimer wrote:
> Hi,
>
> I am new to antlr and I have a problem with the Star *.
>
> If I only parse a String with a star the first rule recognize the 
> star, the second with a token not.
>
> Why?
>
> 1st:
> ----
>
> getTest
> {
> }
>    :   "*"
>        {
>    System.out.println("Star gefunden");
>        }
>    ;
>
>
> 2nd:
> getTest
> {
> }
>    :   STAR
>        {
>    System.out.println("Star found");
>        }
>    ;
>
> Lexer:
> STAR: '*';
>
> raises: line 1:1: expecting STAR, found '*'
>
>
>
From parrt at cs.usfca.edu  Wed Feb  8 14:23:33 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Wed Feb  8 14:23:36 2006
Subject: [antlr-interest] Parsing multiple messages using one parser
In-Reply-To: <bc607a4e0602081332s6016a5d0tae05a932586561df@mail.gmail.com>
References: <200602071514.36112.jens.stegemann@gmx.de>
	<bc607a4e0602070633o2220581td2d270b90d98c0e6@mail.gmail.com>
	<200602081506.57247.jens.stegemann@gmx.de>
	<bc607a4e0602080700k2248ef60p353f111f0481cd93@mail.gmail.com>
	<A8ED9BF7-757D-43C5-956F-A1932EB7451F@cs.usfca.edu>
	<bc607a4e0602081332s6016a5d0tae05a932586561df@mail.gmail.com>
Message-ID: <EB69B5DC-9563-41F3-9064-099BDD83F6B0@cs.usfca.edu>


On Feb 8, 2006, at 1:32 PM, Ric Klaren wrote:

> On 2/8/06, Terence Parr <parrt@cs.usfca.edu> wrote:
>> On Feb 8, 2006, at 7:00 AM, Ric Klaren wrote:
>>> It looks like the search on antlr.org does not cover the mailing  
>>> list
>>> anymore? Anyway I tried finding the post again via:
>>
>> Does for me...I just did a search.
>
> I don't seem to find the same things as the gmane thing though :( (at
> least when I use that 'search bar in the middle' that redirects to
> google. Actually a few tries now don't turn up any results of the
> webserver on port 8080.

I tried predicate I think down 2 pages then.

Ter
From parrt at cs.usfca.edu  Wed Feb  8 14:25:35 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Wed Feb  8 14:25:39 2006
Subject: [antlr-interest] Zero based  $i$ index in StringTemplate 
In-Reply-To: <12561.195.169.118.236.1138806051.squirrel@webmail.xs4all.nl>
References: <12561.195.169.118.236.1138806051.squirrel@webmail.xs4all.nl>
Message-ID: <7C94B3F7-917E-477F-A64A-10F1B1EB6808@cs.usfca.edu>


On Feb 1, 2006, at 7:00 AM, Gevik Babakhani wrote:

> I was wondering why we are using 1 based index in
> ASTExpr.java, function applyListOfAlternatingTemplates at
> argumentContext.put(DEFAULT_INDEX_VARIABLE_NAME, new Integer(i+1));
>
> isn't 0 based index "new Integer(i)" better?

I was thinking of adding i0 as well as i.  1 is what humans expect.   
0 is what computers need but since you can't index in ST no need for  
0 based often. ;)

Ter

From seclib at seclib.com  Wed Feb  8 14:26:35 2006
From: seclib at seclib.com (Xue Yong Zhi)
Date: Wed Feb  8 14:26:54 2006
Subject: [antlr-interest] Re: Recommendation for Lexer
In-Reply-To: <1139422677.6072.36.camel@localhost.localdomain>
References: <1139408246.6072.24.camel@localhost.localdomain>	<dsdaie$d9j$1@sea.gmane.org>
	<1139422677.6072.36.camel@localhost.localdomain>
Message-ID: <dsdr6p$isn$1@sea.gmane.org>



> Plus it brings native support for the issues I have. 

Can you tell me more about this? I can not see how it helps to maintain 
states.

-- 
Xue Yong Zhi
http://seclib.blogspot.com

From mail at martin-probst.com  Wed Feb  8 14:40:40 2006
From: mail at martin-probst.com (Martin Probst)
Date: Wed Feb  8 14:40:47 2006
Subject: [antlr-interest] Problem with *
In-Reply-To: <43EA660A.5070305@gmx.de>
References: <43E7CC29.2000808@gmx.de>  <43EA660A.5070305@gmx.de>
Message-ID: <1139438440.6131.3.camel@localhost.localdomain>

Hi,

maybe you could post your whole grammar? That might help. You can also
get debug trace from the lexer if you run antlr with the option
-debugLexer (if I remember correctly). Sometimes reading the generated
code or tracing through it can help a lot (you have to look at the
lexer).

A possible cause would be that the '*' character is matched by a
different rule in your Lexer (which would explain why writing it
literally in the parser works). Make sure no other Lexer rule can match
a single star. Do you get any non-determinism warnings from ANTLR?

Martin

Am Mittwoch, den 08.02.2006, 22:43 +0100 schrieb Jens Bartelheimer:
> Hi again,
> 
> has nobody a solution for my problem?
> 
> I have recognized that the same problem exist if I define only one 
> single token in my rule.
> 
> Jens
> 
> Jens Bartelheimer wrote:
> > Hi,
> >
> > I am new to antlr and I have a problem with the Star *.
> >
> > If I only parse a String with a star the first rule recognize the 
> > star, the second with a token not.
> >
> > Why?
> >
> > 1st:
> > ----
> >
> > getTest
> > {
> > }
> >    :   "*"
> >        {
> >    System.out.println("Star gefunden");
> >        }
> >    ;
> >
> >
> > 2nd:
> > getTest
> > {
> > }
> >    :   STAR
> >        {
> >    System.out.println("Star found");
> >        }
> >    ;
> >
> > Lexer:
> > STAR: '*';
> >
> > raises: line 1:1: expecting STAR, found '*'
> >
> >
> >
> 

From mail at martin-probst.com  Wed Feb  8 14:47:19 2006
From: mail at martin-probst.com (Martin Probst)
Date: Wed Feb  8 14:47:24 2006
Subject: [antlr-interest] Re: Recommendation for Lexer
In-Reply-To: <dsdr6p$isn$1@sea.gmane.org>
References: <1139408246.6072.24.camel@localhost.localdomain>
	<dsdaie$d9j$1@sea.gmane.org>
	<1139422677.6072.36.camel@localhost.localdomain>
	<dsdr6p$isn$1@sea.gmane.org>
Message-ID: <1139438839.6131.10.camel@localhost.localdomain>

> > Plus it brings native support for the issues I have. 
> 
> Can you tell me more about this? I can not see how it helps to maintain 
> states.

Well, you have a directive where you can enter normal states and
explicit states, every rule can be preceded by a list of states in which
it matches, or none (which means match in any except for explicit
states). Also the lexer generates DFAs, so you don't get non-determinism
problems because of tokens that only differ in suffixes (like ANTLR3,
but that's just not ready...). 

So for this it provides any support I can think of, and the explicit/non
explicit thing is very useful if you have some language parts that are
whitespace significant. It's a little less convenient than ANTLR because
it doesn't impose any token model on you, so it also doesn't
automatically create a table of token types and you have to set types
manually in Java code. However, I can live with that in return for
states.

Martin

From parrt at cs.usfca.edu  Wed Feb  8 14:56:23 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Wed Feb  8 14:56:26 2006
Subject: [antlr-interest] generating cyclic state machines in Java
In-Reply-To: <20060205040143.90128.qmail@web54503.mail.yahoo.com>
References: <20060205040143.90128.qmail@web54503.mail.yahoo.com>
Message-ID: <CE1ED11A-57D4-4B50-8C18-CC2BBC61E2FC@cs.usfca.edu>

Hi Jeff,

Well, I'm not sure I fully understand what you have, but while  
sitting in the beautiful California sun today I thought about how I  
would redo them.  Perhaps this is similar to what you would suggest.

First, my goals:

1. don't create a lot of classes
2. don't create a lot of instances
3. avoid method calls per character just to transition
4. be as small as possible

I thought about just making a huge switch on state number that jumped  
to a CASE:

switch ( s ) {
   case 0 : ...
   case 1 : ...
   ...
}

But, with say 500 states I'm not sure java would do this efficiently  
and it would limit the size of our DFAs due to java method size  
limits.  For states that have semantic predicates are truly  
complicated transitions, we could do this.

As an optimization, I would like something tight like this:

while ( s != accept state ) {
   s = states[s][input.LA(1)];
   if ( s==-1 ) error;
}
return predictedAlt[s];

which works well enough for 8 bits. Actually when the range from low  
to high of the edge labels is > threshold then you'd decide the array  
would be too big and you resort to another case in your switch.  So  
for single char labels very high into the unicode range, you could  
still use this approach.  You need min/max arrays too:

while ( s != accept state ) {
   c = input.LA(1);
   if ( c>max[s] ) error;
   s = states[s][c-min[s]];
   if ( s==-1 ) error;
}
return predictedAlt[s];

For most states then, you could do this fast scheme and then resort  
to a big switch for the others or even use methods for s0(), s32(),  
etc.. and jump to them to reduce the size of the method containing  
the switch.

Do you see any problems with this?

One could be defining the stuff; java does what...ok, web says I can  
do this:

int dfa1_min[] = {...};
int dfa1_max[] = {...};
...
int dfa1_states[][] = {
	{ 0,0,0,3,0,2,0,... }, // state 1 transitions where on char x?
	{ ... },			// state 2
	...
};

Java creates an array of arrays, which is a lot of objects and  
hopefully it doesn't wipe to 0 first and then add these default  
values. :(

Anybody have experience with this in Java?

Ter
From jbarnesweb at yahoo.com  Wed Feb  8 19:59:43 2006
From: jbarnesweb at yahoo.com (Jeff Barnes)
Date: Wed Feb  8 19:59:45 2006
Subject: [antlr-interest] generating cyclic state machines in Java
In-Reply-To: <CE1ED11A-57D4-4B50-8C18-CC2BBC61E2FC@cs.usfca.edu>
Message-ID: <20060209035943.92109.qmail@web54506.mail.yahoo.com>

Hi Ter,

> 
> Java creates an array of arrays, which is a lot of
> objects and  
> hopefully it doesn't wipe to 0 first and then add
> these default  
> values. :(
> 
> Anybody have experience with this in Java?
> 
> Ter
> 

Is this what you're asking?

public class Test
{
	public static void main(String[] args)
	{
		char[] s = new char[10];
		for (int i = 0; i < s.length; i++)
		{
			System.out.println((int)s[i]);
		}
	}
}

C:\dev\playground>javac Test.java

C:\dev\playground>java Test
0
0
0
0
0
0
0
0
0
0

I believe you are going to find that the processor
cost of creating an array is roughly equal to the cost
of creating a metamodel... and a lot more work.

I'm putting together a rough draft of what I had in
mind. I'll post it by end of week or so, if that's ok.
Just something for you to consider.

We actually got some sun here in Seattle this week.
'Got distracted by it.

;-)

Regards,
Jeff

From open.zone at virgin.net  Wed Feb  8 22:56:03 2006
From: open.zone at virgin.net (Micheal J)
Date: Wed Feb  8 22:39:37 2006
Subject: [antlr-interest] Re: Recommendation for Lexer
In-Reply-To: <1139422677.6072.36.camel@localhost.localdomain>
Message-ID: <004e01c62d45$e6107770$6402a8c0@hercules>

> JFlex looks good at the moment. It doesn't impose any class 
> inheritance on you and the generated lexer is completely 
> standalone, so it should be easy to integrate with ANTLR. 

Have a look at our KSCParse sample on the ANTLR site. It's for C# targets
but includes a CsFlex (Jflex for C#) lexer that demonstrates ANTLR
integration [with Jflex-style lexers]. 

Although you don't *need* it, Kunle also added an ANTLR mode to CsFlex
(patch code in the CsFlex site on SourceForge) that you could port to Jflex
[and submit to the Jflex project if you desire] to make ANTLR integration
even easier.

> Plus it brings native support for the issues I have. The only 
> thing I'm missing is a deeper control about what parts of the 
> token end up in the tokens text, but maybe I've just not 
> found that yet.

The sample should help in that regard too. You get to decide what is in the
tokens you return (or perhaps I haven't quite appreciated the complexity of
your lexer).

Cheers,

Micheal

From gt54-antlr at cyconix.com  Thu Feb  9 01:07:58 2006
From: gt54-antlr at cyconix.com (Paul Johnson)
Date: Thu Feb  9 01:08:06 2006
Subject: [antlr-interest] Re: Recommendation for Lexer
In-Reply-To: <1139438839.6131.10.camel@localhost.localdomain>
References: <1139408246.6072.24.camel@localhost.localdomain>	<dsdaie$d9j$1@sea.gmane.org>	<1139422677.6072.36.camel@localhost.localdomain>	<dsdr6p$isn$1@sea.gmane.org>
	<1139438839.6131.10.camel@localhost.localdomain>
Message-ID: <43EB066E.3010600@cyconix.com>

Martin Probst wrote:
>>>Plus it brings native support for the issues I have. 
>>
>>Can you tell me more about this? I can not see how it helps to maintain 
>>states.
> 
> 
> Well, you have a directive where you can enter normal states and
> explicit states, every rule can be preceded by a list of states in which
> it matches, or none (which means match in any except for explicit
> states). Also the lexer generates DFAs, so you don't get non-determinism
> problems because of tokens that only differ in suffixes (like ANTLR3,
> but that's just not ready...). 

[f]lex also does this but, in my experience, it's not generally useful 
if the parser can't communicate with the lexer and push back unnecessary 
tokens. For instance, if you're parsing with yacc/bison, then yacc 
already has one read-ahead token by the time you realise that you need 
to change states in the lexer, and it's too late. Have you got a fix for 
this? Or do you do all the necessary state-change logic in the lexer itself?

Paul

From mail at martin-probst.com  Thu Feb  9 02:50:25 2006
From: mail at martin-probst.com (Martin Probst)
Date: Thu Feb  9 02:50:38 2006
Subject: [antlr-interest] Re: Recommendation for Lexer
In-Reply-To: <43EB066E.3010600@cyconix.com>
References: <1139408246.6072.24.camel@localhost.localdomain>
	<dsdaie$d9j$1@sea.gmane.org>
	<1139422677.6072.36.camel@localhost.localdomain>
	<dsdr6p$isn$1@sea.gmane.org>
	<1139438839.6131.10.camel@localhost.localdomain>
	<43EB066E.3010600@cyconix.com>
Message-ID: <1139482225.8062.8.camel@localhost.localdomain>

> [f]lex also does this but, in my experience, it's not generally useful 
> if the parser can't communicate with the lexer and push back unnecessary 
> tokens. For instance, if you're parsing with yacc/bison, then yacc 
> already has one read-ahead token by the time you realise that you need 
> to change states in the lexer, and it's too late. Have you got a fix for 
> this? Or do you do all the necessary state-change logic in the lexer itself?

I'm doing all the state stuff in the Lexer, exactly because of that.
I've made bad experiences with setting Lexer state from the Parser, it
just makes the code messy and hard to debug. The major pro of JFlex here
is that it manages the states for you and includes that
explicit/non-explicit states thing. It's all possible to achieve in
ANTLR, but it gets really ugly (e.g. one big NEXT_TOKEN rule with a
predicates for each token, set types etc.).

Martin

From mail at martin-probst.com  Thu Feb  9 04:21:36 2006
From: mail at martin-probst.com (Martin Probst)
Date: Thu Feb  9 04:21:43 2006
Subject: [antlr-interest] Re: Recommendation for Lexer
In-Reply-To: <004e01c62d45$e6107770$6402a8c0@hercules>
References: <004e01c62d45$e6107770$6402a8c0@hercules>
Message-ID: <1139487697.8062.15.camel@localhost.localdomain>

On Thu, 2006-02-09 at 06:56 +0000, Micheal J wrote:
> > JFlex looks good at the moment. It doesn't impose any class 
> > inheritance on you and the generated lexer is completely 
> > standalone, so it should be easy to integrate with ANTLR. 
> 
> Have a look at our KSCParse sample on the ANTLR site. It's for C# targets
> but includes a CsFlex (Jflex for C#) lexer that demonstrates ANTLR
> integration [with Jflex-style lexers]. 
> 
> Although you don't *need* it, Kunle also added an ANTLR mode to CsFlex
> (patch code in the CsFlex site on SourceForge) that you could port to Jflex
> [and submit to the Jflex project if you desire] to make ANTLR integration
> even easier.

I actually get along with it quite well currently, I was just describing
to Xue Yong Zhi how JFlex solves some of my problems better than ANTLR
lexers.

> > Plus it brings native support for the issues I have. The only 
> > thing I'm missing is a deeper control about what parts of the 
> > token end up in the tokens text, but maybe I've just not 
> > found that yet.
> 
> The sample should help in that regard too. You get to decide what is in the
> tokens you return (or perhaps I haven't quite appreciated the complexity of
> your lexer).

A typical rule might look like this:

<STATEX> "foo" (("." {Digits}) | 
                ({Digits} ("." [0-9]*)?)) [eE] [+-]? {Digits}
         { setState(STATEY); return token(FOO); }

Now my problem is how to access certain parts of the match without
re-parsing the string in the Java code part (e.g. ideally I'd like no
indexOf(), substring() stuff but rather something like $1 or \1 to get
the capturing groups).

Martin

From kalle at snigel.net  Thu Feb  9 04:56:26 2006
From: kalle at snigel.net (karl wettin)
Date: Thu Feb  9 04:54:45 2006
Subject: [antlr-interest] more newbie help required
In-Reply-To: <99CD2E17-1813-46CC-B358-49987ED03D53@snigel.net>
References: <921F860C-7105-48FA-9367-9A42322A0482@snigel.net>
	<99CD2E17-1813-46CC-B358-49987ED03D53@snigel.net>
Message-ID: <EAD6B0E1-FFCF-4020-8D7E-1B41FC9B465A@snigel.net>

So I traced the feature a bit longer.

In essense, why does this return the text:
  	
	(		
		options { greedy=false; } :
		show:SOME_EXPRESSION
		{System.out.println(show);}
	)+

and why does this return null:
	show:(		
		options { greedy=false; } :
		SOME_EXPRESSION
	)+
	{System.out.println(show);}

?

-- 
karl


From kweinert at gmail.com  Thu Feb  9 05:32:01 2006
From: kweinert at gmail.com (Kenneth D. Weinert)
Date: Thu Feb  9 05:32:03 2006
Subject: [antlr-interest] Mention of antlr in Linux news
Message-ID: <36052.24.8.140.228.1139491921.squirrel@webmail.quarter-flash.com>


http://www.linux-watch.com/news/NS6361290460.html

-- 
Ken Weinert  Quarterflash Design Group  http://quarter-flash.com

For systems, the analogue of a face-lift is to add to the control
graph an edge that creates a cycle, not just an additional node. 
	-- Alan J. Perlis


From rhill03 at eds.com  Thu Feb  9 06:11:18 2006
From: rhill03 at eds.com (Hill, Robert)
Date: Thu Feb  9 06:12:09 2006
Subject: [antlr-interest] Mention of antlr in Linux news
Message-ID: <2E909902FD3A03419E3A905908AE3DD40196F0B0@UKNSM201.emea.corp.eds.com>


I guess they didn't see
http://www.koders.com then.

For those who can't be bothered visiting , quote from the page

"koders.com - Searching 225,816,744 lines of code."
Sounds like a source code search engine to me ;)


/2ob


--
Rob Hill
EDS - Hallamshire Business Park
F1E/087
Sheffield	
T:	+44 (0) 114 291 1928
M:	+44 (0) 791 732 1227
E:	rhill03@eds.com

 

>-----Original Message-----
>From: antlr-interest-bounces@antlr.org 
>[mailto:antlr-interest-bounces@antlr.org] On Behalf Of Kenneth 
>D. Weinert
>Sent: 09 February 2006 13:32
>To: antlr-interest@antlr.org
>Subject: [antlr-interest] Mention of antlr in Linux news
>
>
>http://www.linux-watch.com/news/NS6361290460.html
>
>--
>Ken Weinert  Quarterflash Design Group  http://quarter-flash.com
>
>For systems, the analogue of a face-lift is to add to the 
>control graph an edge that creates a cycle, not just an 
>additional node. 
>	-- Alan J. Perlis
>
>
>
From y0016408 at yahoo.de  Thu Feb  9 07:36:23 2006
From: y0016408 at yahoo.de (Sergej Bogomolow)
Date: Thu Feb  9 07:36:26 2006
Subject: [antlr-interest] DEBUG_ANALYZER
Message-ID: <20060209153623.477.qmail@web25705.mail.ukl.yahoo.com>

Hi @all,

I'm going to set the attribute DEBUG_ANALYZER in the
class antlr.LLkAnalyzer on true, due to I want see
additional messages, when launching antlr from my
source code. I know that I should set the attribute
analyzerDebug in the class Grammar on true to achieve
this aim, but I don't know how to do this in the class
which invoke the method doEverything of the class
antlr.Tool.

Thanks,
Sergej


	

	
		
___________________________________________________________ 
Telefonate ohne weitere Kosten vom PC zum PC: http://messenger.yahoo.de
From open.zone at virgin.net  Thu Feb  9 12:54:20 2006
From: open.zone at virgin.net (Micheal J)
Date: Thu Feb  9 12:38:21 2006
Subject: [antlr-interest] Re: Recommendation for Lexer
In-Reply-To: <1139487697.8062.15.camel@localhost.localdomain>
Message-ID: <000201c62dbb$01e90320$6402a8c0@hercules>

> A typical rule might look like this:
> 
> <STATEX> "foo" (("." {Digits}) | 
>                 ({Digits} ("." [0-9]*)?)) [eE] [+-]? {Digits}
>          { setState(STATEY); return token(FOO); }
> 
> Now my problem is how to access certain parts of the match 
> without re-parsing the string in the Java code part (e.g. 
> ideally I'd like no indexOf(), substring() stuff but rather 
> something like $1 or \1 to get the capturing groups).

No general solution but, you can use lexer states to extract a contiguous
substring (much like we do to remove the '@' from verbatim strings and
identifiers). Not that you want any more states...

Micheal

From gudnabrsam at yahoo.com  Thu Feb  9 12:56:49 2006
From: gudnabrsam at yahoo.com (Matt Benson)
Date: Thu Feb  9 12:56:52 2006
Subject: [antlr-interest] generating cyclic state machines in Java
In-Reply-To: <CE1ED11A-57D4-4B50-8C18-CC2BBC61E2FC@cs.usfca.edu>
Message-ID: <20060209205649.47003.qmail@web30904.mail.mud.yahoo.com>

Not much to add here, and am interested to see what
else Jeff says, but I seriously doubt Java would wipe
the contents of arrays for which initial values are
provided... working on the assumption that over the
ten years of Java's evolution somebody smarter than I
has touched each of the major JREs...

-Matt

--- Terence Parr <parrt@cs.usfca.edu> wrote:

> Hi Jeff,
> 
> Well, I'm not sure I fully understand what you have,
> but while  
> sitting in the beautiful California sun today I
> thought about how I  
> would redo them.  Perhaps this is similar to what
> you would suggest.
> 
> First, my goals:
> 
> 1. don't create a lot of classes
> 2. don't create a lot of instances
> 3. avoid method calls per character just to
> transition
> 4. be as small as possible
> 
> I thought about just making a huge switch on state
> number that jumped  
> to a CASE:
> 
> switch ( s ) {
>    case 0 : ...
>    case 1 : ...
>    ...
> }
> 
> But, with say 500 states I'm not sure java would do
> this efficiently  
> and it would limit the size of our DFAs due to java
> method size  
> limits.  For states that have semantic predicates
> are truly  
> complicated transitions, we could do this.
> 
> As an optimization, I would like something tight
> like this:
> 
> while ( s != accept state ) {
>    s = states[s][input.LA(1)];
>    if ( s==-1 ) error;
> }
> return predictedAlt[s];
> 
> which works well enough for 8 bits. Actually when
> the range from low  
> to high of the edge labels is > threshold then you'd
> decide the array  
> would be too big and you resort to another case in
> your switch.  So  
> for single char labels very high into the unicode
> range, you could  
> still use this approach.  You need min/max arrays
> too:
> 
> while ( s != accept state ) {
>    c = input.LA(1);
>    if ( c>max[s] ) error;
>    s = states[s][c-min[s]];
>    if ( s==-1 ) error;
> }
> return predictedAlt[s];
> 
> For most states then, you could do this fast scheme
> and then resort  
> to a big switch for the others or even use methods
> for s0(), s32(),  
> etc.. and jump to them to reduce the size of the
> method containing  
> the switch.
> 
> Do you see any problems with this?
> 
> One could be defining the stuff; java does
> what...ok, web says I can  
> do this:
> 
> int dfa1_min[] = {...};
> int dfa1_max[] = {...};
> ...
> int dfa1_states[][] = {
> 	{ 0,0,0,3,0,2,0,... }, // state 1 transitions where
> on char x?
> 	{ ... },			// state 2
> 	...
> };
> 
> Java creates an array of arrays, which is a lot of
> objects and  
> hopefully it doesn't wipe to 0 first and then add
> these default  
> values. :(
> 
> Anybody have experience with this in Java?
> 
> Ter
> 


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 
From parrt at cs.usfca.edu  Thu Feb  9 13:29:01 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Thu Feb  9 13:29:03 2006
Subject: [antlr-dev] Re: [antlr-interest] generating cyclic state machines
	in Java
In-Reply-To: <20060209205649.47003.qmail@web30904.mail.mud.yahoo.com>
References: <20060209205649.47003.qmail@web30904.mail.mud.yahoo.com>
Message-ID: <7F10BE5B-BEE8-46C0-B74C-01A8DB50EB0C@cs.usfca.edu>


On Feb 9, 2006, at 12:56 PM, Matt Benson wrote:

> Not much to add here, and am interested to see what
> else Jeff says, but I seriously doubt Java would wipe
> the contents of arrays for which initial values are
> provided... working on the assumption that over the
> ten years of Java's evolution somebody smarter than I
> has touched each of the major JREs...

I hope!  I am also going to probably allocate one big 1D array and  
then simulate the 2D array rather than let it create n arrays for n  
DFA states.  Slows down GC etc...

Ter
From mail at martin-probst.com  Thu Feb  9 15:00:03 2006
From: mail at martin-probst.com (Martin Probst)
Date: Thu Feb  9 15:00:20 2006
Subject: [antlr-dev] Re: [antlr-interest] generating cyclic state
	machines in Java
In-Reply-To: <7F10BE5B-BEE8-46C0-B74C-01A8DB50EB0C@cs.usfca.edu>
References: <20060209205649.47003.qmail@web30904.mail.mud.yahoo.com>
	<7F10BE5B-BEE8-46C0-B74C-01A8DB50EB0C@cs.usfca.edu>
Message-ID: <1139526003.22707.1.camel@localhost.localdomain>

> I hope!  I am also going to probably allocate one big 1D array and  
> then simulate the 2D array rather than let it create n arrays for n  
> DFA states.  Slows down GC etc...

The two rules of optimisation:
1. Don't do it
2. (for experts) Don't do it yet

Why not get a working system and benchmark it first? In my experience
the JIT & friends always behave different from what you'd expect ...

Martin

From AdamB at datacom.co.nz  Thu Feb  9 19:07:15 2006
From: AdamB at datacom.co.nz (Adam Bishop (DSLWN))
Date: Thu Feb  9 19:07:21 2006
Subject: [antlr-interest] Lexer Bug?
Message-ID: <46562C5EECFA8C47AADDF029EE11D73D0270A7F0@dnzwgex1.datacom.co.nz>

If I define a lexer rule:

NOT_EQUALS : "<>" | "!=" ;

 

It matches the string "<="

 

The lexer nextToken method shows:

 

else if ((LA(1)=='!'||LA(1)=='<') && (LA(2)=='='||LA(2)=='>') && (true)
&& (true) && (true) && (true) && (true) && (true)) {

 

which is flawed.

 

I have solved my problem for this by moving the definition of
LESS_THAN_OR_EQUALS above the definition of NOT_EQUALS.

 

Is this a bug, or am I doing something flawed?

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060210/424fa9c8/attachment.html
From allex at all-x.net  Thu Feb  9 23:08:50 2006
From: allex at all-x.net (Alexey Demakov)
Date: Thu Feb  9 23:08:55 2006
Subject: [antlr-interest] Lexer Bug?
References: <46562C5EECFA8C47AADDF029EE11D73D0270A7F0@dnzwgex1.datacom.co.nz>
Message-ID: <008601c62e10$d7f04500$0116a8c0@allex>

Hi Adam,

It's because ANTLR uses so-called approximate lookahead
http://www.antlr.org/doc/glossary.html#Linear_approximate_lookahead
instead of full LL(k) lookahead.

If you define each token in its own protected lexer rule, it will solve the problem
for any order of rules (assuming k >= 2):

protected LG : "<>" ;

protected NE : "!=" ;

NOT_EQUALS : LG | NE ;

LESS_THAN_OR_EQUALS : "<=" ;

Regards,
Alexey
---
Alexey Demakov
TreeDL: Tree Description Language: http://treedl.sourceforge.net
RedVerst Group: http://www.unitesk.com
 
  ----- Original Message ----- 
  From: Adam Bishop (DSLWN) 
  To: antlr-interest@antlr.org 
  Sent: Friday, February 10, 2006 6:07 AM
  Subject: [antlr-interest] Lexer Bug?


  If I define a lexer rule:

  NOT_EQUALS : "<>" | "!=" ;

   

  It matches the string "<="

   

  The lexer nextToken method shows:

   

  else if ((LA(1)=='!'||LA(1)=='<') && (LA(2)=='='||LA(2)=='>') && (true) && (true) && (true) && (true) && (true) && (true)) {

   

  which is flawed.

   

  I have solved my problem for this by moving the definition of LESS_THAN_OR_EQUALS above the definition of NOT_EQUALS.

   

  Is this a bug, or am I doing something flawed?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060210/ec2f2226/attachment.html
From Ulrich.Frank at dlr.de  Fri Feb 10 01:04:50 2006
From: Ulrich.Frank at dlr.de (Ulrich Frank)
Date: Fri Feb 10 01:04:52 2006
Subject: [antlr-interest] semantic differentiation
Message-ID: <3C01A2DF-C6F4-44B0-A166-EB9F30F045FE@dlr.de>

Hello,
I've a new question: when I define something like

IDENT :  ( 'a'..'z' | '0'..'9' )*

in my lexer and then I have rules in my grammar like


{
         private String first = "first";
	public String getFirst() { return first; }
}
query  : { first=$FIRST.toString(); } "select" query2 ;
query2 : { first=$FIRST.toString(); } (IDENT)? query3 ;
query3 : { first=$FIRST.toString(); } "from" query4 ;
query4 : { first=$FIRST.toString(); } IDENT query5 ;
query5 : { first=$FIRST.toString(); } ("where" query6)? ;
query6 : { first=$FIRST.toString(); } IDENT query7 ;
query7 : { first=$FIRST.toString(); } ("<" | "<=" | ">" | ">=") query8 ;
query8 : { first=$FIRST.toString(); } IDENT ;


The problem I have is that I want to distinguish the IDENT in query2  
and the IDENT in query4. I have to do something in the parser, but  
what (semantic action, but how)?? Any idea? I need this because when  
I analyze $FIRST in another java class, I have to know if the IDENT I  
got from getFirst() is the IDENT from rule query2 or the IDENT from  
rule query4.

Greets, Uli
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060210/ff8d4a15/attachment-0001.html
From ewbank at gmail.com  Fri Feb 10 02:03:45 2006
From: ewbank at gmail.com (Bryan Ewbank)
Date: Fri Feb 10 02:03:47 2006
Subject: [antlr-interest] semantic differentiation
In-Reply-To: <3C01A2DF-C6F4-44B0-A166-EB9F30F045FE@dlr.de>
References: <3C01A2DF-C6F4-44B0-A166-EB9F30F045FE@dlr.de>
Message-ID: <dd3a065f0602100203y499a016eh657c9d21952fb496@mail.gmail.com>

Is it sufficient simply to set another variable (type_first) to
indicate which place generated the value of first?

Also, <query2> and <query3> (for example) look suspicious because
you've named this variable "first".  After processing, the variable
will contain the /last/ value encountered.

On 2/10/06, Ulrich Frank <Ulrich.Frank@dlr.de> wrote:
>
> query  : { first=$FIRST.toString(); } "select" query2 ;
> query2 : { first=$FIRST.toString(); } (IDENT)? query3 ;
> query3 : { first=$FIRST.toString(); } "from" query4 ;
> query4 : { first=$FIRST.toString(); } IDENT query5 ;
> query5 : { first=$FIRST.toString(); } ("where" query6)? ;
> query6 : { first=$FIRST.toString(); } IDENT query7 ;
> query7 : { first=$FIRST.toString(); } ("<" | "<=" | ">" | ">=") query8 ;
> query8 : { first=$FIRST.toString(); } IDENT ;
>
> The problem I have is that I want to distinguish the IDENT in query2 and the
> IDENT in query4. I have to do something in the parser, but what (semantic
> action, but how)?? Any idea? I need this because when I analyze $FIRST in
> another java class, I have to know if the IDENT I got from getFirst() is the
> IDENT from rule query2 or the IDENT from rule query4.
From open.zone at virgin.net  Fri Feb 10 02:50:37 2006
From: open.zone at virgin.net (Micheal J)
Date: Fri Feb 10 02:34:14 2006
Subject: [antlr-interest] Updated C# parser grammar for kcsparse and the C#
	csharp_v1 example in ANTLR 2.7.6+
Message-ID: <001101c62e2f$d836f9e0$6502a8c0@hercules>

Updated grammar file includes a fix for parsing nested #region and #if
preprocessor directive blocks.

Thanks to  Paul Foster for reporting the issue (and supplying test cases)
and, Kunle for providing the fix.

Get it here: http://www.antlr.org/share/1139567485993/CSharpParser.g


Cheers,

Micheal


---------------------------------------------------------
"Java isn't platform independent; it is a platform. 
 Like Windows, it is a proprietary commercial platform. "
                                      - Bjarne Stroustrup
 

From Ulrich.Frank at dlr.de  Fri Feb 10 02:35:20 2006
From: Ulrich.Frank at dlr.de (Ulrich Frank)
Date: Fri Feb 10 02:35:25 2006
Subject: [antlr-interest] semantic differentiation
Message-ID: <8A441715-36BF-4C70-B227-391B78C8AC4D@dlr.de>

The variable is called first because it represents the $FIRST-set.  
And therefore it is correct, that it contains the last value  
encountered - explicit. I need this construct because of that: the  
input is a string, f.e. "select from ttt where sss" and then I push  
CTRL-space. Then, a popup goes up and shows me all posibilities which  
are correct at this position of the grammar. In the example above:  
<=, <, >=, >. I get these posibilities by looking at $FIRST and  
therefore $FIRST should always be saved in the variable first because  
then I only have to look what first consists of and can show it in  
the popup.

The problem I have now is, that IDENT after select and IDENT after  
from cannot be differentiated, so the user can't decide, which should  
come next. In the former one there should be an object (OQL not SQL)  
in the latter one an attribute of this object.

Any ideas??



-----

Is it sufficient simply to set another variable (type_first) to
indicate which place generated the value of first?

Also, <query2> and <query3> (for example) look suspicious because
you've named this variable "first".  After processing, the variable
will contain the /last/ value encountered.

On 2/10/06, Ulrich Frank <Ulrich.Frank at dlr.de> wrote:
 >
 > query  : { first=$FIRST.toString(); } "select" query2 ;
 > query2 : { first=$FIRST.toString(); } (IDENT)? query3 ;
 > query3 : { first=$FIRST.toString(); } "from" query4 ;
 > query4 : { first=$FIRST.toString(); } IDENT query5 ;
 > query5 : { first=$FIRST.toString(); } ("where" query6)? ;
 > query6 : { first=$FIRST.toString(); } IDENT query7 ;
 > query7 : { first=$FIRST.toString(); } ("<" | "<=" | ">" | ">=")  
query8 ;
 > query8 : { first=$FIRST.toString(); } IDENT ;
 >
 > The problem I have is that I want to distinguish the IDENT in  
query2 and the
 > IDENT in query4. I have to do something in the parser, but what  
(semantic
 > action, but how)?? Any idea? I need this because when I analyze  
$FIRST in
 > another java class, I have to know if the IDENT I got from getFirst 
() is the
 > IDENT from rule query2 or the IDENT from rule query4.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060210/6d4487f3/attachment.html
From sunjigang1965 at yahoo.com.cn  Fri Feb 10 09:08:50 2006
From: sunjigang1965 at yahoo.com.cn (=?gb2312?q?=CB=EF=BC=CD=B8=D5=20Jigang=20(Robert)=20Sun?=)
Date: Fri Feb 10 09:08:58 2006
Subject: [antlr-interest] bugs with 2.7.6? (answer to " A problem with
	loading AST Node type occured")
Message-ID: <20060210170851.24042.qmail@web15704.mail.cnb.yahoo.com>

I did a small change in method loadNodeTypeObject() in
class antlr.ASTFactory                       

I changed nodeTypeName by prefixing it with 
NAMESPACE+".". I added on statement before " 
nodeTypeObject = assem.GetType(nodeTypeName);"


 if (nodeTypeName == "INTNode") nodeTypeName =
"MiniJava." + nodeTypeName;

so nodeTypeName becomes "MiniJava.INTNode". 

I suppose antlr user should not use his own namespace
if he want use hetero AST by default.

Jigang
                       
--- "ÀÔºÕ∏’ Jigang (Robert) Sun"
<sunjigang1965@yahoo.com.cn>–¥µ¿:

> »’∆⁄: Tue, 7 Feb 2006 16:39:52 +0800 (CST)
> ∑¢º˛»À: 
>     "ÀÔºÕ∏’ Jigang (Robert) Sun"
> <sunjigang1965@yahoo.com.cn>
> ÷˜Ã‚: A problem with loading AST Node type occured.
>  ’º˛»À: "antlr-interest@antlr.org"
> <antlr-interest@antlr.org>
> 
> A problem with loading AST Node type occured.
>    
>   Here is my simplest grammar:
>    
>    primaryExp
>   :
>    INTEGER_LITERAL <AST=INTNode>
>   ;
> 
>    
>   INTNode class
>    
>    public abstract class Expr : antlr.BaseAST{
>   public abstract int value();
>  }
>    
>    public class INTNode:Expr{
>   int val=0;
>   public INTNode(Token tok){
>    val=int.Parse(tok.getText());
>    }
>   public override int value(){
>    return val;
>   }
>   
>   public override  void initialize(AST t){
>   }
>   public override  void initialize(IToken t){
>   }
>   public override  void initialize(int i,string s){
>   }
>  }
>    
>   I have just newly downloaded Microsoft Framework
> 2.0, but the problem is still persisted.
>    
>   Jigang
> 
> 		
> ---------------------------------
>  —≈ª¢1G√‚∑—” œ‰∞Ÿ∑÷∞Ÿ∑¿¿¨ª¯–≈
>  —≈ª¢÷˙ ÷-À—À˜°¢…±∂æ°¢∑¿…ß»≈  


__________________________________________________
∏œøÏ◊¢≤·—≈ª¢≥¨¥Û»›¡ø√‚∑—” œ‰?
http://cn.mail.yahoo.com
From gabriel.adrian.radu at googlemail.com  Fri Feb 10 09:52:03 2006
From: gabriel.adrian.radu at googlemail.com (Gabriel Radu)
Date: Fri Feb 10 09:52:10 2006
Subject: [antlr-interest] Handling lexical nondeterminism in Tokens
In-Reply-To: <43E9054F.4050100@latte.harvard.edu>
References: <43E64701.7070800@latte.harvard.edu>
	<67e2ed240602060340i11c6e102m@mail.gmail.com>
	<43E76A77.5070208@latte.harvard.edu>
	<67e2ed240602060838j17b98d09l@mail.gmail.com>
	<43E8CE9A.3030505@latte.harvard.edu>
	<67e2ed240602071006j6e4d4a14w@mail.gmail.com>
	<43E9054F.4050100@latte.harvard.edu>
Message-ID: <67e2ed240602100952i2ce06dcet@mail.gmail.com>

Dear Mark,

Sorry for the delayed reply. With a little help from the Oracle
ORACLE-7-SQL grammar from the antler home page, I think that I have
solved the problem.

The attached grammar file works with your test cases. Now the next
step will be to build the AST and write a parser for it.

Best regards,
Gabriel



On 07/02/06, Mark R. Diggory <mdiggory@latte.harvard.edu> wrote:
> I've included both an attached jpeg showing the non-determiinism in
> Antlr Studio and the Eclipse project as a zip archive. There is a
> Main.java file with examples I'm testing in it.
>
> To handle all the cases where parenth can occur, I'm doing the following.
>
> > class SearchQueryParser extends Parser;
> >
> > options{
> >     k=3;
> >     exportVocab=SearchQuery;
> >     buildAST = true; // uses CommonAST by default
> > }
> >
> > statement
> >     : LEFT_PAREN expr RIGHT_PAREN EOST
> >     | expr EOST
> >     ;
> >
> > expr
> >     : mexpr ( bool_relations mexpr)*
> >     | LEFT_PAREN mexpr ( bool_relations  mexpr)* RIGHT_PAREN
> >     ;
> >
> > mexpr
> >     : atom ( bool_relations atom )*
> >     | LEFT_PAREN atom ( bool_relations atom )*    RIGHT_PAREN
> >     ;
> >
> > atom
> >     : IDENTIFIER equivalence_relation LITERAL
> >     ;
> >
> > bool_relations : AND|OR|NOT ;
> >
> > equivalence_relation : EQUALS|NOT_EQUALS|LT|LTE|GT|GTE ;
>
>
> thanks,
> -Mark
>
> Gabriel Radu wrote:
>
> >Do you have any test cases which work? And what is the generated
> >parser complaining about when you run the test cases mentioned in your
> >previous email?
> >
> >Best regards,
> >Gabriel
> >
> >
> >
> >On 07/02/06, Mark R. Diggory <mdiggory@latte.harvard.edu> wrote:
> >
> >
> >> Thanks, that is very close to what I need.
> >>
> >> Seems not to work on the following cases, which should all be valid.
> >>
> >> "((foo='bar')AND bim='bam');"
> >> "(foo='bar' AND bim='bam');"
> >> "foo='bar' AND bim='bam';"
> >>
> >> I've tried different combinations of defining the parethises and the white
> >>space. Along the lines of the following
> >>
> >> : LEFT_PAREN! expr RIGHT_PAREN!
> >> | expr
> >> But can't seem to get it right.
> >>
> >> -Mark
> >>
> >>
> >> Gabriel Radu wrote:
> >> Dear Mark,
> >>
> >>What about:
> >>
> >>
> >>
> >> class SearchQueryParser extends Parser;
> >> options
> >> {
> >> k=3;
> >> exportVocab=SearchQuery;
> >> buildAST = true; // uses CommonAST by default
> >>
> >> }
> >>
> >>statement
> >> : LEFT_PAREN! expr RIGHT_PAREN! EOST
> >> | expr EOST
> >> ;
> >>
> >>expr
> >> : mexpr ( bool_relations LEFT_PAREN! expr RIGHT_PAREN! )*
> >> ;
> >>
> >>mexpr
> >> : atom ( bool_relations atom )*
> >> ;
> >>
> >>atom
> >> : IDENTIFIER equivalence_relation LITERAL
> >> ;
> >>
> >>bool_relations : AND|OR|NOT ;
> >>
> >>equivalence_relation : EQUALS|NOT_EQUALS|LT|LTE|GT|GTE ;
> >>
> >> where EOST is a token which marks the end of a statement. It can be
> >>something like end of line or semicolon. Don't forget to add it to the
> >>lexer as well.
> >>
> >>Let me know how you are getting on.
> >>
> >>
> >>Best regards,
> >>Gabriel
> >>
> >>
> >>
> >>
> >>On 06/02/06, Mark R. Diggory <mdiggory@latte.harvard.edu> wrote:
> >>
> >>
> >> Thanks, I think I understand how this will help in the Lexer. I'm
> >>currently having problems how to capture how to properly represent the
> >>syntax in the Parser
> >>
> >>Here's a clarification of what I should be able to do with the query
> >>language:
> >>
> >>The smallest "atom" is a LITERAL string, currently this can be in quotes
> >>or not in quotes. For example:
> >>
> >>
> >>
> >> United States
> >>"Untied States"
> >>
> >> Alternatively a "atom" can be an equivalence relation. For instance:
> >>
> >>
> >>
> >> title="Untied States"
> >>title<>"Untied States"
> >>date>=2006
> >>
> >> Each atom can have parentheses around it.
> >>
> >>
> >>
> >> (title="Untied States")
> >>
> >> equivalence relations can be joined using boolean relations
> >>
> >>
> >>
> >> title="Untied States" AND date>=2006
> >>title="Untied States" OR date>=2006
> >>title="Untied States" NOT date>=2006
> >>
> >> boolean relations can be wrapped in parentheses to control precedence.
> >>
> >>
> >>
> >> title="Untied States" AND (date>=2006 OR author=Steven King)
> >>
> >> I've been trying to capture this using the following parser, but its
> >>clear now that I'm missing the mark:
> >>
> >>
> >>
> >> class SearchQueryParser extends Parser;
> >> options
> >> {
> >> k=3;
> >> exportVocab=SearchQuery;
> >> buildAST = true; // uses CommonAST by default
> >>
> >> }
> >>
> >>expr
> >> :
> >> mexpr ((AND|OR|NOT) mexpr)*
> >> ;
> >>
> >>mexpr
> >> :
> >> LITERAL | (IDENTIFIER (EQUALS|NOT_EQUALS|LT|LTE|GT|GTE)
> >>LITERAL)+
> >> ;
> >>
> >>atom
> >> :
> >> LEFT_PAREN! mexpr RIGHT_PAREN! | LEFT_PAREN! expr RIGHT_PAREN!
> >> ;
> >>
> >>
> >> thanks again for your advice,
> >>Mark
> >>
> >>Gabriel Radu wrote:
> >>
> >>
> >>
> >> Dear Mark,
> >>
> >>I suggest using syntactic predicates. Also increasing the lexers look
> >>ahead to 2 (k=2) for example may sort out the ambiguity between LT and
> >>LTE, and GT and GTE. However, if you use syntactic predicates for all
> >>tokens, increasing the look ahead may not be necessary.
> >>
> >>An example of using syntactic predicates for your grammar is following:
> >>
> >>
> >>class SearchQueryLexer extends Lexer;
> >> options
> >> {
> >> charVocabulary='\3'..'\377';
> >> }
> >>
> >>
> >>MAIN_LEXER_RULE
> >> : ( LITERAL ) => ( LITERAL { $setType( LITERAL ); } )
> >>
> >> | ( NOT_EQUALS ) => ( NOT_EQUALS { $setType( NOT_EQUALS ); } )
> >> | ( LTE ) => ( LTE { $setType( LTE ); } )
> >> | ( GTE ) => ( GTE { $setType( GTE ); } )
> >>
> >> | ( LT ) => ( LT { $setType( LT ); } )
> >> | ( GT ) => ( GT { $setType( GT ); } )
> >>
> >> | ( NOT ) => ( NOT { $setType( NOT ); } )
> >> | ( AND ) => ( AND { $setType( AND ); } )
> >> | ( OR ) => ( OR { $setType( OR ); } )
> >>
> >> | ( LEFT_PAREN ) => ( LEFT_PAREN { $setType( LEFT_PAREN ); } )
> >> | ( RIGHT_PAREN ) => ( RIGHT_PAREN { $setType( RIGHT_PAREN ); } )
> >>
> >> | ( EQUALS ) => ( EQUALS { $setType( EQUALS ); } )
> >>
> >> | ( IDENTIFIER ) => ( IDENTIFIER { $setType( IDENTIFIER ); } )
> >>
> >> | ( WS ) => WS
> >>
> >> ;
> >>
> >>protected
> >>WS
> >> :
> >> ('\n' | ' ' | '\t' | '\r')+
> >> {
> >> $setType(Token.SKIP);
> >> }
> >> ;
> >>
> >>
> >>protected
> >>SINGLE_QUOTE_STRING
> >> :
> >> '\''! (~('\''))* '\''!
> >> ;
> >>
> >>protected
> >>DOUBLE_QUOTE_STRING
> >> :
> >> '"'! (~('"'))* '"'!
> >> ;
> >>
> >>protected
> >>LITERAL
> >> :
> >> SINGLE_QUOTE_STRING | DOUBLE_QUOTE_STRING
> >> ;
> >>
> >>protected
> >>IDENTIFIER
> >>
> >> options
> >> {
> >> testLiterals=true;
> >> }
> >>
> >> :
> >> ('\241'..'\377'|'a'..'z'|'A'..'Z'|'_')
> >>('\241'..'\377'|'a'..'z'|'A'..'Z'|'-'|'_'|'0'..'9'|'.')*
> >> ;
> >>
> >>protected
> >>LEFT_PAREN
> >> : '(' ;
> >>
> >>protected
> >>RIGHT_PAREN
> >> : ')' ;
> >>
> >>protected
> >>NOT
> >> : ("NOT"|"not") ;
> >>
> >>protected
> >>AND
> >> : ("AND"|"and") ;
> >>
> >>protected
> >>OR
> >> : ("OR"|"or") ;
> >>
> >>protected
> >>EQUALS
> >> : '=' ;
> >>
> >>protected
> >>NOT_EQUALS
> >> : "<>" ;
> >>
> >>protected
> >>LT
> >> : '<' ;
> >>
> >>protected
> >>LTE
> >> : "<=" ;
> >>
> >>protected
> >>GT
> >> : '>' ;
> >>
> >>protected
> >>GTE
> >> : ">=" ;
> >>
> >>
> >>The syntactic predicates are in MAIN_LEXER_RULE. The order of
> >>productions (alternative rules) in MAIN_LEXER_RULE is important,
> >>because the lexer will try to match them in the order they are
> >>declared and will stop as soon as it finds a match. So for example LTE
> >>must be above LT because other ways the lexer will match the LT and
> >>then an EQUALS in stead of LTE.
> >>
> >>Let me know if this has solved your problem.
> >>
> >>
> >>Best regards,
> >>Gabriel
> >>
> >>
> >>
> >>
> >>On 05/02/06, Mark R. Diggory <mdiggory@latte.harvard.edu> wrote:
> >>
> >>
> >>
> >>
> >> I'm still working on building a Parser for our query syntax. I've
> >>encountered an issue with nondeterminism. I've included my grammar file:
> >>
> >>My question is how can I assure that the boolean predicate AND not the
> >>quoted string literal "you AND I" do not collide? I'd be very thankful
> >>to anyone with comments about obvious problems with my grammar file.
> >>
> >>thanks,
> >>Mark
> >>
> >>
> >>
> >>
> >>
> >> class SearchQueryParser extends Parser;
> >> options
> >> {
> >> k=3;
> >> exportVocab=SearchQuery;
> >> buildAST = true; // uses CommonAST by default
> >>
> >> }
> >>
> >>
> >>expr
> >> :
> >> mexpr ((AND|OR|NOT) mexpr)*
> >> ;
> >>
> >>mexpr
> >> :
> >> LITERAL^ | IDENTIFIER^ ((EQUALS|NOT_EQUALS|LT|LTE|GT|GTE)
> >>LITERAL^)+
> >> ;
> >>
> >>
> >>atom
> >> :
> >> IDENTIFIER | LEFT_PAREN! expr RIGHT_PAREN!
> >> ;
> >>
> >>class SearchQueryLexer extends Lexer;
> >> options
> >> {
> >> charVocabulary='\3'..'\377';
> >> }
> >>
> >>WS
> >> :
> >> ('\n' | ' ' | '\t' | '\r')+
> >> {
> >> $setType(Token.SKIP);
> >> }
> >> ;
> >>
> >>
> >>protected
> >>SINGLE_QUOTE_STRING
> >> :
> >> '\''! (~('\''))* '\''!
> >> ;
> >>
> >>protected
> >>DOUBLE_QUOTE_STRING
> >> :
> >> '"'! (~('"'))* '"'!
> >> ;
> >>
> >>LITERAL
> >> :
> >> SINGLE_QUOTE_STRING | DOUBLE_QUOTE_STRING
> >> ;
> >>
> >>IDENTIFIER
> >>
> >> options
> >> {
> >> testLiterals=true;
> >> }
> >>
> >> :
> >> ('\241'..'\377'|'a'..'z'|'A'..'Z'|'_')
> >>('\241'..'\377'|'a'..'z'|'A'..'Z'|'-'|'_'|'0'..'9'|'.')*
> >> ;
> >>
> >>LEFT_PAREN
> >> : '(' ;
> >>
> >>RIGHT_PAREN
> >> : ')' ;
> >>
> >>NOT
> >> : ("NOT"|"not") ;
> >>
> >>AND
> >> : ("AND"|"and") ;
> >>
> >>OR
> >> : ("OR"|"or") ;
> >>
> >>EQUALS
> >> : '=' ;
> >>
> >>NOT_EQUALS
> >> : "<>" ;
> >>
> >>LT
> >> : '<' ;
> >>
> >>LTE
> >> : "<=" ;
> >>
> >>GT
> >> : '>' ;
> >>
> >>GTE
> >> : ">=" ;
> >>
> >>
> >>
> >>
> >>
> >>
> >>
> >>
>
>
>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: query.g
Type: application/octet-stream
Size: 2425 bytes
Desc: not available
Url : http://www.antlr.org/pipermail/antlr-interest/attachments/20060210/2a8ba710/query-0001.obj
From Erik.Putrycz at nrc-cnrc.gc.ca  Fri Feb 10 10:23:22 2006
From: Erik.Putrycz at nrc-cnrc.gc.ca (Putrycz, Erik)
Date: Fri Feb 10 10:23:24 2006
Subject: [antlr-interest] COBOL question
Message-ID: <E4D07AB09F5F044299333C8D0FEB45E901932133@nrccenexb1.nrc.ca>

I'm trying to adapt the Open COBOL grammar to ANTLR and I'm struggling a
little... My goal is to build an AST of a COBOL program. I'm not too
familiar with lexers/parsers... 

How can I deal with the line number that starts each line?

It seems in the OpenCobol grammar, it is suppressed by a pre-processor
but I wouldn't mind having it in the AST.

How to build a Lexer rule for the line number?

Here is a COBOL line example

000010 IDENTIFICATION DIVISION.

And I want to deal with the starting 6 numbers...

 

Thanks,

 

Erik Putrycz, Ph.D - Research Associate /
<mailto:erik.putrycz@nrc-cnrc.gc.ca> erik.putrycz@nrc-cnrc.gc.ca / (613)
990 0681

Institute for Information Technology - Software Engineering Group

National Research Council, Canada - Building M-50, 1200 Montreal Road

Ottawa, Ontario, CANADA K1A 0R6

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060210/a8f7fb5f/attachment.html
From gudnabrsam at yahoo.com  Fri Feb 10 10:38:24 2006
From: gudnabrsam at yahoo.com (Matt Benson)
Date: Fri Feb 10 10:38:28 2006
Subject: [antlr-interest] COBOL question
In-Reply-To: <E4D07AB09F5F044299333C8D0FEB45E901932133@nrccenexb1.nrc.ca>
Message-ID: <20060210183824.30453.qmail@web30915.mail.mud.yahoo.com>

Having worked with COBOL for several years until my
recent emancipation, I don't envy you this task, which
I thought of doing more than once but fortunately
never HAD to.  The column positions sure were
problematical in theory, especially due to the fact
that different circumstances (some of which I still
don't completely understand) make it legal to, for
example, do away entirely with the initial six
characters, leaving not column seven, but column one
as the comment column, and shifting the rest of the
file similarly.  That aside, AFAIU the initial six
columns utilization for line numbers is only a
(widely-used) convention; with that in mind wouldn't
they be any six characters, period?  When I used to
egrep COBOL I would start patterns with "^.{6}[^\*]";
you get the point.  There is a sourceforge project
which uses a... sable? Javacc? can't remember, parser
to generate an XML view of a COBOL copybook... I
haven't looked at it in several months (whew) but last
I checked it had matured quite a bit and could parse
most of what I threw at it... I think it's LGPLd so
you might be able to extend from it, maybe not...
http://sourceforge.net/projects/cb2xml

when searching for cb2xml I found that sourceforge now
hosts another project of similar description, too:
http://sourceforge.net/projects/copybooktoxml

Good luck,
Matt

--- "Putrycz, Erik" <Erik.Putrycz@nrc-cnrc.gc.ca>
wrote:

> I'm trying to adapt the Open COBOL grammar to ANTLR
> and I'm struggling a
> little... My goal is to build an AST of a COBOL
> program. I'm not too
> familiar with lexers/parsers... 
> 
> How can I deal with the line number that starts each
> line?
> 
> It seems in the OpenCobol grammar, it is suppressed
> by a pre-processor
> but I wouldn't mind having it in the AST.
> 
> How to build a Lexer rule for the line number?
> 
> Here is a COBOL line example
> 
> 000010 IDENTIFICATION DIVISION.
> 
> And I want to deal with the starting 6 numbers...
> 
>  
> 
> Thanks,
> 
>  
> 
> Erik Putrycz, Ph.D - Research Associate /
> <mailto:erik.putrycz@nrc-cnrc.gc.ca>
> erik.putrycz@nrc-cnrc.gc.ca / (613)
> 990 0681
> 
> Institute for Information Technology - Software
> Engineering Group
> 
> National Research Council, Canada - Building M-50,
> 1200 Montreal Road
> 
> Ottawa, Ontario, CANADA K1A 0R6
> 
>  
> 
> 


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 
From open.zone at virgin.net  Fri Feb 10 12:11:52 2006
From: open.zone at virgin.net (Micheal J)
Date: Fri Feb 10 11:55:24 2006
Subject: [antlr-interest] bugs with 2.7.6? (answer to " A problem
	withloading AST Node type occured")
In-Reply-To: <20060210170851.24042.qmail@web15704.mail.cnb.yahoo.com>
Message-ID: <000201c62e7e$3d636940$6502a8c0@hercules>

> I did a small change in method loadNodeTypeObject() in
> class antlr.ASTFactory                       
> 
> I changed nodeTypeName by prefixing it with 
> NAMESPACE+".". I added on statement before "
> nodeTypeObject = assem.GetType(nodeTypeName);"
> 
> 
>  if (nodeTypeName == "INTNode") nodeTypeName =
> "MiniJava." + nodeTypeName;
> 
> so nodeTypeName becomes "MiniJava.INTNode". 

If I understand you correctly, you've modified ASTFactory to check for a
specific unqualifed class name and then make it fully qualified. There is no
need to do that, supplying fully qualified names is a requirement for using
hetero asts. Just supply the fully qualified name in the ANTLR file like
this:

	<AST=MiniJava.INTNode>

> I suppose antlr user should not use his own namespace
> if he want use hetero AST by default.

No, he must use the fully qualified name which includes the names of
enclosing namespace(s).

Cheers,

Micheal

From parrt at cs.usfca.edu  Fri Feb 10 12:41:46 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Fri Feb 10 12:41:49 2006
Subject: [antlr-interest] Updated C# parser grammar for kcsparse and the
	C# csharp_v1 example in ANTLR 2.7.6+
In-Reply-To: <001101c62e2f$d836f9e0$6502a8c0@hercules>
References: <001101c62e2f$d836f9e0$6502a8c0@hercules>
Message-ID: <35C85670-0F20-4502-ABEB-242C36DD1693@cs.usfca.edu>


On Feb 10, 2006, at 2:50 AM, Micheal J wrote:

> Updated grammar file includes a fix for parsing nested #region and #if
> preprocessor directive blocks.
>
> Thanks to  Paul Foster for reporting the issue (and supplying test  
> cases)
> and, Kunle for providing the fix.
>
> Get it here: http://www.antlr.org/share/1139567485993/CSharpParser.g

Great work!  I've moved to grammars area though from file sharing...

http://www.antlr.org/grammar/1139567485993/CSharpParser.g

Ter
From parrt at cs.usfca.edu  Fri Feb 10 12:49:45 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Fri Feb 10 12:49:49 2006
Subject: [antlr-dev] Re: [antlr-interest] generating cyclic state machines
	in Java
In-Reply-To: <1139526003.22707.1.camel@localhost.localdomain>
References: <20060209205649.47003.qmail@web30904.mail.mud.yahoo.com>
	<7F10BE5B-BEE8-46C0-B74C-01A8DB50EB0C@cs.usfca.edu>
	<1139526003.22707.1.camel@localhost.localdomain>
Message-ID: <6F3FAA7A-C5C9-4C6A-9A87-6CCB912B35B6@cs.usfca.edu>


On Feb 9, 2006, at 3:00 PM, Martin Probst wrote:

>> I hope!  I am also going to probably allocate one big 1D array and
>> then simulate the 2D array rather than let it create n arrays for n
>> DFA states.  Slows down GC etc...
>
> The two rules of optimisation:
> 1. Don't do it
> 2. (for experts) Don't do it yet
>
> Why not get a working system and benchmark it first?

Exactly what I was doing to do ;)  I was going to do the obvious  
first with the caveat that I must be able to limit the size of each  
state, deferring to a complicated hetergeneous state for unicode and  
predicates.

> In my experience
> the JIT & friends always behave different from what you'd expect ...

yup...

Ter
From antlr at jazillian.com  Sat Feb 11 14:33:42 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Sat Feb 11 14:33:57 2006
Subject: [antlr-interest] COBOL question
In-Reply-To: <E4D07AB09F5F044299333C8D0FEB45E901932133@nrccenexb1.nrc.ca>
References: <E4D07AB09F5F044299333C8D0FEB45E901932133@nrccenexb1.nrc.ca>
Message-ID: <43EE6646.30606@jazillian.com>

Putrycz, Erik wrote:

> I?m trying to adapt the Open COBOL grammar to ANTLR and I?m struggling 
> a little? My goal is to build an AST of a COBOL program. I?m not too 
> familiar with lexers/parsers?
>
> How can I deal with the line number that starts each line?
>
> It seems in the OpenCobol grammar, it is suppressed by a pre-processor 
> but I wouldn?t mind having it in the AST.
>
> How to build a Lexer rule for the line number?
>
> Here is a COBOL line example
>
> 000010 IDENTIFICATION DIVISION.
>
> And I want to deal with the starting 6 numbers?
>
> Thanks,
>
> **Erik**** ****Putrycz****, ****Ph.D**** - Research Associate / 
> ****erik.putrycz@nrc-cnrc.gc.ca** 
> <mailto:erik.putrycz@nrc-cnrc.gc.ca>** / ****(613) 990 0681**
>
> Institute for Information Technology - Software Engineering Group
>
> National Research Council, Canada - Building M-50, 1200 Montreal Road
>
> Ottawa, Ontario, CANADA K1A 0R6
>
I recently started a ANTLR COBOL grammar.
It's derived from this sorta-BNF grammar:
http://www.cs.vu.nl/grammars/vs-cobol-ii/#gdef:data-description-entry
It compiles with ANTLR, but gets zillions of ambiguity warnings, so
needs some major left-factoring. I'd be happy to collaborate if
anyone wants to, just send me email. I don't have any plans to
go further with it.

As for your question about lexing line numbers, yes, I think you'll need to
do that "by hand" first. You could check out Cobol for GCC:
http://cobolforgcc.sourceforge.net/
...or, what appears to be better...OpenCOBOL:
http://www.opencobol.org
From dieter_frej at gmx.net  Mon Feb 13 06:17:10 2006
From: dieter_frej at gmx.net (Dieter Frej)
Date: Mon Feb 13 06:23:00 2006
Subject: [antlr-interest] not inserting empty nodes in AST
Message-ID: <43F094E6.50102@gmx.net>

Hi everybody,

I hope this question was not asked before... at least I could not find
it in the archives...

I am using the java15.g from Michael Studman and I found that nodes like
EXTENDS_CLAUSE and IMPLEMENTS_CLAUSE are inserted even though they are
empty and do not contain any additional information. Can anyone help me
to get rid of them? Meaning: how do I have to change the grammar so that
they are not inserted in the AST when they are empty?

My example is a stupid

public class Test1
{

}

Thanks in advance!

Dieter
From ewbank at gmail.com  Mon Feb 13 06:26:57 2006
From: ewbank at gmail.com (Bryan Ewbank)
Date: Mon Feb 13 06:27:04 2006
Subject: [antlr-interest] heterogeneous trees and importing vocabularies
	(v2.7.x)
Message-ID: <dd3a065f0602130626y722bd1b2na4f65b72d345f608@mail.gmail.com>

Have a C++ code-generation question (but have a bad feeling about it :-)...

I am using importVocab for my parser and all the tree parsers; I am
now starting to consider using a heterogeneous tree.  My problem, and
the question, is

Are heterogeneous trees and the importVocab option mutually exclusive?
 The error I get when I add a tokens{} section to a grammar seems to
imply that is so.

To push a bit further, is there any way folks have come up with to use
templated types as the AST types?
   // this goes boom (error "excepting CLOSE_ELEMENT_OPTION, found '<' ")
   tokens {
      PLUS<AST=Node<PLUS> >;
   };

Stumped,
- Bryan
From dieter_frej at gmx.net  Mon Feb 13 07:57:23 2006
From: dieter_frej at gmx.net (Dieter Frej)
Date: Mon Feb 13 08:03:09 2006
Subject: [antlr-interest] line numbers to literals
Message-ID: <43F0AC63.8060003@gmx.net>

Hi,

I am using java15.g grammar from Michael Studman and I "enhanced" the
CommonAST to have line numbers as described in
http://www.jguru.com/jguru/faq/view.jsp?EID=62654

I was wondering what I have to change in the grammar in order to get the
line numbers for the modifiers (like public, static) and Literals like
if, while, try, ...

Thanks

Dieter
From parrt at cs.usfca.edu  Mon Feb 13 11:25:10 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Mon Feb 13 11:25:14 2006
Subject: [antlr-interest] ANTLR2005 workshop notes
Message-ID: <5C121074-E83B-4733-8A30-0B5E305658AF@cs.usfca.edu>

Howdy, finally scanned my workshop notes; too much effort to type. ;)

http://www.antlr.org/workshop/ANTLR2005/notes1.jpg
http://www.antlr.org/workshop/ANTLR2005/notes2.jpg

add to

http://www.antlr.org/workshop/ANTLR2005/summary.html

Ter
From jens.stegemann at gmx.de  Mon Feb 13 12:32:04 2006
From: jens.stegemann at gmx.de (Jens Stegemann)
Date: Mon Feb 13 12:32:09 2006
Subject: [antlr-interest] Parsing multiple messages using one parser
In-Reply-To: <bc607a4e0602081337x3c5ff51ev5a97014118728f95@mail.gmail.com>
References: <200602071514.36112.jens.stegemann@gmx.de>
	<bc607a4e0602080700k2248ef60p353f111f0481cd93@mail.gmail.com>
	<bc607a4e0602081337x3c5ff51ev5a97014118728f95@mail.gmail.com>
Message-ID: <200602132132.05063.jens.stegemann@gmx.de>

Hi,

> Here it is:
>
Thank you very much. Your code works well and sped up my application as much 
as expected. Your really were a great help!

Sorry for taking so long to reply...


Your's

Jens

-- 
Keep your dreams alive and live your dreams!
From kalle at snigel.net  Mon Feb 13 16:44:53 2006
From: kalle at snigel.net (karl wettin)
Date: Mon Feb 13 16:43:20 2006
Subject: [antlr-interest] more newbie help required
In-Reply-To: <EAD6B0E1-FFCF-4020-8D7E-1B41FC9B465A@snigel.net>
References: <921F860C-7105-48FA-9367-9A42322A0482@snigel.net>
	<99CD2E17-1813-46CC-B358-49987ED03D53@snigel.net>
	<EAD6B0E1-FFCF-4020-8D7E-1B41FC9B465A@snigel.net>
Message-ID: <AD4DAEAA-58B6-4B01-A5E3-012C799EEFC1@snigel.net>

I like ANTLR more and more, but have lots of troubles understanding  
documentation and examples regarding AST. I get some parts, but  
suddenly new characters and for me unknown terms is supposed to  
generate something I can use. But I dont understand what or how. Too  
many calculator-examples. Not even sure if I need AST, the  
interpreted text is in no way hierarchical.

I just want a simple Visitor  that follows the expressions as it  
matches. I could synchronize System.out and read the results from  
there. I don't want to do that. What am I supposed to do here?

2.
This is my single parser expression:

	expr: WELL_FORMATTED | BAD_FORMATTED;

Now I get an error where the grammar listed before the other in the  
lexer will be the matching expression. If the input is bad formatted  
data and WELL_FORMATTED is before the BAD_FORMATTED in the lexer, it  
will not match. My guess is that it has something to do with  
lookahead, but even at absurd levels it has no effect. I can get it  
to fail on the second character.

My solution is two parser expressions, and if WELL_FORMATTED throws a  
parser exception, then I call BAD_FORMATTED instead.

I do not understand at all why I get this error.


>
> In essense, why does this return the text:
>  	
> 	(show:SOME_EXPRESSION {System.out.println(show);})+
>
> and why does this return null:
> 	show:(options { greedy=false; } : SOME_EXPRESSION )+
> 	{System.out.println(show);}
>

I still don't understand this.

-- 
karl

From volenin at gmail.com  Tue Feb 14 04:52:23 2006
From: volenin at gmail.com (Vladimir Olenin)
Date: Tue Feb 14 04:52:26 2006
Subject: [antlr-interest] antlr based data parser frameworks
Message-ID: <43F1D287.4060505@gmail.com>

Hi,

I wonder if there are any antlr powered data parser frameworks which
would facilitate most common tasks of parsing arbitrary flat data files
(eg, delimited lists, etc). The key here is SIMPLE, meaning there is a
way to setup parsing 'parameters' through simple config file, eg XML.
The Lexer&Parser would also be generic enough to allow reasonably
flexible behavior for these use cases (data files with no looping, etc).

Just to illustrate the idea, here what config file might look like:
...
  <data file="xxx" listener="com.myproject.CSVParserListener">
    <delim>;,/t</delim>
    <field name="alias" order="1" />
    <field name="name"  order="2" />
    <field name="email" order="3" />
  </data>
...
with sample input file

JACK, JACK LAYTON, jack@canada.com
PAUL, Paul Martin, paul@canada.com

The intermediate step would be to generate Lexer&Parser from a template
on the fly, transforming XML definitions (above) into Lexer tokens and
Parser rules, compiling them and parsing the defined input file. The
also should be some way to hook up an event listener which would listen
for the tokens/data structures spit out by the parser.

I realize it might be a bit of a long shot, but I don't see any major
technical obstacles which might prevent such or similar framework. (The
example above is quite primitive. It should also be possible to describe
more complex _structured_ data through xml, similar to the way arbitrary
XML file structure can be described through DTD or XSD)

I've seen ANTLR provides an example of 'simple parser' (CSV list). I've
also ran into a commercial ANTLR powered CSV parser. But there seems to
be no framework like the one I've tried to describe above.


PS: I realize there is not enough information here to even sketch the
draft of the framework, so if there is no such framework yet and there
is interest in discussing the idea, I can put together something more
coherent.


From mail at martin-probst.com  Tue Feb 14 06:42:09 2006
From: mail at martin-probst.com (Martin Probst)
Date: Tue Feb 14 06:42:15 2006
Subject: [antlr-interest] more newbie help required
In-Reply-To: <07CEBD13-746A-4A34-8DDF-1F096E719970@snigel.net>
References: <921F860C-7105-48FA-9367-9A42322A0482@snigel.net>
	<99CD2E17-1813-46CC-B358-49987ED03D53@snigel.net>
	<EAD6B0E1-FFCF-4020-8D7E-1B41FC9B465A@snigel.net>
	<AD4DAEAA-58B6-4B01-A5E3-012C799EEFC1@snigel.net>
	<1139908421.9638.4.camel@localhost.localdomain>
	<07CEBD13-746A-4A34-8DDF-1F096E719970@snigel.net>
Message-ID: <1139928130.7789.6.camel@localhost.localdomain>

Hi,

your currently doing all the work in the lexer and don't use a parser at
all. If you have a completely flat file format, that's exactly what you
want to do though.

The 'normal' way of using a Lexer however is something like this:
Lexer myLexer = new Lexer(input);
Token tok = null;
while ((tok = myLexer.nextToken()).getType() != Token.EOF) {
  // do something with the token
}

You would then try to break up input into single parts (e.g. NAME,
SEASON, EPISODE, etc., that's why the Lexer is also called Tokenizer) so
you can easily handle the single parts from the outside. But that might
not work four you, at least not with your current way of parsing.

Martin

On Tue, 2006-02-14 at 13:21 +0100, karl wettin wrote:
> 14 feb 2006 kl. 10.13 skrev Martin Probst:
> 
> Hi, and thanks for your reply!
> 
> >>
> >> I just want a simple Visitor
> >
> > You can create member variables in your parser class and custom
> > constructors, methods etc., so you have all Java-power at your
> > fingertips.
> 
>   I hacked a visitor to my Lexer. If it's as easy it sounds to be I  
> guess I could just copy my code to the parser. A simple example,  
> perhaps based on my grammar, would be appreciated.
> 
> >> If the input is bad formatted  data and WELL_FORMATTED is
> >> before the BAD_FORMATTED in the lexer, it  will not match.
> >
> > Could you post the Lexer rules for WELL_FORMATTED and for  
> > BAD_FORMATTED?
> > I'd guess that your input text is matching both of them (e.g. your
> > language is non-deterministic - both rules can match the same  
> > input) or
> > at least the same prefix. Matching something "slightly wrong" can be
> > very difficult.
> 
> Attached is the generated vistor hack-lexer, the visitor and the  
> visitor coupled grammar and a test. I think it should run without any  
> problems.
> 
> 

From Ulrich.Frank at dlr.de  Tue Feb 14 06:48:00 2006
From: Ulrich.Frank at dlr.de (Ulrich Frank)
Date: Tue Feb 14 06:48:05 2006
Subject: [antlr-interest] Newbie: problem with semantic differentiation in
	the lexer
Message-ID: <43F1EDA0.8@dlr.de>

Hello,

I have the following problem. In the lexer I define the following rules

protected CHAR : ('a'..'z') ;
protected DIGIT : ('0'..'9') ;
IDENT : (CHAR | DIGIT)+ ;

In the parser I have a rule like

query : "from" IDENT "select" IDENT ;

Because I want to develop a query editor I want to extend it with an 
auto completion mechanism. This means at the position of IDENT after 
'from' I want to choose between all existing objects coming from an 
repository and at the position of IDENT after 'select' I want to show 
all available attributes corresponding to the object selected after 'from'.
To do this, I have to distinguish between both of these IDENTs. So how 
can I do this???? Any proposals? Please help.
From mail at martin-probst.com  Tue Feb 14 07:16:27 2006
From: mail at martin-probst.com (Martin Probst)
Date: Tue Feb 14 07:16:35 2006
Subject: [antlr-interest] Newbie: problem with semantic differentiation
	in the lexer
In-Reply-To: <43F1EDA0.8@dlr.de>
References: <43F1EDA0.8@dlr.de>
Message-ID: <1139930187.7789.8.camel@localhost.localdomain>

> Because I want to develop a query editor I want to extend it with an 
> auto completion mechanism. This means at the position of IDENT after 
> 'from' I want to choose between all existing objects coming from an 
> repository and at the position of IDENT after 'select' I want to show 
> all available attributes corresponding to the object selected after 'from'.
> To do this, I have to distinguish between both of these IDENTs. So how 
> can I do this???? Any proposals? Please help.

What about getting the last token in the editor left of the current
caret position and deciding depending on it's type?

Martin

From ric.klaren at gmail.com  Tue Feb 14 11:20:37 2006
From: ric.klaren at gmail.com (Ric Klaren)
Date: Tue Feb 14 11:20:36 2006
Subject: [antlr-interest] heterogeneous trees and importing vocabularies
	(v2.7.x)
In-Reply-To: <dd3a065f0602130626y722bd1b2na4f65b72d345f608@mail.gmail.com>
References: <dd3a065f0602130626y722bd1b2na4f65b72d345f608@mail.gmail.com>
Message-ID: <43F22D85.4080907@gmail.com>

Bryan Ewbank wrote:
> Have a C++ code-generation question (but have a bad feeling about it :-)...
> 
> I am using importVocab for my parser and all the tree parsers; I am
> now starting to consider using a heterogeneous tree.  My problem, and
> the question, is

I cannot really recommend the heterogeneous AST stuff... you're bound to
run into quirks/problems/limitations of the reference counter.

> Are heterogeneous trees and the importVocab option mutually exclusive?
>  The error I get when I add a tokens{} section to a grammar seems to
> imply that is so.

I would have to check the source, what is the message you get?

> To push a bit further, is there any way folks have come up with to use
> templated types as the AST types?
>    // this goes boom (error "excepting CLOSE_ELEMENT_OPTION, found '<' ")
>    tokens {
>       PLUS<AST=Node<PLUS> >;
>    };

Hmmm would require building escaping into antlr.g... Does it work to
typedef the node type outside somewhere?

Cheers,

Ric
From Ulrich.Frank at dlr.de  Tue Feb 14 12:11:46 2006
From: Ulrich.Frank at dlr.de (Ulrich Frank)
Date: Tue Feb 14 12:11:46 2006
Subject: [antlr-interest] Newbie: problem with semantic differentiation in the
	lexer
Message-ID: <761AD4D5-C079-4DF6-86CB-437952BDBEB6@dlr.de>

Hello Martin,

the way you proposed is the one I've chosen right now. But isn't  
there a better one, especially for the definition of the rules?  
Perhaps a semantic action or something like that ....?
From kroepke at dolphin-services.de  Tue Feb 14 14:25:06 2006
From: kroepke at dolphin-services.de (Kay Roepke)
Date: Tue Feb 14 14:25:12 2006
Subject: [antlr-interest] [v3] options {ignore=WS;} MIA?
Message-ID: <9F8092CC-7896-4EEE-BF27-305E5AC54148@dolphin-services.de>

Moin!

Have I missed the reason for v3 not being able to use the elegant  
ignore=WS option in a lexer rule?
Or is it just One Moret Thing(tm) on the TODO-list?

Regards,

Kay
From parrt at cs.usfca.edu  Tue Feb 14 14:40:23 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Tue Feb 14 14:40:27 2006
Subject: [antlr-interest] who asked me to do setFileCharEncoding in ST?
Message-ID: <74159106-C6F1-43BA-A251-BB3128C1BC4E@cs.usfca.edu>

Hi, i am doing a paper on i18n for ST and i want to credit the man or  
woman that suggested I add setFileCharEncoding to ST groups...can  
anybody remind me who that was?  I was there at least in April 2004  
so probalby the Jan 2005 (2.1?) release.

I have it down as Anton Keks that gave me the idea of mapping type to  
renderer.  If somebody else helped, please let me konw.  Paper is due  
Fri.

Ter
From kalle at snigel.net  Wed Feb 15 01:17:47 2006
From: kalle at snigel.net (karl wettin)
Date: Wed Feb 15 01:16:16 2006
Subject: [antlr-interest] case optimization
Message-ID: <69885456-5CA6-4259-816E-EC4EB6FF93F6@snigel.net>

A sequence of characters seems to be translated by ANTLR to Java as a  
long case statement.

Would it not be faster to check (min =< char <= max)? Is there some  
JVM optimization I'm not aware of?

-- 
karl
From kalle at snigel.net  Wed Feb 15 05:33:02 2006
From: kalle at snigel.net (karl wettin)
Date: Wed Feb 15 05:31:30 2006
Subject: [antlr-interest] more newbie help required
In-Reply-To: <1139928130.7789.6.camel@localhost.localdomain>
References: <921F860C-7105-48FA-9367-9A42322A0482@snigel.net>
	<99CD2E17-1813-46CC-B358-49987ED03D53@snigel.net>
	<EAD6B0E1-FFCF-4020-8D7E-1B41FC9B465A@snigel.net>
	<AD4DAEAA-58B6-4B01-A5E3-012C799EEFC1@snigel.net>
	<1139908421.9638.4.camel@localhost.localdomain>
	<07CEBD13-746A-4A34-8DDF-1F096E719970@snigel.net>
	<1139928130.7789.6.camel@localhost.localdomain>
Message-ID: <A659E008-6F99-4343-BC6C-28F9D43A9A4D@snigel.net>


14 feb 2006 kl. 15.42 skrev Martin Probst:
> your currently doing all the work in the lexer and don't use a  
> parser at
> all. If you have a completely flat file format, that's exactly what  
> you
> want to do though.

Great news, as I take it "completely flat" is want I want. Or is it?  
What does it mean? The visitor I hacked in my lexer does the trick.   
What would then be the correct way of implementing a visitor like the  
one in my code? I doubt hacking a bean property to the lexer after  
generation is a correct solution.

FOO : bar:(<WORD>) { visitor.foo(bar); };


> The 'normal' way of using a Lexer however is something like this:
> Lexer myLexer = new Lexer(input);
> Token tok = null;
> while ((tok = myLexer.nextToken()).getType() != Token.EOF) {
>   // do something with the token
> }
>
> You would then try to break up input into single parts (e.g. NAME,
> SEASON, EPISODE, etc., that's why the Lexer is also called  
> Tokenizer) so
> you can easily handle the single parts from the outside. But that  
> might
> not work four you, at least not with your current way of parsing.

I am not completely sure I understand what you are telling me. If I  
want it "normal", I should to what with my grammar and move what to  
the parser?

However I did try something like your suggested code and got the only  
two tokens as result. One composite root expression and an EOF token.  
I did not get the building part tokens of the composite root. Is this  
due to the fact that I only use the lexer? No rules are protected. Or  
is it becasue all my grammar is coupled to each other, that the first  
two tokens in my lexer will consume the whole text by calling other  
grammar? Should this be done in the parser for below code to return  
the composite part tokens of the root expression?

	public static void test(String text) throws Exception {
		System.out.println("Testing " + text);
		MyLexer lexer = new MyLexer(new StringReader(text));
		while (true) {
			Token token = lexer.nextToken();
			System.out.println(token.getType() + "\t" + token.getText());			
			if (token.getType() == MyLexerTokenTypes.EOF) {
				break;
			}
		}
	}

-- 
karl

> Martin
>
> On Tue, 2006-02-14 at 13:21 +0100, karl wettin wrote:
>> 14 feb 2006 kl. 10.13 skrev Martin Probst:
>>
>> Hi, and thanks for your reply!
>>
>>>>
>>>> I just want a simple Visitor
>>>
>>> You can create member variables in your parser class and custom
>>> constructors, methods etc., so you have all Java-power at your
>>> fingertips.
>>
>>   I hacked a visitor to my Lexer. If it's as easy it sounds to be I
>> guess I could just copy my code to the parser. A simple example,
>> perhaps based on my grammar, would be appreciated.
>>
>>>> If the input is bad formatted  data and WELL_FORMATTED is
>>>> before the BAD_FORMATTED in the lexer, it  will not match.
>>>
>>> Could you post the Lexer rules for WELL_FORMATTED and for
>>> BAD_FORMATTED?
>>> I'd guess that your input text is matching both of them (e.g. your
>>> language is non-deterministic - both rules can match the same
>>> input) or
>>> at least the same prefix. Matching something "slightly wrong" can be
>>> very difficult.
>>
>> Attached is the generated vistor hack-lexer, the visitor and the
>> visitor coupled grammar and a test. I think it should run without any
>> problems.
>>
>>
>
>

From allex at all-x.net  Wed Feb 15 05:53:09 2006
From: allex at all-x.net (Alexey Demakov)
Date: Wed Feb 15 05:53:11 2006
Subject: [antlr-interest] need ANTLRHashString.toString() conversion!
Message-ID: <01ed01c63237$27bb6360$8cc79553@marlboro>

I'm trying to use lexer's literalsTable as source for set of keywords.
But the current ANTLRHashString interface have not method to convert it to String,
so only "query" interface is possible. 
To implement "enumeration" interface I need to get string value of ANTLRHashString.
"enumeration" interface required, for example, to implement syntax highliting in Eclipse.

There is my "query" interface:

private static TDL_Lexer literalsTableProvider 
    = new TDL_Lexer( (antlr.LexerSharedInputState)null ); 
private static Hashtable literalsTable = literalsTableProvider.getLiteralsTable();
private static ANTLRHashString hashString = new ANTLRHashString( literalsTableProvider );
    
    /**
     * Returns true if given string is one of TreeDL keywords.
     *  
     * @param s        String to be checked.
     * @return         true if string is one of TreeDL keywords.
     */
    public static synchronized boolean isKeyword( String s )
    {
        hashString.setString( s );
        return literalsTable.containsKey( hashString );
    }


Regards,
Alexey

-----
Alexey Demakov
TreeDL: Tree Description Language: http://treedl.sourceforge.net
RedVerst Group: http://www.unitesk.com


From allex at all-x.net  Wed Feb 15 05:53:49 2006
From: allex at all-x.net (Alexey Demakov)
Date: Wed Feb 15 05:53:53 2006
Subject: [antlr-interest] Bug in 2.7.6 with lexer option defaultErrorHandler
	= true
Message-ID: <020a01c63237$3f848f80$8cc79553@marlboro>

When lexer option defaultErrorHandler is set to true,
antlr-2.7.6 generates error handlers with call of 

public void recover( RecognitionException ex, BitSet tokenSet )

but this method is defined only in Parser, not in CharScanner,
so it causes compilation errors.

antlr-2.7.2 "inlines" this method as

consume();
consumeUntil( tokenSet );

Workaround - define this method in lexer:

public void recover( RecognitionException ex, BitSet tokenSet ) throws CharStreamException 
{
  consume();
  consumeUntil( tokenSet );
}

Regards,
Alexey

-----
Alexey Demakov
TreeDL: Tree Description Language: http://treedl.sourceforge.net
RedVerst Group: http://www.unitesk.com

From dalloro at gmail.com  Wed Feb 15 07:08:22 2006
From: dalloro at gmail.com (Livio)
Date: Wed Feb 15 07:08:26 2006
Subject: [antlr-interest] Unicode-16 xml parser
Message-ID: <4d0d52400602150708s29a8cb40r2bceca50eeeafae4@mail.gmail.com>

Skipped content of type multipart/alternative-------------- next part --------------
A non-text attachment was scrubbed...
Name: uxml.g
Type: application/octet-stream
Size: 5739 bytes
Desc: not available
Url : http://www.antlr.org/pipermail/antlr-interest/attachments/20060215/943f7bef/uxml-0001.obj
-------------- next part --------------
A non-text attachment was scrubbed...
Name: test.xml
Type: text/xml
Size: 252 bytes
Desc: not available
Url : http://www.antlr.org/pipermail/antlr-interest/attachments/20060215/943f7bef/test-0001.xml
From dalloro at users.sourceforge.net  Wed Feb 15 07:10:30 2006
From: dalloro at users.sourceforge.net (Livio Dalloro)
Date: Wed Feb 15 07:10:35 2006
Subject: [antlr-interest] Unicode-16 xml parser
Message-ID: <4d0d52400602150710h65a02691ief8574e6f336502f@mail.gmail.com>

Skipped content of type multipart/alternative-------------- next part --------------
A non-text attachment was scrubbed...
Name: test.xml
Type: text/xml
Size: 252 bytes
Desc: not available
Url : http://www.antlr.org/pipermail/antlr-interest/attachments/20060215/d2cfd7f9/test.xml
-------------- next part --------------
A non-text attachment was scrubbed...
Name: uxml.g
Type: application/octet-stream
Size: 5739 bytes
Desc: not available
Url : http://www.antlr.org/pipermail/antlr-interest/attachments/20060215/d2cfd7f9/uxml.obj
From mail at martin-probst.com  Wed Feb 15 07:51:42 2006
From: mail at martin-probst.com (Martin Probst)
Date: Wed Feb 15 07:51:49 2006
Subject: [antlr-interest] more newbie help required
In-Reply-To: <A659E008-6F99-4343-BC6C-28F9D43A9A4D@snigel.net>
References: <921F860C-7105-48FA-9367-9A42322A0482@snigel.net>
	<99CD2E17-1813-46CC-B358-49987ED03D53@snigel.net>
	<EAD6B0E1-FFCF-4020-8D7E-1B41FC9B465A@snigel.net>
	<AD4DAEAA-58B6-4B01-A5E3-012C799EEFC1@snigel.net>
	<1139908421.9638.4.camel@localhost.localdomain>
	<07CEBD13-746A-4A34-8DDF-1F096E719970@snigel.net>
	<1139928130.7789.6.camel@localhost.localdomain>
	<A659E008-6F99-4343-BC6C-28F9D43A9A4D@snigel.net>
Message-ID: <1140018702.26134.14.camel@localhost.localdomain>

> Or is it becasue all my grammar is coupled to each other, that the 
> first two tokens in my lexer will consume the whole text by calling 
> other grammar? 

Yes, that's the reason. The 'normal' idea is that you have several lexer
rules and each of them matches a part of the file. Then nextToken() will
return single parts of the file. If you use a parser, the parser would
then depending on the token type descend into different subrules etc.

> Should this be done in the parser for below code to return  
> the composite part tokens of the root expression?
> 
> 	public static void test(String text) throws Exception {
> 		System.out.println("Testing " + text);
> 		MyLexer lexer = new MyLexer(new StringReader(text));
> 		while (true) {
> 			Token token = lexer.nextToken();
> 			System.out.println(token.getType() + "\t" + token.getText());			
> 			if (token.getType() == MyLexerTokenTypes.EOF) {
> 				break;
> 			}
> 		}
> 	}

This is correct.

Martin

From parrt at cs.usfca.edu  Wed Feb 15 10:35:32 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Wed Feb 15 10:35:35 2006
Subject: [antlr-interest] Bug in 2.7.6 with lexer option
	defaultErrorHandler = true
In-Reply-To: <020a01c63237$3f848f80$8cc79553@marlboro>
References: <020a01c63237$3f848f80$8cc79553@marlboro>
Message-ID: <BD15F359-F7BA-47CF-A97D-16DC16AE48D8@cs.usfca.edu>


On Feb 15, 2006, at 5:53 AM, Alexey Demakov wrote:

> When lexer option defaultErrorHandler is set to true,
> antlr-2.7.6 generates error handlers with call of
> public void recover( RecognitionException ex, BitSet tokenSet )
>
> but this method is defined only in Parser, not in CharScanner,
> so it causes compilation errors.
>
> antlr-2.7.2 "inlines" this method as
>
> consume();
> consumeUntil( tokenSet );
>
> Workaround - define this method in lexer:
>
> public void recover( RecognitionException ex, BitSet tokenSet )  
> throws CharStreamException {
>  consume();
>  consumeUntil( tokenSet );
> }

I swear I fixed that but as you say...fix did not get in there. : 
(  We're going to do a 2.7.7 soon.

Ter
From prashant.deva at gmail.com  Wed Feb 15 11:38:53 2006
From: prashant.deva at gmail.com (Prashant Deva)
Date: Wed Feb 15 11:38:56 2006
Subject: [antlr-interest] Bug in 2.7.6 with lexer option
	defaultErrorHandler = true
In-Reply-To: <BD15F359-F7BA-47CF-A97D-16DC16AE48D8@cs.usfca.edu>
References: <020a01c63237$3f848f80$8cc79553@marlboro>
	<BD15F359-F7BA-47CF-A97D-16DC16AE48D8@cs.usfca.edu>
Message-ID: <41fed8f80602151138s189d59ebkc78d4dca757f7080@mail.gmail.com>

Terence,
  How soon are you planning to release 2.7.7 ?

If it will be a little late, could you just send me the fix for this
problem, so I can put it in the version of antlr that will be provided with
ANTLR Studio in the next update.

I will version it as 2.7.6.1

On 2/16/06, Terence Parr <parrt@cs.usfca.edu> wrote:
>
>
> On Feb 15, 2006, at 5:53 AM, Alexey Demakov wrote:
>
> > When lexer option defaultErrorHandler is set to true,
> > antlr-2.7.6 generates error handlers with call of
> > public void recover( RecognitionException ex, BitSet tokenSet )
> >
> > but this method is defined only in Parser, not in CharScanner,
> > so it causes compilation errors.
> >
> > antlr-2.7.2 "inlines" this method as
> >
> > consume();
> > consumeUntil( tokenSet );
> >
> > Workaround - define this method in lexer:
> >
> > public void recover( RecognitionException ex, BitSet tokenSet )
> > throws CharStreamException {
> >  consume();
> >  consumeUntil( tokenSet );
> > }
>
> I swear I fixed that but as you say...fix did not get in there. :
> (  We're going to do a 2.7.7 soon.
>
> Ter
>



--
Prashant Deva
Creator, ANTLR Studio
Founder, Placid Systems, www.placidsystems.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060216/71ed36c3/attachment.html
From parrt at cs.usfca.edu  Wed Feb 15 12:07:42 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Wed Feb 15 12:07:47 2006
Subject: [antlr-interest] please review: internationalization and
	localization paper
Message-ID: <19798C73-DD2B-456C-A13F-5E704DF0E8E6@cs.usfca.edu>

Howdy,

I'm submitting a paper on StringTemplate for ICWE06 conference:

http://www.cs.usfca.edu/~parrt/papers/i18n.pdf

and I could use your feedback.  Goes in depth about how ST deals with  
nasty i18n problems.

Deadline for submission is Fri ;)

Ter
From open.zone at virgin.net  Wed Feb 15 15:16:08 2006
From: open.zone at virgin.net (Micheal J)
Date: Wed Feb 15 14:59:37 2006
Subject: [antlr-interest] Bug in 2.7.6 with lexer
	optiondefaultErrorHandler = true
In-Reply-To: <BD15F359-F7BA-47CF-A97D-16DC16AE48D8@cs.usfca.edu>
Message-ID: <000901c63285$ce4f71f0$6502a8c0@hercules>

> > public void recover( RecognitionException ex, BitSet tokenSet )
> > throws CharStreamException {
> >  consume();
> >  consumeUntil( tokenSet );
> > }
> 
> I swear I fixed that but as you say...fix did not get in there. : 
> (  We're going to do a 2.7.7 soon.

I also remember adding recover() to C#, Java and C++ CharScanner last year.
How did this get rolled-back?

Cheers,

Micheal

From parrt at cs.usfca.edu  Wed Feb 15 19:36:34 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Wed Feb 15 19:36:50 2006
Subject: [antlr-interest] Bug in 2.7.6 with lexer
	optiondefaultErrorHandler = true
In-Reply-To: <000901c63285$ce4f71f0$6502a8c0@hercules>
References: <000901c63285$ce4f71f0$6502a8c0@hercules>
Message-ID: <FECEAC74-0EE2-4023-8EE4-68930CC22C2F@cs.usfca.edu>


On Feb 15, 2006, at 3:16 PM, Micheal J wrote:

>>> public void recover( RecognitionException ex, BitSet tokenSet )
>>> throws CharStreamException {
>>>  consume();
>>>  consumeUntil( tokenSet );
>>> }
>>
>> I swear I fixed that but as you say...fix did not get in there. :
>> (  We're going to do a 2.7.7 soon.
>
> I also remember adding recover() to C#, Java and C++ CharScanner  
> last year.
> How did this get rolled-back?

no idea :(  Booo.  oh well...we can fix it.
Ter
From parrt at cs.usfca.edu  Wed Feb 15 19:37:16 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Wed Feb 15 19:37:33 2006
Subject: [antlr-interest] Bug in 2.7.6 with lexer option
	defaultErrorHandler = true
In-Reply-To: <41fed8f80602151138s189d59ebkc78d4dca757f7080@mail.gmail.com>
References: <020a01c63237$3f848f80$8cc79553@marlboro>
	<BD15F359-F7BA-47CF-A97D-16DC16AE48D8@cs.usfca.edu>
	<41fed8f80602151138s189d59ebkc78d4dca757f7080@mail.gmail.com>
Message-ID: <3145F7EB-3E40-4258-B19C-2DB44CBCB269@cs.usfca.edu>


On Feb 15, 2006, at 11:38 AM, Prashant Deva wrote:

> Terence,
>   How soon are you planning to release 2.7.7 ?
>
> If it will be a little late, could you just send me the fix for  
> this problem, so I can put it in the version of antlr that will be  
> provided with ANTLR Studio in the next update.
>
> I will version it as 2.7.6.1

ok. well, i'm not sure when we'll do this...not too soon though...i'm  
swamped.
Ter
From jbarnesweb at yahoo.com  Wed Feb 15 23:16:15 2006
From: jbarnesweb at yahoo.com (Jeff Barnes)
Date: Wed Feb 15 23:16:17 2006
Subject: [antlr-dev] Re: [antlr-interest] generating cyclic state machines
	in Java
In-Reply-To: <CE1ED11A-57D4-4B50-8C18-CC2BBC61E2FC@cs.usfca.edu>
Message-ID: <20060216071615.35323.qmail@web54511.mail.yahoo.com>

Hi everyone,

Please take a look at my take on this problem from a
conceptual standpoint. 

http://www.geocities.com/jbarnesweb/fsmsurvey.pdf

If you like it, I could propose a template to replace
Java.stg.

More below:


--- Terence Parr <parrt@cs.usfca.edu> wrote:

> First, my goals:
> 
> 1. don't create a lot of classes
> 2. don't create a lot of instances

I'm pretty sure one of the models I'm proposing fits
both of those requirements.

> 3. avoid method calls per character just to
> transition

How about InputSymbol? (could be a TokenType wrapper)

> 4. be as small as possible

The smallest possible would probably be a table
lookup. For just a little more size, you get
readability too. ;)

> 
> I thought about just making a huge switch on state
> number that jumped  
> to a CASE:
> 
> switch ( s ) {
>    case 0 : ...
>    case 1 : ...
>    ...
> }

Say it ain't so, Ter...

sigh.

> 
> But, with say 500 states I'm not sure java would do
> this efficiently  
> and it would limit the size of our DFAs due to java
> method size  
> limits.  For states that have semantic predicates
> are truly  
> complicated transitions, we could do this.
> 

Yeah, I just don't buy the switch stuff. Better to
know what you want upfront for me.


> As an optimization, I would like something tight
> like this:
> 
> while ( s != accept state ) {
>    s = states[s][input.LA(1)];
>    if ( s==-1 ) error;
> }
> return predictedAlt[s];

That is a classic Cargill take on state machines, I
believe. Please take a look at the doc and let me know
which way you are leaning.

Regards,
Jeff


=========
Jeff Barnes
(206)245-6100


Few things are impossible to diligence and skill.
--- Samuel Johnson (Rasselas Chap. xii.)
From silvester.pozarnik at tracetracker.com  Thu Feb 16 03:27:44 2006
From: silvester.pozarnik at tracetracker.com (Silvester Pozarnik)
Date: Thu Feb 16 03:27:54 2006
Subject: [antlr-interest] The ISO 8601 Date Format
Message-ID: <5D85F621120B9545BE359DCFA778812535FE1E@SERVER.tt.tracetracker.com>

Did someone tried to write down the lexical rules for the ISO 8601 Date
Format? There are some discussions about (as in the
http://www.antlr.org/pipermail/antlr-interest/2003-August/004790.ht
ml), but there is none implementation to be found.

 

This is strange, since this is one of the most used data types and the
ISO 8601 is the most used representation format.

 

BR

Silvester

            

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060216/8d8aa0cd/attachment.html
From danspaven at hotmail.com  Thu Feb 16 07:40:28 2006
From: danspaven at hotmail.com (Dan Spaven)
Date: Thu Feb 16 07:40:37 2006
Subject: [antlr-interest] Newbie needs guidance on passing paramters to
	functions
Message-ID: <BAY101-F320DF5B37DCA3AF8D59960BBFB0@phx.gbl>

Hi there,

I'm attempting to parse and translate a C like language (with a limited set 
of constructs) into bytecode. The language has #include statements at the 
start of the program pointing to files containing the functions needed. I've 
successfully expanded these files inline using the java include example that 
comes with antlr-2.7.5.

My problem is that despite my best efforts i still have no idea on how to 
pass the parameters to these functions from calls that occur later on in the 
code.

my questions are:

Can this be done by just using a grammar file or will i need to build a 
treeparser?
and depending on the answer to the above can anybody give me any details on 
a recommended solution?

Any replies would be very much appreciated,

Cheers,

Dan


From Sebastian.Kaliszewski at softax.com.pl  Thu Feb 16 11:04:09 2006
From: Sebastian.Kaliszewski at softax.com.pl (Sebastian Kaliszewski)
Date: Thu Feb 16 10:48:17 2006
Subject: [antlr-interest] Newbie needs guidance on passing paramters to
	functions
In-Reply-To: <BAY101-F320DF5B37DCA3AF8D59960BBFB0@phx.gbl>
References: <BAY101-F320DF5B37DCA3AF8D59960BBFB0@phx.gbl>
Message-ID: <43F4CCA9.1080703@softax.com.pl>

Dan Spaven wrote:
> My problem is that despite my best efforts i still have no idea on how 
> to pass the parameters to these functions from calls that occur later on 
> in the code.
> 
> my questions are:
> 
> Can this be done by just using a grammar file or will i need to build a 
> treeparser?
> and depending on the answer to the above can anybody give me any details 
> on a recommended solution?

In simple cases of code generator for simple grammars tree parser is non 
needed. If there is lots of syntactic shugar and stuff in your language, 
tree parser is a nice addition(*) allowing you to simplify your code 
generation code reducing code repetition (3 x code on one sentence, thats 
fun;)).

Anyway, what you need here is thing known as symbol table (in typical 
language it is in fact a hierarchy of dictionaries, for each scope one such 
dictionary) i.e. thing which maps your symbol names (i.e. names of 
variables, functions, types, classes, constant, enumerations, whatever) to 
types or values they represent. So if you have in your code a following 
construct:

float myFun(int a, float b) {
   return a+b;
}

Then you'd load the following entry (mapping) into your symbol table:

"myFun" -> kind: FUNCTION
            type: "float"
            parameters: "int", "float"
            subscope: (
              "a" -> kind: VARIABLE
                     type: "int";
              "b" -> kind: VARIABLE
                     type: "float";
            );


Where subscope contains symbol table for the scope of myFun function body.

Of course, you have to encode the symbol table structure into programming 
language you're using to write your compiler. In statically typed OO 
languages like Java, C++ or C# in case of such rather simple symbol 
tables(**) just use language's own dictionary type (std::map in C++) and 
entries could be members of some class heirarchy with common root. In Python 
you could do the same or take advantage of some dynamic typing and/or 
functional programming features.


rgds
Sebastian Kaliszewski
-

*) Especially with Antlr 3 this will be even better option, as tree 
generation code will be simpler and more readable, but
From parrt at cs.usfca.edu  Thu Feb 16 12:22:30 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Thu Feb 16 12:22:44 2006
Subject: [antlr-interest] fingers need rest
Message-ID: <99622A73-0635-43CE-AB69-AAD68DAC3731@cs.usfca.edu>

hi. I'm learning dvorak and resting inflamed fingers...i may not be  
able to respond to emails for a bit :(

Ter
From zhixueyong at hotmail.com  Thu Feb 16 21:30:16 2006
From: zhixueyong at hotmail.com (Xue Yong Zhi)
Date: Thu Feb 16 21:31:12 2006
Subject: [antlr-interest] First release of Rubyfront
Message-ID: <loom.20060217T062642-686@post.gmane.org>

I am glad to announce the first release of rubyfront (a ruby parser powered by 
antlr).

Even though this is the first release, rubyfront can parse entire ruby standard 
library (over 1500 .rb files).

To download or check out more details about rubyfront, please go to http://
seclib.blogspot.com/2006/02/first-release-of-rubyfront.html

Rubyfront uses BSD license. I am going to write more about it on my blog later.

Xue Yong Zhi
http://seclib.blogspot.com

From Ulrich.Frank at dlr.de  Fri Feb 17 02:44:38 2006
From: Ulrich.Frank at dlr.de (Ulrich Frank)
Date: Fri Feb 17 02:44:44 2006
Subject: [antlr-interest] Error computing the FIRST set???
Message-ID: <43F5A916.60305@dlr.de>

Hello, me again.

I have a problem with the computation of the first set of a rule. I hope 
you can help me although it is a little difficult to explain.
Well, first the lexer grammar:

...
tokens {
    CIT = "ComplexItemType";
    ATTR = "Attribute" ;
}

IDENT options {testLiterals=true;} : (DIGIT | CHAR | DOT)+ ;

....

Then the parser grammar:

{
    private String first = "";
}

query :   { first=$FIRST.toString(); } "from" query2 ;
query2 : { first=$FIRST.toString(); } CIT query3 ;
query3 : { first=$FIRST.toString(); } "select" query4 ;
query4 : { first=$FIRST.toString(); } (ATTR)? query5 ;
query5 : { first=$FIRST.toString(); } "where" query6 ;
....


So first includes in the different cases the following
FIRST(query) = {"from"}
FIRST(query2) = {"ComplexItemType"}
FIRST(query3) = {"select"}
FIRST(query4) = {"where"}   <-------------- ERROR ????? I'm missing 
"Attribute"
FIRST(query5) = {"where"}

There is something more to explain but I think it will get to much (I 
subclass the generatet lexer class and modify the nextToken() method)).
The main problem is the following: The difference in using the tokens 
(CIT and ATTR) is that in the second case the usage is optional. In the 
case of query2 the FIRST set was computed correct but in the optional 
case query4 "Attribute" is missing. Is there a bug or what did I wrong? 
Please help.
From dalloro at gmail.com  Fri Feb 17 03:10:47 2006
From: dalloro at gmail.com (Livio)
Date: Fri Feb 17 03:10:51 2006
Subject: [antlr-interest] Re: Unicode-16 xml parser
In-Reply-To: <4d0d52400602150708s29a8cb40r2bceca50eeeafae4@mail.gmail.com>
References: <4d0d52400602150708s29a8cb40r2bceca50eeeafae4@mail.gmail.com>
Message-ID: <4d0d52400602170310l3b96ba5fv877d2d85994f568b@mail.gmail.com>

Sorry for the duplicate post,
no hints for my grammar?

thanks anyway.

On 2/15/06, Livio <dalloro@gmail.com> wrote:
>
> Hi,
>
> I'm not sure this is the right list to ask this question...
> I'm using antlr-2.7.6 to produce c++ code and I'm trying to parse
> simplified xml unicode (not UTF-8) files.
> I've read a couple of threads about unicode parsing in antlr and I've seen
>
> that antlr doesn't support wchar. But it shouldn't be a problem, since
> what I need to produce is an "old style" parser/scanner able to handle
> unicode
> input, not a full unicode parser/scanner.
> I've also had a look to the unicode exmaple in the antlr examples
> directory, but
> it seemed too tailored to UTF-8 inputs.
>
> My first attempt was to produce a grammar that could work with ANSI, and I
>
> succeded on my first attempt.
> The grammar in attach is the result of my porting to unicode-16
> (In my plans there's a porting to unicode-32), that first grammar, and
> didn't work.
> The ansi scanner had a k=2, the unicode version has a k=4 because of the
> internal
> "char" representation that antlr uses.
>
> The problem shows up immediately at the beginning of the parse phase.
> May you give me some hints to discover and solve the error(s)?
> I know I'm a newbie, so I hope my problem don't get you bored too much.
>
> I thank you in advance.
>
> P.S.
> Note that the first 2 byte that usually "mark" the beginning of a unicode
> file have
> been removed to simpify the grammar.
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060217/4663efc1/attachment.html
From amohombe at yahoo.com  Fri Feb 17 04:10:44 2006
From: amohombe at yahoo.com (Ahmed Mohombe)
Date: Fri Feb 17 04:11:10 2006
Subject: [antlr-interest] Re: fingers need rest
In-Reply-To: <99622A73-0635-43CE-AB69-AAD68DAC3731@cs.usfca.edu>
References: <99622A73-0635-43CE-AB69-AAD68DAC3731@cs.usfca.edu>
Message-ID: <dt4eg5$t7f$3@sea.gmane.org>

> ...and resting inflamed fingers...
Than maybe this is good for you:
http://www.datahand.com/

:).

Ahmed.

From craig at palantir.co.za  Sat Feb 18 01:55:04 2006
From: craig at palantir.co.za (Craig Main)
Date: Sat Feb 18 01:55:12 2006
Subject: [antlr-interest] conditional tree jumping,
Message-ID: <20060218095508.8C2EBDCC25@www.antlr.org>

Hi,

 

Is there any way of only evaluating the true part when the condition is
true, and the false part if the condition is false in the below tree?

 

statement                          {log.Debug(null); object result = null;}


                                 : #(ASSIGN id:ID result=expression {
log.Info(string.Format("{0} = {1}", id.getText(), result)); } ) 

                                 | #(TOK_CONST cid:ID ASSIGN result=term)
{log.Info("constant decl");}

                                 | {log.Debug("inside");}

                                   #(TOK_IF condition (statement)*
({log.Debug("in-else");} TOK_ELSE (statement)* {log.Debug("out-else");})?)

                                   {log.Debug("outside");}

                                 ;

 

condition                        

returns [object result]             {log.Debug(null); result = null; object
l, r;}

                                 : #(TOK_OR l=condition r=condition)

                                  | #(TOK_AND l=condition r=condition)

                                  | #(NOT_EQUAL l=condition r=condition)

                                  | #(EQUAL l=condition r=condition)

                                  | #(LTHAN l=condition r=condition)

                                  | #(GTHAN l=condition r=condition)

                                  | #(LTE l=condition r=condition)

                                  | #(GTE l=condition r=condition)

                                 | result=expression
{log.Debug("condition->expression");}

                                 ;

 

Regards

Craig

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060218/44c9b6c0/attachment.html
From Jeff.Barnes at codesic.com  Sat Feb 18 21:00:13 2006
From: Jeff.Barnes at codesic.com (Jeff Barnes)
Date: Sat Feb 18 21:04:07 2006
Subject: [antlr-interest] conditional tree jumping,
References: <20060218095508.8C2EBDCC25@www.antlr.org>
Message-ID: <FC6B2BF8B2FE854EAE0C380E55CA5734119D7E@hq-app2.CODESIC.COM>

Hi Craig,
 
I'm no tree parser guru, but I believe you want to return a boolean instead of an object from the condition rule. Perhaps you can evaluate the result of the expression rule on the result alt. You may, however, want to refactor the result=expression to something like result=booleanExpression since a condition implies a boolean, at least in my mind it does... ;)
 
Regards,
Jeff

________________________________

From: antlr-interest-bounces@antlr.org on behalf of Craig Main
Sent: Sat 2/18/2006 1:55 AM
To: antlr-interest@antlr.org
Subject: [antlr-interest] conditional tree jumping,



Hi,

 

Is there any way of only evaluating the true part when the condition is true, and the false part if the condition is false in the below tree?

 

statement                          {log.Debug(null); object result = null;}                                   

                                 : #(ASSIGN id:ID result=expression { log.Info(string.Format("{0} = {1}", id.getText(), result)); } ) 

                                 | #(TOK_CONST cid:ID ASSIGN result=term) {log.Info("constant decl");}

                                 | {log.Debug("inside");}

                                   #(TOK_IF condition (statement)* ({log.Debug("in-else");} TOK_ELSE (statement)* {log.Debug("out-else");})?)

                                   {log.Debug("outside");}

                                 ;

 

condition                        

returns [object result]             {log.Debug(null); result = null; object l, r;}

                                 : #(TOK_OR l=condition r=condition)

                                  | #(TOK_AND l=condition r=condition)

                                  | #(NOT_EQUAL l=condition r=condition)

                                  | #(EQUAL l=condition r=condition)

                                  | #(LTHAN l=condition r=condition)

                                  | #(GTHAN l=condition r=condition)

                                  | #(LTE l=condition r=condition)

                                  | #(GTE l=condition r=condition)

                                 | result=expression {log.Debug("condition->expression");}

                                 ;

 

Regards

Craig

From craig at palantir.co.za  Sat Feb 18 23:36:37 2006
From: craig at palantir.co.za (Craig Main)
Date: Sat Feb 18 23:36:44 2006
Subject: [antlr-interest] conditional tree jumping,
In-Reply-To: <FC6B2BF8B2FE854EAE0C380E55CA5734119D7E@hq-app2.CODESIC.COM>
Message-ID: <20060219073641.176C2DCC35@www.antlr.org>

Hi Jeff,

Thanks for the response.
I agree completely with your appraisal of the Boolean rule.

My question is somewhat more sinister though. I need to know how to choose a
branch of the AST tree based on the outcome of the expression. I want to
skip processing the false loop if the condition is true, and vice versa.

I want the tree parser to skip parsing the correct section of the true. A
kind of semantic predicate I think?

Regards
Craig

-----Original Message-----
From: antlr-interest-bounces@antlr.org
[mailto:antlr-interest-bounces@antlr.org] On Behalf Of Jeff Barnes
Sent: 19 February 2006 07:00
To: antlr-interest@antlr.org
Subject: RE: [antlr-interest] conditional tree jumping,

Hi Craig,
 
I'm no tree parser guru, but I believe you want to return a boolean instead
of an object from the condition rule. Perhaps you can evaluate the result of
the expression rule on the result alt. You may, however, want to refactor
the result=expression to something like result=booleanExpression since a
condition implies a boolean, at least in my mind it does... ;)
 
Regards,
Jeff

________________________________

From: antlr-interest-bounces@antlr.org on behalf of Craig Main
Sent: Sat 2/18/2006 1:55 AM
To: antlr-interest@antlr.org
Subject: [antlr-interest] conditional tree jumping,



Hi,

 

Is there any way of only evaluating the true part when the condition is
true, and the false part if the condition is false in the below tree?

 

statement                          {log.Debug(null); object result = null;}


                                 : #(ASSIGN id:ID result=expression {
log.Info(string.Format("{0} = {1}", id.getText(), result)); } ) 

                                 | #(TOK_CONST cid:ID ASSIGN result=term)
{log.Info("constant decl");}

                                 | {log.Debug("inside");}

                                   #(TOK_IF condition (statement)*
({log.Debug("in-else");} TOK_ELSE (statement)* {log.Debug("out-else");})?)

                                   {log.Debug("outside");}

                                 ;

 

condition                        

returns [object result]             {log.Debug(null); result = null; object
l, r;}

                                 : #(TOK_OR l=condition r=condition)

                                  | #(TOK_AND l=condition r=condition)

                                  | #(NOT_EQUAL l=condition r=condition)

                                  | #(EQUAL l=condition r=condition)

                                  | #(LTHAN l=condition r=condition)

                                  | #(GTHAN l=condition r=condition)

                                  | #(LTE l=condition r=condition)

                                  | #(GTE l=condition r=condition)

                                 | result=expression
{log.Debug("condition->expression");}

                                 ;

 

Regards

Craig



From jens.bartelheimer at gmx.de  Sun Feb 19 14:17:47 2006
From: jens.bartelheimer at gmx.de (Jens Bartelheimer)
Date: Sun Feb 19 14:17:52 2006
Subject: [antlr-interest] Lexer exception?
Message-ID: <43F8EE8B.7060509@gmx.de>

Hi,

how can I catch such an exception? I do not found something in the 
documentation.

line 1:1: unexpected token: 111

Cheers,
Jens


From mail at martin-probst.com  Sun Feb 19 15:04:43 2006
From: mail at martin-probst.com (Martin Probst)
Date: Sun Feb 19 15:04:54 2006
Subject: [antlr-interest] Lexer exception?
In-Reply-To: <43F8EE8B.7060509@gmx.de>
References: <43F8EE8B.7060509@gmx.de>
Message-ID: <1140390284.9244.7.camel@localhost.localdomain>

> how can I catch such an exception? I do not found something in the 
> documentation.
> 
> line 1:1: unexpected token: 111

You have to turn off the default error handler, e.g. in your options
section of the lexer "defaultErrorHandler = false". Afterwards you can
catch exceptions. All of them extend ANTLRException, the manual contains
a part called "Exception hierarchy".

Martin

From jens.bartelheimer at gmx.de  Sun Feb 19 15:28:18 2006
From: jens.bartelheimer at gmx.de (Jens Bartelheimer)
Date: Sun Feb 19 15:28:23 2006
Subject: [antlr-interest] Lexer exception?
In-Reply-To: <1140390284.9244.7.camel@localhost.localdomain>
References: <43F8EE8B.7060509@gmx.de>
	<1140390284.9244.7.camel@localhost.localdomain>
Message-ID: <43F8FF12.9070903@gmx.de>


Hi Martin,

thanks for your reply but if I turn off the option there are no 
additional exceptions.

If I turn it on explicit I have the following error in the Lexer:

My error message:
The method recover(RecognitionException, BitSet) is undefined for the 
type UMLLexer

Why? Is there a mistake in my Lexer?

Jens


Martin Probst wrote:
>> how can I catch such an exception? I do not found something in the 
>> documentation.
>>
>> line 1:1: unexpected token: 111
>>     
>
> You have to turn off the default error handler, e.g. in your options
> section of the lexer "defaultErrorHandler = false". Afterwards you can
> catch exceptions. All of them extend ANTLRException, the manual contains
> a part called "Exception hierarchy".
>
> Martin
>
>
>   
From ewbank at gmail.com  Sun Feb 19 20:30:11 2006
From: ewbank at gmail.com (Bryan Ewbank)
Date: Sun Feb 19 20:30:13 2006
Subject: [antlr-interest] conditional tree jumping,
In-Reply-To: <20060219073641.176C2DCC35@www.antlr.org>
References: <FC6B2BF8B2FE854EAE0C380E55CA5734119D7E@hq-app2.CODESIC.COM>
	<20060219073641.176C2DCC35@www.antlr.org>
Message-ID: <dd3a065f0602192030j3d1877ck3af8b9f102ab56dd@mail.gmail.com>

Yes, a semantic predicate avoids evaluating the "wrong half".  Something like
this will work (assume that "condition" returns a boolean value:

    #(TOK_IF
        res=condition
        ( {res==true}?
            (statement)* TOK_ELSE ( . )*
        | {res==false}?
            ( . )* TOK_ELSE (statement)*
        )
    )

Note that this form as a bit of a problem figuring out which node is the
"right" TOK_ELSE because there might be another TOK_IF statement therein.

I find it easier/cleaner to add a statement-list node so that the TOK_ELSE is
eliminated and there's no ambiguity.  This leads to:

    #(TOK_IF res=condition
        ( {res==true}? stmt .
        | . stmt )
    )


On 2/19/06, Craig Main <craig@palantir.co.za> wrote:
> Hi Jeff,
>
> Thanks for the response.
> I agree completely with your appraisal of the Boolean rule.
>
> My question is somewhat more sinister though. I need to know how to choose a
> branch of the AST tree based on the outcome of the expression. I want to skip
> processing the false loop if the condition is true, and vice versa.
>
> I want the tree parser to skip parsing the correct section of the true. A
> kind of semantic predicate I think?
>
> Regards
> Craig
From craig at palantir.co.za  Sun Feb 19 20:46:25 2006
From: craig at palantir.co.za (Craig Main)
Date: Sun Feb 19 20:46:31 2006
Subject: [antlr-interest] conditional tree jumping,
In-Reply-To: <dd3a065f0602192030j3d1877ck3af8b9f102ab56dd@mail.gmail.com>
Message-ID: <20060220044628.D898FDCC7F@www.antlr.org>

Hi Bryan,

How would you eliminate the else with the statement list?
I am not quite sure what you mean here - I am still trying to wrap my brain
around the tree matching syntax.

Would you be in a position to give me a small example? I assume that you
eliminate the node in the parser.

Regards
Craig

-----Original Message-----
From: antlr-interest-bounces@antlr.org
[mailto:antlr-interest-bounces@antlr.org] On Behalf Of Bryan Ewbank
Sent: 20 February 2006 06:30
To: ANTLR Interest
Subject: Re: [antlr-interest] conditional tree jumping,

Yes, a semantic predicate avoids evaluating the "wrong half".  Something
like
this will work (assume that "condition" returns a boolean value:

    #(TOK_IF
        res=condition
        ( {res==true}?
            (statement)* TOK_ELSE ( . )*
        | {res==false}?
            ( . )* TOK_ELSE (statement)*
        )
    )

Note that this form as a bit of a problem figuring out which node is the
"right" TOK_ELSE because there might be another TOK_IF statement therein.

I find it easier/cleaner to add a statement-list node so that the TOK_ELSE
is
eliminated and there's no ambiguity.  This leads to:

    #(TOK_IF res=condition
        ( {res==true}? stmt .
        | . stmt )
    )


On 2/19/06, Craig Main <craig@palantir.co.za> wrote:
> Hi Jeff,
>
> Thanks for the response.
> I agree completely with your appraisal of the Boolean rule.
>
> My question is somewhat more sinister though. I need to know how to choose
a
> branch of the AST tree based on the outcome of the expression. I want to
skip
> processing the false loop if the condition is true, and vice versa.
>
> I want the tree parser to skip parsing the correct section of the true. A
> kind of semantic predicate I think?
>
> Regards
> Craig


From demakov at ispras.ru  Sun Feb 19 23:08:20 2006
From: demakov at ispras.ru (Alexey Demakov)
Date: Sun Feb 19 23:08:34 2006
Subject: [antlr-interest] Lexer exception?
Message-ID: <000701c635ec$6e6589e0$8cc79553@marlboro>

Hi Jens,

Aa I wrote recently, it is the bug in antlr.
http://www.antlr.org/pipermail/antlr-interest/2006-February/015417.html

Define this method in your lexer code:

public void recover( RecognitionException ex, BitSet tokenSet ) throws CharStreamException 
{
  saveConsumedInput = false; 
  consume();
  consumeUntil( tokenSet );
  saveConsumedInput = true; 
}

But if you want completly skip malformed token, you have to define custom exception handler
with $setType( Token.SKIP ) for each lexer rule. :(

---
Alexey Demakov
TreeDL: Tree Description Language: http://treedl.sourceforge.net
RedVerst Group: http://www.unitesk.com


From: "Jens Bartelheimer" <jens.bartelheimer@gmx.de>
> Hi Martin,
> 
> thanks for your reply but if I turn off the option there are no 
> additional exceptions.
> 
> If I turn it on explicit I have the following error in the Lexer:
> 
> My error message:
> The method recover(RecognitionException, BitSet) is undefined for the 
> type UMLLexer
> 
> Why? Is there a mistake in my Lexer?
> 
> Jens
> 
> 
> Martin Probst wrote:
> >> how can I catch such an exception? I do not found something in the 
> >> documentation.
> >>
> >> line 1:1: unexpected token: 111
> >>     
> >
> > You have to turn off the default error handler, e.g. in your options
> > section of the lexer "defaultErrorHandler = false". Afterwards you can
> > catch exceptions. All of them extend ANTLRException, the manual contains
> > a part called "Exception hierarchy".


From demakov at ispras.ru  Sun Feb 19 23:10:26 2006
From: demakov at ispras.ru (Alexey Demakov)
Date: Sun Feb 19 23:10:42 2006
Subject: [antlr-interest] Bug in 2.7.6 with lexer option
	defaultErrorHandler = true
Message-ID: <000d01c635ec$b973b600$8cc79553@marlboro>

From: "Terence Parr" <parrt@cs.usfca.edu>
> On Feb 15, 2006, at 5:53 AM, Alexey Demakov wrote:
> 
> > When lexer option defaultErrorHandler is set to true,
> > antlr-2.7.6 generates error handlers with call of
> > public void recover( RecognitionException ex, BitSet tokenSet )
> >
> > but this method is defined only in Parser, not in CharScanner,
> > so it causes compilation errors.
> >
> > antlr-2.7.2 "inlines" this method as
> >
> > consume();
> > consumeUntil( tokenSet );
> >
> > Workaround - define this method in lexer:
> >
> > public void recover( RecognitionException ex, BitSet tokenSet )  
> > throws CharStreamException {
> >  consume();
> >  consumeUntil( tokenSet );
> > }
> 
> I swear I fixed that but as you say...fix did not get in there. : 
> (  We're going to do a 2.7.7 soon.

I'm starting to doubt that it is the best way for recovery in lexer...
All text matched by consume() and  consumeUntil( tokenSet ) 
is appended to token.  May be it's better to set saveConsumedInput = false before consume()
and restore saveConsumedInput = true after consumeUntil()?
And how can I completely skip this malformed token?
I can't set token type to Token.SKIP in recover() and don't want 
to define custom error handlers for each lexer rule.
May be allow to return a value from recover() method?

public boolean recover( RecognitionException ex, BitSet tokenSet )  
throws CharStreamException {
  consume();
  consumeUntil( tokenSet );
  return false;
}

and generate error handler as

catch (RecognitionException ex) {
   reportError(ex);
   if( !recover(ex,_tokenSet_1) ) _type = Token.SKIP;
}

---
Alexey Demakov
TreeDL: Tree Description Language: http://treedl.sourceforge.net
RedVerst Group: http://www.unitesk.com


From Ulrich.Frank at dlr.de  Mon Feb 20 00:54:21 2006
From: Ulrich.Frank at dlr.de (Ulrich Frank)
Date: Mon Feb 20 00:54:26 2006
Subject: [antlr-interest] Error computing the FIRST set???
Message-ID: <43F983BC.9030802@dlr.de>

Hello,

I found the error .... and it's of course made by myself.

In the example I posted FIRST(query4) is be computed right, but in case 
of query4 also FIRST(query5) is computed and therefore the result of 
FIRST(query5) is saved in first and not FIRST(query4) - it's overwritten.

Cu,
Uli
From jens.bartelheimer at gmx.de  Mon Feb 20 01:48:18 2006
From: jens.bartelheimer at gmx.de (Jens Bartelheimer)
Date: Mon Feb 20 01:48:23 2006
Subject: [antlr-interest] Lexer exception?
In-Reply-To: <000701c635ec$6e6589e0$8cc79553@marlboro>
References: <000701c635ec$6e6589e0$8cc79553@marlboro>
Message-ID: <43F99062.3010906@gmx.de>

Ok, this method solves the problem if the option is set to true.

As Martin mentioned I have to set this option to false but there are no 
additional exceptions. I think this is idependent from the bug in antlr. 
Am I right? I also do not want to skip the malformed token, I only need 
an exception so that I can recognize the wrong input  if  I call the 
parser. Further I do not need the printing of the message "line 1:1: 
unexpected token: 111". Is this only possible with the $skipToken....?

Thanks,
Jens

Alexey Demakov wrote:
> Hi Jens,
>
> Aa I wrote recently, it is the bug in antlr.
> http://www.antlr.org/pipermail/antlr-interest/2006-February/015417.html 
>
>
> Define this method in your lexer code:
>
> public void recover( RecognitionException ex, BitSet tokenSet ) throws 
> CharStreamException {
>  saveConsumedInput = false;  consume();
>  consumeUntil( tokenSet );
>  saveConsumedInput = true; }
>
> But if you want completly skip malformed token, you have to define 
> custom exception handler
> with $setType( Token.SKIP ) for each lexer rule. :(
>
> ---
> Alexey Demakov
> TreeDL: Tree Description Language: http://treedl.sourceforge.net
> RedVerst Group: http://www.unitesk.com
>
>
> From: "Jens Bartelheimer" <jens.bartelheimer@gmx.de>
>> Hi Martin,
>>
>> thanks for your reply but if I turn off the option there are no 
>> additional exceptions.
>>
>> If I turn it on explicit I have the following error in the Lexer:
>>
>> My error message:
>> The method recover(RecognitionException, BitSet) is undefined for the 
>> type UMLLexer
>>
>> Why? Is there a mistake in my Lexer?
>>
>> Jens
>>
>>
>> Martin Probst wrote:
>> >> how can I catch such an exception? I do not found something in the 
>> >> documentation.
>> >>
>> >> line 1:1: unexpected token: 111
>> >>     >
>> > You have to turn off the default error handler, e.g. in your options
>> > section of the lexer "defaultErrorHandler = false". Afterwards you can
>> > catch exceptions. All of them extend ANTLRException, the manual 
>> contains
>> > a part called "Exception hierarchy".
>
>
>
From demakov at ispras.ru  Mon Feb 20 02:27:41 2006
From: demakov at ispras.ru (Alexey Demakov)
Date: Mon Feb 20 02:27:57 2006
Subject: [antlr-interest] Lexer exception?
References: <000701c635ec$6e6589e0$8cc79553@marlboro> <43F99062.3010906@gmx.de>
Message-ID: <013f01c63608$477c13f0$8cc79553@marlboro>

As far as I know defaultErrorHandler = false causes lexer
to throw TokenStreamException. By default parser catches RecognitionException only,
so parser will pass TokenStreamException without any messages.

I think

line 1:1: unexpected token: 111

caused by error in parser not in lexer. It looks like default parser error message.
If 111 is valid token, there is no error in lexer. If file can't start from
this token, it is parser error.

Regards,
Alexey

-----
Alexey Demakov
TreeDL: Tree Description Language: http://treedl.sourceforge.net
RedVerst Group: http://www.unitesk.com


----- Original Message ----- 
From: "Jens Bartelheimer" <jens.bartelheimer@gmx.de>
To: "Alexey Demakov" <demakov@ispras.ru>
Cc: "antlr-interest" <antlr-interest@antlr.org>
Sent: Monday, February 20, 2006 12:48 PM
Subject: Re: [antlr-interest] Lexer exception?


> Ok, this method solves the problem if the option is set to true.
> 
> As Martin mentioned I have to set this option to false but there are no 
> additional exceptions. I think this is idependent from the bug in antlr. 
> Am I right? I also do not want to skip the malformed token, I only need 
> an exception so that I can recognize the wrong input  if  I call the 
> parser. Further I do not need the printing of the message "line 1:1: 
> unexpected token: 111". Is this only possible with the $skipToken....?
> 
> Thanks,
> Jens
> 
> Alexey Demakov wrote:
>> Hi Jens,
>>
>> Aa I wrote recently, it is the bug in antlr.
>> http://www.antlr.org/pipermail/antlr-interest/2006-February/015417.html 
>>
>>
>> Define this method in your lexer code:
>>
>> public void recover( RecognitionException ex, BitSet tokenSet ) throws 
>> CharStreamException {
>>  saveConsumedInput = false;  consume();
>>  consumeUntil( tokenSet );
>>  saveConsumedInput = true; }
>>
>> But if you want completly skip malformed token, you have to define 
>> custom exception handler
>> with $setType( Token.SKIP ) for each lexer rule. :(
>>
>> ---
>> Alexey Demakov
>> TreeDL: Tree Description Language: http://treedl.sourceforge.net
>> RedVerst Group: http://www.unitesk.com
>>
>>
>> From: "Jens Bartelheimer" <jens.bartelheimer@gmx.de>
>>> Hi Martin,
>>>
>>> thanks for your reply but if I turn off the option there are no 
>>> additional exceptions.
>>>
>>> If I turn it on explicit I have the following error in the Lexer:
>>>
>>> My error message:
>>> The method recover(RecognitionException, BitSet) is undefined for the 
>>> type UMLLexer
>>>
>>> Why? Is there a mistake in my Lexer?
>>>
>>> Jens
>>>
>>>
>>> Martin Probst wrote:
>>> >> how can I catch such an exception? I do not found something in the 
>>> >> documentation.
>>> >>
>>> >> line 1:1: unexpected token: 111
>>> >>     >
>>> > You have to turn off the default error handler, e.g. in your options
>>> > section of the lexer "defaultErrorHandler = false". Afterwards you can
>>> > catch exceptions. All of them extend ANTLRException, the manual 
>>> contains
>>> > a part called "Exception hierarchy".
>>
>>
>>

From damir.kirasic at fer.hr  Mon Feb 20 02:34:27 2006
From: damir.kirasic at fer.hr (=?ISO-8859-2?Q?Damir_Kirasi=E6?=)
Date: Mon Feb 20 02:34:31 2006
Subject: [antlr-interest] Preserving ALL comments!
Message-ID: <43F99B33.8050703@fer.hr>

Hello,

We want to constuct AST for the Standard C programs
and to have ALL comments preserverd.

We started with StdCParser.g from examples
(we use CommonHiddenStreamToken, CommonASTWithHiddenTokens
and all the stuff)
and it works fine but not ALL the comments
seem to be present in the AST.

For example, for the following snippet:

/* comment1 */
main()  /* comment2  */
{
	printf("Hello");
}
/* comment3 */


only comment1 can be found in the AST.

It seems that comment2 is tied to RPAREN
and comment3 to RCURLY.
RPAREN and RCURLY are not included in the AST
and comment2 and comment3 are lost.

Am I right?
How to get ALL the comments in AST?

Thank you for your time.


Damir
From sunjigang1965 at yahoo.com.cn  Mon Feb 20 06:21:26 2006
From: sunjigang1965 at yahoo.com.cn (=?gb2312?q?=CB=EF=BC=CD=B8=D5=20Jigang=20(Robert)=20Sun?=)
Date: Mon Feb 20 06:21:34 2006
Subject: [antlr-interest] (no subject)
Message-ID: <20060220142126.10148.qmail@web15710.mail.cnb.yahoo.com>

Could anyone give an example fo making a linked list
using antlr?

My grammar is 
explist:
	exp (COMMA^<AST=ExpList> exp)*



	

	
		
___________________________________________________________ 
—≈ª¢1G√‚∑—” œ‰∞Ÿ∑÷∞Ÿ∑¿¿¨ª¯–≈ 
http://cn.mail.yahoo.com/
From sunjigang1965 at yahoo.com.cn  Mon Feb 20 06:23:16 2006
From: sunjigang1965 at yahoo.com.cn (=?gb2312?q?=CB=EF=BC=CD=B8=D5=20Jigang=20(Robert)=20Sun?=)
Date: Mon Feb 20 06:23:26 2006
Subject: [antlr-interest] Could anyone give an example fo making a linked
	list using antlr?
Message-ID: <20060220142316.10669.qmail@web15710.mail.cnb.yahoo.com>

Could anyone give an example fo making a linked list
using antlr?

My grammar is 
explist:
     exp (COMMA^<AST=ExpList> exp)*
     ;

Cheers!



	

	
		
___________________________________________________________ 
—≈ª¢1G√‚∑—” œ‰∞Ÿ∑÷∞Ÿ∑¿¿¨ª¯–≈ 
http://cn.mail.yahoo.com/
From antlr at jazillian.com  Mon Feb 20 07:05:47 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Mon Feb 20 07:05:50 2006
Subject: [antlr-interest] Preserving ALL comments!
In-Reply-To: <43F99B33.8050703@fer.hr>
References: <43F99B33.8050703@fer.hr>
Message-ID: <43F9DACB.5040004@jazillian.com>

Damir Kirasi? wrote:

> Hello,
>
> We want to constuct AST for the Standard C programs
> and to have ALL comments preserverd.
>
> We started with StdCParser.g from examples
> (we use CommonHiddenStreamToken, CommonASTWithHiddenTokens
> and all the stuff)
> and it works fine but not ALL the comments
> seem to be present in the AST.
>
> For example, for the following snippet:
>
> /* comment1 */
> main()  /* comment2  */
> {
>     printf("Hello");
> }
> /* comment3 */
>
>
> only comment1 can be found in the AST.
>
> It seems that comment2 is tied to RPAREN
> and comment3 to RCURLY.
> RPAREN and RCURLY are not included in the AST
> and comment2 and comment3 are lost.
>
> Am I right?
> How to get ALL the comments in AST?
>
> Thank you for your time.
>
>
> Damir
>
What I did was change the grammar to have it not discard
Whitespace, Newline, Comment, and CPPComment tokens.
Then, after lexing, I make a pass through the tokens, trying to
use the whitespace to figure out which piece of code each comment
really seems to go with. For example, your comment1 seems to
go with the "main" token, but if there had been a blank line
after it, it would "go with" the top of the file.

Also during this pass through the token list, I also remove all these
Whitespace, Newline, Comment, and CPPComment tokens.

Andy
From ewbank at gmail.com  Mon Feb 20 08:11:45 2006
From: ewbank at gmail.com (Bryan Ewbank)
Date: Mon Feb 20 08:11:49 2006
Subject: [antlr-interest] Could anyone give an example fo making a linked
	list using antlr?
In-Reply-To: <20060220142316.10669.qmail@web15710.mail.cnb.yahoo.com>
References: <20060220142316.10669.qmail@web15710.mail.cnb.yahoo.com>
Message-ID: <dd3a065f0602200811gba0c218hab573b75d0f10fd5@mail.gmail.com>

I'm guessing here that what you mean is a single node with all the
"exp" nodes under it, rather than a tree of COMMA nodes, each with two
children.

> Could anyone give an example for making a linked list using antlr?
>
> My grammar is
>	explist: exp (COMMA^<AST=ExpList> exp)* ;

This will, as you probably know, produce a left-to-right tree.

To produce a single-level tree, use this instead:

	explist: exp (COMMA! exp)* { ## = #( #[EXPLIST], ## ); }

To produce a right-to-left tree (for exponentiation, e.g.):

	explist : exp ( POWER^ explist )? ;
From ewbank at gmail.com  Mon Feb 20 08:28:26 2006
From: ewbank at gmail.com (Bryan Ewbank)
Date: Mon Feb 20 08:28:29 2006
Subject: [antlr-interest] conditional tree jumping,
In-Reply-To: <43f949a5.47925a1c.5694.ffffdf03SMTPIN_ADDED@mx.gmail.com>
References: <dd3a065f0602192030j3d1877ck3af8b9f102ab56dd@mail.gmail.com>
	<43f949a5.47925a1c.5694.ffffdf03SMTPIN_ADDED@mx.gmail.com>
Message-ID: <dd3a065f0602200828m16bafbf4m2be816ff447e2088@mail.gmail.com>

On 2/19/06, Craig Main <craig@palantir.co.za> wrote:
> How would you eliminate the else with the statement list?
> I am not quite sure what you mean here - I am still trying to wrap my brain
> around the tree matching syntax.
>
> Would you be in a position to give me a small example? I assume that you
> eliminate the node in the parser.

It will come to you; drawing the silly things helped me to see the problems and
ambiguities.  Let's see...  I'll sketch what I do, more or less...

To produce a clean IF node in the parser:

	stmt
	:
		( r:TOK_IF^ LP! expr RP! stmt ( TOK_ELSE! stmt { r.setType(TOK_IFELSE); } )?
		| ... other statement types here ...
		| stmtlist
		)
	;

	stmtlist : LCB! ( stmt )* RCB! { ## = #( #[STMTLIST], ## ); } ;

The ()? around the TOK_ELSE will cause a warning in ANTLR.  Setting the option
"greedy=true" for the ()? construct will bind ELSE to closest IF.

This produces a tree of two shapes; one for "if" alone, and one for "if/else":

	#(TOK_IF e1 s1)
	#(TOK_IFELSE e1 s1 s2)
	// e1 is the expression
	// s1 is the "if-branch" of the tree
	// s2 is the "else-branch", if present.

Now, you can write the tree parser rules to process e1, then select s1 (or s2)
based on the results.

In a similar vein, if you are implementing short-circuit &&/|| and ?: operators
(as C does), you need to be aware of the related situation and code for it:

	// oversimplified by assuming only boolean-valued expressions
	expr
	:
		( ...
		| #( ANDAND res=expr
			( { res==true  }? expr | .)	// eval e2 only when e1==true
		| #( OROR res=expr
			( { res==false }? expr | .)	// eval e2 only when e1==false
		| #( QUEST res=expr
			( { res==true }? res=expr .	// eval only e2 when e1==true
			| . res=expr			// ... otherwise, eval only e3
	 		)
	;
From Cyang at infobal.com  Mon Feb 20 10:50:39 2006
From: Cyang at infobal.com (Charlie Yang)
Date: Mon Feb 20 10:47:51 2006
Subject: [antlr-interest] question about tokenSet?
Message-ID: <96AD91D781CCD511A66000B0D0D15C4902CD3E0E@ibnet.infobal.com>

Hi,
  In the java code generated for the parser, I see statements like

  _tokenSet_1.member (LA (1))

And there are things like _tokenSet_2 and so on.

Does anybody know, what these tokenSets are and how they are created. 

Charlie
From seclib at seclib.com  Mon Feb 20 11:02:08 2006
From: seclib at seclib.com (Xue Yong Zhi)
Date: Mon Feb 20 11:02:58 2006
Subject: [antlr-interest] Re: question about tokenSet?
In-Reply-To: <96AD91D781CCD511A66000B0D0D15C4902CD3E0E@ibnet.infobal.com>
References: <96AD91D781CCD511A66000B0D0D15C4902CD3E0E@ibnet.infobal.com>
Message-ID: <dtd3nb$70n$1@sea.gmane.org>

Charlie Yang wrote:
> Hi,
>   In the java code generated for the parser, I see statements like
> 
>   _tokenSet_1.member (LA (1))
> 
> And there are things like _tokenSet_2 and so on.
> 
> Does anybody know, what these tokenSets are and how they are created. 
> 
> Charlie
> 

Check out:
http://www.antlr.org/doc/options.html#codeBitsetTestThreshold

-- 
Xue Yong Zhi
http://seclib.blogspot.com

From sunjigang1965 at yahoo.com.cn  Mon Feb 20 17:07:41 2006
From: sunjigang1965 at yahoo.com.cn (=?gb2312?q?=CB=EF=BC=CD=B8=D5=20Jigang=20(Robert)=20Sun?=)
Date: Mon Feb 20 17:34:31 2006
Subject: =?gb2312?q?Re=A3=BA=20Re:=20[antlr-interest]=20Could=20anyone=20give=20an?=
	=?gb2312?q?=20example=20fo=20making=20a=20linked=20list=20using=20antlr=3F?=
In-Reply-To: <dd3a065f0602200811gba0c218hab573b75d0f10fd5@mail.gmail.com>
Message-ID: <20060221010741.71253.qmail@web15706.mail.cnb.yahoo.com>

Thank you Bryan.

Your solution works. But I could not find explanation
for ## in Tree Construction section of Antlr 2.7.6
manual. Could anyone tell me the reference address?

Jigang 

--- Bryan Ewbank <ewbank@gmail.com>Wrote:

> I'm guessing here that what you mean is a single
> node with all the
> "exp" nodes under it, rather than a tree of COMMA
> nodes, each with two
> children.
> 
> > Could anyone give an example for making a linked
> list using antlr?
> >
> > My grammar is
> >	explist: exp (COMMA^<AST=ExpList> exp)* ;
> 
> This will, as you probably know, produce a
> left-to-right tree.
> 
> To produce a single-level tree, use this instead:
> 
> 	explist: exp (COMMA! exp)* { ## = #( #[EXPLIST], ##
> ); }
> 
> To produce a right-to-left tree (for exponentiation,
> e.g.):
> 
> 	explist : exp ( POWER^ explist )? ;
> 



	

	
		
___________________________________________________________ 
—≈ª¢1G√‚∑—” œ‰∞Ÿ∑÷∞Ÿ∑¿¿¨ª¯–≈ 
http://cn.mail.yahoo.com/
From kroepke at dolphin-services.de  Mon Feb 20 18:05:49 2006
From: kroepke at dolphin-services.de (Kay Roepke)
Date: Mon Feb 20 18:05:56 2006
Subject: =?UTF-8?Q?Re:_Re=EF=BC=9A_Re:_[antlr-interest]_Could_anyone_give?=
	=?UTF-8?Q?_an_example_fo_making_a_linked_list_using_antlr=3F?=
In-Reply-To: <20060221010741.71253.qmail@web15706.mail.cnb.yahoo.com>
References: <20060221010741.71253.qmail@web15706.mail.cnb.yahoo.com>
Message-ID: <007A1A87-2379-44D0-A284-7BA770033A34@dolphin-services.de>


On 21. Feb 2006, at 2:07 Uhr, ??? Jigang (Robert) Sun wrote:

> Thank you Bryan.
>
> Your solution works. But I could not find explanation
> for ## in Tree Construction section of Antlr 2.7.6
> manual. Could anyone tell me the reference address?
>
> Jigang


Hi!
Take a look at this posting from Bryan (posted on October 29th,2005)
Thread starts at: http://www.antlr.org/pipermail/antlr-interest/ 
2005-October/014144.html

HTH,
Kay

On 10/29/05, Suman Karumuri <mansuk@gmail.com> wrote:

> Hi ,
>
> 1) Can anyone explain me what this action does. I have taken this
> example from the calc.g file in antlr examples.
>
> expr :  expr1        { ## = #(#[EXPR,"expr"],##); }    ;
>

This means
(1) Create a new EXPR node
(2) Place the current version of the output tree for this rule
     as the only child of that node
(3) Use that new tree as the output tree for this rule

From kroepke at dolphin-services.de  Mon Feb 20 19:35:42 2006
From: kroepke at dolphin-services.de (Kay Roepke)
Date: Mon Feb 20 19:35:49 2006
Subject: =?UTF-8?Q?Re:_Re=EF=BC=9A_Re:_[antlr-interest]_Could_anyone_give?=
	=?UTF-8?Q?_an_example_fo_making_a_linked_list_using_antlr=3F?=
In-Reply-To: <20060221010741.71253.qmail@web15706.mail.cnb.yahoo.com>
References: <20060221010741.71253.qmail@web15706.mail.cnb.yahoo.com>
Message-ID: <3035045B-1F4E-4EC8-94D7-BF1813340A36@dolphin-services.de>


On 21. Feb 2006, at 2:07 Uhr, ??? Jigang (Robert) Sun wrote:

> Could anyone tell me the reference address?

BTW also have a look at http://www.antlr.org/article/1137964510001/ 
manual.tree.construction.txt

-k
From vs667 at nyu.edu  Mon Feb 20 19:39:07 2006
From: vs667 at nyu.edu (Vladimir S.)
Date: Mon Feb 20 19:39:34 2006
Subject: [antlr-interest] C# .NET 2.0 'antlr.ASTPair' does not contain a
 definition for 'GetInstance' and PutInstance
Message-ID: <43FA8B5B.1010506@nyu.edu>

I am having some issue compiling the C# parser generated by antrl in 
Visual Studio 2005.
I have build the antlr.runtime.dll successfully and referenced it in my 
project, but for some reason I get the
'antlr.ASTPair' does not contain a definition for 'GetInstance' and 
antlr.ASTPair' does not contain a definition for 'PutInstance' error.

I have tried this with every C# examples provided. The 
ASTPair.GetInstance() and ASTPair.PutInstance() do not seem to exist in 
the antlr.runtime.dll

Thanks for any feedback.
Vladimir Sutskever
From damir.kirasic at fer.hr  Mon Feb 20 23:36:24 2006
From: damir.kirasic at fer.hr (=?ISO-8859-2?Q?Damir_Kirasi=E6?=)
Date: Mon Feb 20 23:36:30 2006
Subject: [antlr-interest] Preserving ALL comments!
References: 43F99B33.8050703@fer.hr
Message-ID: <43FAC2F8.5040004@fer.hr>

Thank you for your answer.

Yes, what you suggest is all right but
it requires a lot of work. Completely new
layer between lexer and parser.
And we already have that hidden channels and hidden
objects that are supposed to solve such problems.

Any easier solution?

Damir

From jens.bartelheimer at gmx.de  Mon Feb 20 23:47:54 2006
From: jens.bartelheimer at gmx.de (Jens Bartelheimer)
Date: Mon Feb 20 23:48:00 2006
Subject: [antlr-interest] Lexer exception?
In-Reply-To: <013f01c63608$477c13f0$8cc79553@marlboro>
References: <000701c635ec$6e6589e0$8cc79553@marlboro> <43F99062.3010906@gmx.de>
	<013f01c63608$477c13f0$8cc79553@marlboro>
Message-ID: <43FAC5AA.3020409@gmx.de>

Thanks for your help. Your are right. It is an error raised by the 
parser. And if I set the option defaultErrorHandler=false in the options 
of the parser I can catch the exception. Thanks, Jens

Alexey Demakov wrote:
> As far as I know defaultErrorHandler = false causes lexer
> to throw TokenStreamException. By default parser catches 
> RecognitionException only,
> so parser will pass TokenStreamException without any messages.
>
> I think
>
> line 1:1: unexpected token: 111
>
> caused by error in parser not in lexer. It looks like default parser 
> error message.
> If 111 is valid token, there is no error in lexer. If file can't start 
> from
> this token, it is parser error.
>
> Regards,
> Alexey
>
> -----
> Alexey Demakov
> TreeDL: Tree Description Language: http://treedl.sourceforge.net
> RedVerst Group: http://www.unitesk.com
>
>
> ----- Original Message ----- From: "Jens Bartelheimer" 
> <jens.bartelheimer@gmx.de>
> To: "Alexey Demakov" <demakov@ispras.ru>
> Cc: "antlr-interest" <antlr-interest@antlr.org>
> Sent: Monday, February 20, 2006 12:48 PM
> Subject: Re: [antlr-interest] Lexer exception?
>
>
>> Ok, this method solves the problem if the option is set to true.
>>
>> As Martin mentioned I have to set this option to false but there are 
>> no additional exceptions. I think this is idependent from the bug in 
>> antlr. Am I right? I also do not want to skip the malformed token, I 
>> only need an exception so that I can recognize the wrong input  if  I 
>> call the parser. Further I do not need the printing of the message 
>> "line 1:1: unexpected token: 111". Is this only possible with the 
>> $skipToken....?
>>
>> Thanks,
>> Jens
>>
>> Alexey Demakov wrote:
>>> Hi Jens,
>>>
>>> Aa I wrote recently, it is the bug in antlr.
>>> http://www.antlr.org/pipermail/antlr-interest/2006-February/015417.html 
>>>
>>>
>>> Define this method in your lexer code:
>>>
>>> public void recover( RecognitionException ex, BitSet tokenSet ) 
>>> throws CharStreamException {
>>>  saveConsumedInput = false;  consume();
>>>  consumeUntil( tokenSet );
>>>  saveConsumedInput = true; }
>>>
>>> But if you want completly skip malformed token, you have to define 
>>> custom exception handler
>>> with $setType( Token.SKIP ) for each lexer rule. :(
>>>
>>> ---
>>> Alexey Demakov
>>> TreeDL: Tree Description Language: http://treedl.sourceforge.net
>>> RedVerst Group: http://www.unitesk.com
>>>
>>>
>>> From: "Jens Bartelheimer" <jens.bartelheimer@gmx.de>
>>>> Hi Martin,
>>>>
>>>> thanks for your reply but if I turn off the option there are no 
>>>> additional exceptions.
>>>>
>>>> If I turn it on explicit I have the following error in the Lexer:
>>>>
>>>> My error message:
>>>> The method recover(RecognitionException, BitSet) is undefined for 
>>>> the type UMLLexer
>>>>
>>>> Why? Is there a mistake in my Lexer?
>>>>
>>>> Jens
>>>>
>>>>
>>>> Martin Probst wrote:
>>>> >> how can I catch such an exception? I do not found something in 
>>>> the >> documentation.
>>>> >>
>>>> >> line 1:1: unexpected token: 111
>>>> >>     >
>>>> > You have to turn off the default error handler, e.g. in your options
>>>> > section of the lexer "defaultErrorHandler = false". Afterwards 
>>>> you can
>>>> > catch exceptions. All of them extend ANTLRException, the manual 
>>>> contains
>>>> > a part called "Exception hierarchy".
>>>
>>>
>>>
>
>
From sunjigang1965 at yahoo.com.cn  Tue Feb 21 03:34:51 2006
From: sunjigang1965 at yahoo.com.cn (=?gb2312?q?=CB=EF=BC=CD=B8=D5=20Jigang=20(Robert)=20Sun?=)
Date: Tue Feb 21 03:35:01 2006
Subject: =?gb2312?q?=BB=D8=B8=B4=A3=BA=20[antlr-interest]=20C#=20.NET=202.0=20'ant?=
	=?gb2312?q?lr.ASTPair'=20does=20not=20contain=20a=20definition=20for=20'G?=
	=?gb2312?q?etInstance'=20and=20PutInstance?=
In-Reply-To: <43FA8B5B.1010506@nyu.edu>
Message-ID: <20060221113451.75310.qmail@web15706.mail.cnb.yahoo.com>

Similar strange windows poped up a couple of weeks
ago. The error I met was that ASTPair could not be
found in the project. I moved antlr 2.7.6 files on to
root of C: drive and kept ist directory name
unchanged(default directory name), i.e.
"C:\antlr-2.7.6". Maybe adding using assembly
directives does help. The compiler I am using is C#
2005 Express. I hope this could be a hint. 

Jigang 

--- "Vladimir S." <vs667@nyu.edu>–¥µ¿:

> I am having some issue compiling the C# parser
> generated by antrl in 
> Visual Studio 2005.
> I have build the antlr.runtime.dll successfully and
> referenced it in my 
> project, but for some reason I get the
> 'antlr.ASTPair' does not contain a definition for
> 'GetInstance' and 
> antlr.ASTPair' does not contain a definition for
> 'PutInstance' error.
> 
> I have tried this with every C# examples provided.
> The 
> ASTPair.GetInstance() and ASTPair.PutInstance() do
> not seem to exist in 
> the antlr.runtime.dll
> 
> Thanks for any feedback.
> Vladimir Sutskever
> 



	

	
		
___________________________________________________________ 
—≈ª¢1G√‚∑—” œ‰∞Ÿ∑÷∞Ÿ∑¿¿¨ª¯–≈ 
http://cn.mail.yahoo.com/
From open.zone at virgin.net  Tue Feb 21 07:15:30 2006
From: open.zone at virgin.net (Micheal J)
Date: Tue Feb 21 06:58:52 2006
Subject: [antlr-interest] C# .NET 2.0 'antlr.ASTPair' does not contain a
	definition for 'GetInstance' and PutInstance
In-Reply-To: <43FA8B5B.1010506@nyu.edu>
Message-ID: <000d01c636f9$a7fc6350$6502a8c0@hercules>

Vladimir,
 
> I am having some issue compiling the C# parser generated by antrl in 
> Visual Studio 2005.
> I have build the antlr.runtime.dll successfully and 
> referenced it in my 
> project, but for some reason I get the
> 'antlr.ASTPair' does not contain a definition for 'GetInstance' and 
> antlr.ASTPair' does not contain a definition for 'PutInstance' error.

ASTPair contained those methods in ANTLR 2.7.5. You need to process your
grammar files with the ANTLR tool in version 2.7.6 to regenerate your C#
source code files. Then reference the runtime assembly dlls from 2.7.6 in
your project.

> I have tried this with every C# examples provided. The 
> ASTPair.GetInstance() and ASTPair.PutInstance() do not seem 
> to exist in 
> the antlr.runtime.dll

That is right. They no longer exist in ANTLR 2.7.6. It's documented in the
changelog.

You seem to have an enviroment that mixes ANTLR 2.7.5 and ANTLR 2.7.6. That
won't work as you've found out.


Cheers,

Micheal


PS	What are you using ANTLR/C# for?

From antlr at jazillian.com  Tue Feb 21 08:36:14 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Tue Feb 21 08:36:15 2006
Subject: [antlr-interest] Preserving ALL comments!
In-Reply-To: <43FAC2F8.5040004@fer.hr>
References: 43F99B33.8050703@fer.hr <43FAC2F8.5040004@fer.hr>
Message-ID: <43FB417E.3050906@jazillian.com>

Damir Kirasi? wrote:

> Thank you for your answer.
>
> Yes, what you suggest is all right but
> it requires a lot of work. Completely new
> layer between lexer and parser.
> And we already have that hidden channels and hidden
> objects that are supposed to solve such problems.
>
> Any easier solution?
>
> Damir
>
To just remove comments/whitespace shouldn't be more than a few lines of 
code. Just loop through the List
of tokens, removing all the ones of type Newline, Whitespace, Comment, 
and CPPComment. I wouldn't call
that a whole "layer", just a few lines of code that you'd quickly write 
in Java (or whatever) that will accomplish
what you want.

And the hidden channels seem like the wrong solution...they split the 
comments and whitespace into
a separate stream of tokens to be independently processed. But if you 
really want to know which
comments go with which code, you can't do your processing independently. 
You need to treat
the comments and whitespace in the context of the stream of "real" tokens.
From sohail at taggedtype.net  Tue Feb 21 09:13:25 2006
From: sohail at taggedtype.net (sohail@taggedtype.net)
Date: Tue Feb 21 09:13:35 2006
Subject: [antlr-interest] Preserving ALL comments!
In-Reply-To: <43FB417E.3050906@jazillian.com>
References: 43F99B33.8050703@fer.hr <43FAC2F8.5040004@fer.hr>
	<43FB417E.3050906@jazillian.com>
Message-ID: <46762.127.0.0.1.1140542005.squirrel@taggedtype.net>

>> And we already have that hidden channels and hidden
>> objects that are supposed to solve such problems.
>>
>> Any easier solution?
>
> And the hidden channels seem like the wrong solution...they split the
> comments and whitespace into
> a separate stream of tokens to be independently processed. But if you
> really want to know which
> comments go with which code, you can't do your processing independently.
> You need to treat
> the comments and whitespace in the context of the stream of "real" tokens.

Very well put. You can't do language translation + comments without making
comments part of your representation.


From Jeff.Barnes at codesic.com  Tue Feb 21 12:32:06 2006
From: Jeff.Barnes at codesic.com (Jeff Barnes)
Date: Tue Feb 21 12:31:26 2006
Subject: Making part of representation WAS RE: [antlr-interest] Preserving ALL
	comments!
References: 43F99B33.8050703@fer.hr <43FAC2F8.5040004@fer.hr>
	<43FB417E.3050906@jazillian.com>
	<46762.127.0.0.1.1140542005.squirrel@taggedtype.net>
Message-ID: <FC6B2BF8B2FE854EAE0C380E55CA5734119D80@hq-app2.CODESIC.COM>

> Very well put. You can't do language translation + comments without making
> comments part of your representation.

Uh, oh...
 
I think I'm painting myself into a corner.
 
This thread is beginning to sound eerily familiar :)
 
I'm parsing a lisp-style file format that looks something like this
 
...
 
(object Class_Category "Logical View"
 quid        "43BB1622020D"
 exportControl  "Public"
 global      TRUE
 subsystem   "Component View"
 quidu       "43BB16A90015"
 logical_models  (list unit_reference_list
     (object Class "NewClass3"
  quid        "43BB1E27029B"
  stereotype  "Actor"))
 
...
 
My lexer symbols are the STRING, INT, BOOLEAN primitive stuff and such. For example,
BOOLEAN:
    "TRUE" | "FALSE" | "true" | "false"
;
    
COMMA:
    ","
;
    
protected
DIGIT:
    '0'..'9'
;
 
My parser symbols are the meta symbols (object, list, attribute, etc.). For example,
 
object
{
}
:
    LPAREN! OBJECT^
    typeid:ID 
    (
        param
    )*
    (
        attribute
    )* 
    RPAREN!
;
 
Now I'm at the tree phase and finding out there may be some serious brute force involved.
 
It looks like I'm faced with the alternative of instantiating the meta meta model (creating the instances of object, list, etc) with a StringTemplate or write custom tree navigation code to instantiate the meta model (Class_Category, Class).
 
Which one is the least amount of work?
 
Regards,
Jeff
 
From fitztaylor at gmail.com  Tue Feb 21 16:09:53 2006
From: fitztaylor at gmail.com (Neil Fitzpatrick)
Date: Tue Feb 21 16:09:55 2006
Subject: [antlr-interest] v3 - limit on number of rules in lexer with
	MAX_STATES_PER_DFA = 1000?
Message-ID: <28d796dd0602211609hef3fe6udc382b7694ca9968@mail.gmail.com>

Hi,

I've been building up a simple grammar in antlr3 which has a fairly large
number of keywords (around 100 so far).  I've now hit a point where if I had
one more keyword to the lexer.g the generation of the lexer fails in the
NFAToDFAConverter where it hits the 1000 limit for MAX_STATES_PER_DFA.

I've recompiled with an increased limit and this fixes the problem but I'm
not sure if this is a bug in v3 or me doing something stupid in the lexer
grammar.  Any ideas?

Thanks, Neil
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060222/23d197e1/attachment.html
From greenj at ix.netcom.com  Tue Feb 21 16:30:07 2006
From: greenj at ix.netcom.com (John Green)
Date: Tue Feb 21 16:30:12 2006
Subject: [antlr-interest] VC++ 7.1
Message-ID: <43FBB08F.2080105@ix.netcom.com>

Hi Ric,

With MSVC++ 7.1 I had to make a couple of small hacks.

In config.hpp:
// Added by jag. See comments for ver < 1310.
# if ( _MSC_VER < 1320 )
#	define NO_STATIC_CONSTS
# endif


In TokenStreamRewriteEngine.cpp:
// jag added ifndef
#ifndef NO_STATIC_CONSTS
const size_t TokenStreamRewriteEngine::MIN_TOKEN_INDEX = 0;
const int TokenStreamRewriteEngine::PROGRAM_INIT_SIZE = 100;
#endif


Seems to be compiling and running fine now.

Cheers,
john at joanju dot com


BTW all, just in case anyone else is worried about performance and the MSVC compiler, I tried updating to VC++ 8, and found that my parser ended up being 25% slower. I've switched back to 7.1 for now. Searching MSDN forums found a few other complaints about performance regression, and some possible explanations for it.
From parrt at cs.usfca.edu  Tue Feb 21 18:45:08 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Tue Feb 21 18:45:00 2006
Subject: [antlr-interest] v3 - limit on number of rules in lexer with
	MAX_STATES_PER_DFA = 1000?
In-Reply-To: <28d796dd0602211609hef3fe6udc382b7694ca9968@mail.gmail.com>
References: <28d796dd0602211609hef3fe6udc382b7694ca9968@mail.gmail.com>
Message-ID: <E3028AEB-C636-4590-A934-B8E7FDA00434@cs.usfca.edu>

On Feb 21, 2006, at 4:09 PM, Neil Fitzpatrick wrote:
> Hi,
>
> I've been building up a simple grammar in antlr3 which has a fairly  
> large number of keywords (around 100 so far).  I've now hit a point  
> where if I had one more keyword to the lexer.g the generation of  
> the lexer fails in the NFAToDFAConverter where it hits the 1000  
> limit for MAX_STATES_PER_DFA.

I have improved this algorithm...

> I've recompiled with an increased limit and this fixes the problem  
> but I'm not sure if this is a bug in v3 or me doing something  
> stupid in the lexer grammar.  Any ideas?

ea8 fixes this...have no fear. :)  Want a tarball?

Ter
From damir.kirasic at fer.hr  Wed Feb 22 00:50:16 2006
From: damir.kirasic at fer.hr (=?UTF-8?B?RGFtaXIgS2lyYXNpxIc=?=)
Date: Wed Feb 22 00:50:24 2006
Subject: [antlr-interest] Preserving ALL comments!
References: 43FAC2F8.5040004@fer.hr
Message-ID: <43FC25C8.6020409@fer.hr>

 >To just remove comments/whitespace shouldn't be more than a few lines >of
 >code. Just loop through the List
 >of tokens, removing all the ones of type Newline, Whitespace, Comment,
 >and CPPComment. I wouldn't call
 >that a whole "layer", just a few lines of code that you'd quickly write
 >in Java (or whatever) that will accomplish
 >what you want.

 >And the hidden channels seem like the wrong solution...they split the
 >comments and whitespace into
 >a separate stream of tokens to be independently processed. But if you
 >really want to know which
 >comments go with which code, you can't do your processing >independently.
 >You need to treat
 >the comments and whitespace in the context of the stream of "real" 
 >tokens.


We agree that it is easy to remove all Newline, Whitespace and Comment 
from the token stream.
Our problem is that we don't know is how to "programmatically" determine 
which comment goes with which code.
So far, our main objective was to have comments attached as hidden 
tokens to the corresponding nodes in the AST. And at the same time we 
would NOT like to change the grammar file.
For example if we have:
	?
	main()   /* comment2 */
	?
comment2 has to be "reassigned" not to BLANK, not to RPAREN but to ID 
because, according to AST construction from grammar, neither BLANK nor 
RPAREN will be present in the AST.  So, it seems that we have to know 
(from inspecting grammar and AST construction) that RPAREN will not be 
in the AST and skip it as we already skipped the BLANK token.
As far as we can see it, if a comment goes with a token that will not be 
present in the AST,
we have to go back and reassign given comment to next token (which will 
be present in the AST). And yet, we don't know if that new candidate 
token will be present in the AST.

Is it possible? Are we asking too much?
Should we reformulate our objective? (To preserve comments as HIDDEN 
tokens attached to "normal" AST nodes).

Thank you for your answer(s).

Damir


From matthias.gutheil at informatik.uni-mannheim.de  Wed Feb 22 04:12:09 2006
From: matthias.gutheil at informatik.uni-mannheim.de (Matthias Gutheil)
Date: Wed Feb 22 04:17:18 2006
Subject: [antlr-interest] Problem with Java Grammar (Comments at the end)
Message-ID: <43FC5519.3070502@informatik.uni-mannheim.de>

Hello,

just to inform.

I am using the Java 1.5 grammar.

http://www.antlr.org/grammar/1090713067533/index.html

When testing it with

class test {
}
/**

It gives an out of memory error. The problem is the comment at the end.

Matthias


-- 
Matthias Gutheil, Dipl. Inform.
Universit?t Mannheim
Lehrstuhl f?r Softwaretechnik
A5, 6, Geb?udeteil B
68131 Mannheim
Germany

E-Mail: matthias.gutheil@informatik.uni-mannheim.de
Tel: (+49) 621 181 3913

From fitztaylor at gmail.com  Wed Feb 22 05:39:30 2006
From: fitztaylor at gmail.com (Neil Fitzpatrick)
Date: Wed Feb 22 05:39:37 2006
Subject: [antlr-interest] v3 - limit on number of rules in lexer with
	MAX_STATES_PER_DFA = 1000?
In-Reply-To: <E3028AEB-C636-4590-A934-B8E7FDA00434@cs.usfca.edu>
References: <28d796dd0602211609hef3fe6udc382b7694ca9968@mail.gmail.com>
	<E3028AEB-C636-4590-A934-B8E7FDA00434@cs.usfca.edu>
Message-ID: <28d796dd0602220539m3c7f8525ld99c6d3db0634e8d@mail.gmail.com>

On 2/22/06, Terence Parr <parrt@cs.usfca.edu> wrote:
> On Feb 21, 2006, at 4:09 PM, Neil Fitzpatrick wrote:
> > Hi,
> >
> > I've been building up a simple grammar in antlr3 which has a fairly
> > large number of keywords (around 100 so far).  I've now hit a point
> > where if I had one more keyword to the lexer.g the generation of
> > the lexer fails in the NFAToDFAConverter where it hits the 1000
> > limit for MAX_STATES_PER_DFA.
>
> I have improved this algorithm...
>
> > I've recompiled with an increased limit and this fixes the problem
> > but I'm not sure if this is a bug in v3 or me doing something
> > stupid in the lexer grammar.  Any ideas?
>
> ea8 fixes this...have no fear. :)  Want a tarball?

Yes please - that would be great.  v3 is looking fantastic btw - ll(*)
plus antlrworks is working really well for me - a non-expert user
slightly out of their depth trying to write a grammar for an old
4GL... :)  Thanks, Neil

>
> Ter
>
From antlr at jazillian.com  Wed Feb 22 06:26:34 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Wed Feb 22 06:26:34 2006
Subject: [antlr-interest] Preserving ALL comments!
In-Reply-To: <43FC25C8.6020409@fer.hr>
References: 43FAC2F8.5040004@fer.hr <43FC25C8.6020409@fer.hr>
Message-ID: <43FC749A.8000603@jazillian.com>

Damir Kirasi? wrote:

>
> We agree that it is easy to remove all Newline, Whitespace and Comment 
> from the token stream.
> Our problem is that we don't know is how to "programmatically" 
> determine which comment goes with which code.
> So far, our main objective was to have comments attached as hidden 
> tokens to the corresponding nodes in the AST. And at the same time we 
> would NOT like to change the grammar file.
> For example if we have:
>     ?
>     main()   /* comment2 */
>     ?
> comment2 has to be "reassigned" not to BLANK, not to RPAREN but to ID 
> because, according to AST construction from grammar, neither BLANK nor 
> RPAREN will be present in the AST.  So, it seems that we have to know 
> (from inspecting grammar and AST construction) that RPAREN will not be 
> in the AST and skip it as we already skipped the BLANK token.
> As far as we can see it, if a comment goes with a token that will not 
> be present in the AST,
> we have to go back and reassign given comment to next token (which 
> will be present in the AST). And yet, we don't know if that new 
> candidate token will be present in the AST.
>
> Is it possible? Are we asking too much?
> Should we reformulate our objective? (To preserve comments as HIDDEN 
> tokens attached to "normal" AST nodes).
>
> Thank you for your answer(s).
>
> Damir
>
Yes, it is possible. This is exactly the problem that I had to solve.
See /"Preserving the Documentary Structure of Source Code in 
Language-based transformation Tools"/ by Michael L. Van De Vanter at Sun 
Laboratories, which talks about the same issue.

What I do is just before stripping out the comment/newline/whitespace 
tokens, I give each physical line of input a
"loose description" (e.g. "declaration of variable i", "a for 
statement", "a comment", etc). Then, later, after translation is
done, I attempt to put each comment back with the line that it seemed to 
"got with" at the start. I can send you more
details from my top-secret-highly-classified design document in email if 
you'd like :)

Andy

From sunjigang1965 at yahoo.com.cn  Wed Feb 22 06:52:05 2006
From: sunjigang1965 at yahoo.com.cn (=?gb2312?q?=CB=EF=BC=CD=B8=D5=20Jigang=20(Robert)=20Sun?=)
Date: Wed Feb 22 06:52:11 2006
Subject: [antlr-interest] I wish a dummy token is accepted by antlr
Message-ID: <20060222145205.51649.qmail@web15705.mail.cnb.yahoo.com>

I want make a tree with root node type as
<AST=MiniJava.Formal>; dataType as first child; ID, to
be constructed as <AST=MiniJava.Identifier>,as
nextSibling. The following grammar is not recognised:

formal
	:
	dataType ID^ <AST=MiniJava.Identifier>
<AST=MiniJava.Formal>
       ;

So I added actions:

formal
	:
	dataType
	{	
	    MiniJava.Identifier id_AST = null;
            id_AST =
(MiniJava.Identifier)astFactory.create(LT(1),
"MiniJava.Identifier");
            astFactory.addASTChild(ref currentAST,
(AST)id_AST);

	} ID^ <AST=MiniJava.Formal>
	;


Got the following code:

		returnAST = null;
		ASTPair currentAST = new ASTPair();
		AST formal_AST = null;
		
		try {      // for error handling
			dataType();
			astFactory.addASTChild(ref currentAST, returnAST);
				
			MiniJava.Identifier id_AST = null;
			id_AST =
(MiniJava.Identifier)astFactory.create(LT(1),
"MiniJava.Identifier");
			astFactory.addASTChild(ref currentAST,
(AST)id_AST);
			
					
			MiniJava.Formal tmp2_AST = null;
			tmp2_AST = (MiniJava.Formal)
astFactory.create(LT(1), "MiniJava.Formal");
			astFactory.makeASTRoot(ref currentAST,
(AST)tmp2_AST);
			match(ID);
			formal_AST = currentAST.root;
		}
		catch (RecognitionException ex)
		{
			reportError(ex);
			recover(ex,tokenSet_1_);
		}
		returnAST = formal_AST;



I wish a dummy token is accepted by antlr, then I
could use 

formal
	:
	dataType ID <AST=MiniJava.Identifier> DUMMY^ 
<AST=MiniJava.Formal>
       ;

to get my tree.

Does anyone have better solutions?




Reference:

dataType
	:
	 "int"! LSQUARE! RSQUARE <AST=MiniJava.IntArrayType>
	| "int" <AST=MiniJava.IntegerType >
	| "boolean" <AST=MiniJava.BooleanType>
	|  ID <AST=MiniJava.IdentifierType>
	;



__________________________________________________
∏œøÏ◊¢≤·—≈ª¢≥¨¥Û»›¡ø√‚∑—” œ‰?
http://cn.mail.yahoo.com
From Cyang at infobal.com  Wed Feb 22 09:01:52 2006
From: Cyang at infobal.com (Charlie Yang)
Date: Wed Feb 22 08:59:12 2006
Subject: [antlr-interest] [BULK] question about how to store
	variable/procedure definitions and retrieve back for Oracle
Message-ID: <96AD91D781CCD511A66000B0D0D15C4902CD3E16@ibnet.infobal.com>

Hi, All:

Now I'm working on an Oracle parser.

 I  think Oracle's syntax is kind of sick. Say, if call a procedure without
any parameters, just use the procedure name, even without a pair of
parentheses. without looking back from definitions, i don't know it is an
identifer or a function call.

For example:
...
lp_close_file;		// lp_close_file defined as local procedure  before 
...

so the statement is context-sensitive.  Can I store variable/procedure
definitions into antlr grammar and retrieve back to determine  the token is
procedure or variable.  or there is another way abround?

Charlie


From kroepke at dolphin-services.de  Wed Feb 22 09:09:40 2006
From: kroepke at dolphin-services.de (Kay Roepke)
Date: Wed Feb 22 09:09:45 2006
Subject: [antlr-interest] [BULK] question about how to store
	variable/procedure definitions and retrieve back for Oracle
In-Reply-To: <96AD91D781CCD511A66000B0D0D15C4902CD3E16@ibnet.infobal.com>
References: <96AD91D781CCD511A66000B0D0D15C4902CD3E16@ibnet.infobal.com>
Message-ID: <BD937E4E-12AD-4F6C-9D55-0225BDC16391@dolphin-services.de>


On 22. Feb 2006, at 18:01 Uhr, Charlie Yang wrote:

> Can I store variable/procedure
> definitions into antlr grammar and retrieve back to determine  the  
> token is
> procedure or variable.  or there is another way abround?

You'll need to build a symbol table using actions and then use  
predicates to achieve this, but that is expected.
Refer to the list archives, I think this has been covered in much  
more detail, than I could give you right now :)

HTH,

Kay
From ewbank at gmail.com  Wed Feb 22 09:21:47 2006
From: ewbank at gmail.com (Bryan Ewbank)
Date: Wed Feb 22 09:22:34 2006
Subject: [antlr-interest] I wish a dummy token is accepted by antlr
In-Reply-To: <20060222145205.51649.qmail@web15705.mail.cnb.yahoo.com>
References: <20060222145205.51649.qmail@web15705.mail.cnb.yahoo.com>
Message-ID: <dd3a065f0602220921x18d63b00n2d4ccf5639271b7a@mail.gmail.com>

SSB0aGluayB3aGF0IHlvdSB3YW50IGlzIHNvbWV0aGluZyBsaWtlIHRoaXM6Cgpmb3JtYWw6CiAg
ICBkYXRhVHlwZSBJRF4gPEFTVD1NaW5pSmF2YS5JZGVudGlmaWVyPgogICAgeyAjIyA9ICMoICNb
Li4uXSwgIyMgKTsgfQogICAgOwoKSSBkb24ndCBrbm93IHdoYXQgZ29lcyBpbiB0aGUgIi4uLiIs
IGFib3ZlLCB0byBtYWtlIHRoaXMgYQpNaW5pSmF2YS5Gb3JtYWwgbm9kZSAtLSBJIGRvbid0IHVz
ZSBoZXRlcm9nZW5lb3VzIHRyZWVzIC0tIGJ1dCB0aGlzCnN5bnRheCBidWlsZHMgdGhlIHRocmVl
LW5vZGUgdHJlZSB0aGF0IEkgdGhpbmsgeW91IGFyZSBhaW1pbmcgYXQuCgoKT24gMi8yMi8wNiwg
y++8zbjVIEppZ2FuZyAoUm9iZXJ0KSBTdW4gPHN1bmppZ2FuZzE5NjVAeWFob28uY29tLmNuPiB3
cm90ZToKPiBJIHdhbnQgbWFrZSBhIHRyZWUgd2l0aCByb290IG5vZGUgdHlwZSBhcwo+IDxBU1Q9
TWluaUphdmEuRm9ybWFsPjsgZGF0YVR5cGUgYXMgZmlyc3QgY2hpbGQ7IElELCB0bwo+IGJlIGNv
bnN0cnVjdGVkIGFzIDxBU1Q9TWluaUphdmEuSWRlbnRpZmllcj4sYXMKPiBuZXh0U2libGluZy4g
VGhlIGZvbGxvd2luZyBncmFtbWFyIGlzIG5vdCByZWNvZ25pc2VkOgo+Cj4gZm9ybWFsOgo+ICAg
IGRhdGFUeXBlIElEXiA8QVNUPU1pbmlKYXZhLklkZW50aWZpZXI+IDxBU1Q9TWluaUphdmEuRm9y
bWFsPgo+IDsK
From open.zone at virgin.net  Wed Feb 22 10:24:50 2006
From: open.zone at virgin.net (Micheal J)
Date: Wed Feb 22 10:08:13 2006
Subject: [antlr-interest] I wish a dummy token is accepted by antlr
In-Reply-To: <20060222145205.51649.qmail@web15705.mail.cnb.yahoo.com>
Message-ID: <002e01c637dd$46b2c960$6502a8c0@hercules>

Robert,

> I want make a tree with root node type as 
> <AST=MiniJava.Formal>; dataType as first child; ID, to be 
> constructed as <AST=MiniJava.Identifier>,as nextSibling. The 
> following grammar is not recognised:
> 
> formal
> 	:
> 	dataType ID^ <AST=MiniJava.Identifier>
> <AST=MiniJava.Formal>
>        ;

This should do the trick:

formal!
    :	dt:dataType id:ID<AST=MiniJava.Identifier>
	{
		## = #( #[MJ_FORMAL, "MJ_FORMAL", "MiniJava.Formal"], #dt,
#id );
	}

I'm assuming that MJ_FORMAL is a valid token type for your grammar. If not,
define it in the tokens sections.

=========================

This is simpler and might/should also work actually (at least for the C#
you're using):

tokens 
{
   ....
   MJ_FORMAL<AST=MiniJava.Formal>;
   ....
}

formal!
    :	dt:dataType id:ID<AST=MiniJava.Identifier>
	{
		## = #( #[MINI_JAVA_FORMAL, "MINI_JAVA_FORMAL"], #dt, #id );
	}


Cheers,

Micheal
ANTLR/C#

From brannonking at yahoo.com  Wed Feb 22 10:12:34 2006
From: brannonking at yahoo.com (Brannon King)
Date: Wed Feb 22 10:11:57 2006
Subject: [antlr-interest] I wish a dummy token is accepted by antlr
In-Reply-To: <dd3a065f0602220921x18d63b00n2d4ccf5639271b7a@mail.gmail.com>
Message-ID: <000d01c637db$8eb4b1d0$8a0a0a0a@starbridgesystems.com>

Can somebody post a link that contains the documentation on the # symbol? I
don't understand it (especially the way it is used in the code below) and
the documentation seems scarce and scattered throughout the newsgroup.

>>formal:
>>    dataType ID^ <AST=MiniJava.Identifier>
>>    { ## = #( #[...], ## ); }
>>    ;

From pete.forman at westerngeco.com  Wed Feb 22 10:18:43 2006
From: pete.forman at westerngeco.com (Pete Forman)
Date: Wed Feb 22 10:19:25 2006
Subject: [antlr-interest] Re: The ISO 8601 Date Format
References: <5D85F621120B9545BE359DCFA778812535FE1E@SERVER.tt.tracetracker.com>
Message-ID: <oe0zp88s.fsf@wgmail2.gatwick.eur.slb.com>

"Silvester Pozarnik" writes:

 > Did someone tried to write down the lexical rules for the ISO 8601
 > Date Format?
 > There are some discussions about (as in the
 > http://www.antlr.org/pipermail/antlr-interest/2003-August/004790.html),
 > but there is none implementation to be found.

There is a list of ambiguities published in ISO8601ambiguities.doc at
http://groups.yahoo.com/group/ISO8601/files/ (login required).

A new version of ISO 8601 was published in 2004.  This makes some
things easier: there are no truncated formats though one ought to try
and support earlier versions of the standard.  On the other hand, some
non-ASCII characters are permitted: "non-breaking hyphen" (U+2011) and
"minus sign" (U+2212).

I do not know of any implementations.
-- 
Pete Forman                -./\.-  Disclaimer: This post is originated
WesternGeco                  -./\.-   by myself and does not represent
pete.forman@westerngeco.com    -./\.-   opinion of Schlumberger, Baker
http://petef.port5.com           -./\.-   Hughes or their divisions.

From kroepke at dolphin-services.de  Wed Feb 22 10:26:59 2006
From: kroepke at dolphin-services.de (Kay Roepke)
Date: Wed Feb 22 10:27:03 2006
Subject: [antlr-interest] I wish a dummy token is accepted by antlr
In-Reply-To: <000d01c637db$8eb4b1d0$8a0a0a0a@starbridgesystems.com>
References: <000d01c637db$8eb4b1d0$8a0a0a0a@starbridgesystems.com>
Message-ID: <D459BB2B-2C6E-4D36-9D73-8387B6B7B988@dolphin-services.de>


On 22. Feb 2006, at 19:12 Uhr, Brannon King wrote:

> Can somebody post a link that contains the documentation on the #  
> symbol?

I did so yesterday.

HTH,

Kay

On 21. Feb 2006, at 2:07 Uhr, ??? Jigang (Robert) Sun wrote:
> Could anyone tell me the reference address?
>

BTW also have a look at http://www.antlr.org/article/1137964510001/ 
manual.tree.construction.txt

-k
From sunjigang1965 at yahoo.com.cn  Wed Feb 22 13:42:12 2006
From: sunjigang1965 at yahoo.com.cn (=?gb2312?q?=CB=EF=BC=CD=B8=D5=20Jigang=20(Robert)=20Sun?=)
Date: Wed Feb 22 13:42:34 2006
Subject: [antlr-interest] RE RE: I wish a dummy tree...
Message-ID: <20060222214212.95876.qmail@web15703.mail.cnb.yahoo.com>

Thanks a lot, Michael & Bryan!

Youe are very helpful. I constructed a another tree,
formalList, by following your method:


formalList
	:
	 (formal ( COMMA! formal)* { ## =
#(#[FORMAL_LIST,"fORMAL_LIST"],##); })?
	;

formal!
    :	dt:dataType id:ID<AST=MiniJava.Identifier>
	{
		## = #( #[MINI_JAVA_FORMAL, "MINI_JAVA_FORMAL"],
#dt, #id );
	}
	;

tokens 
{
  MINI_JAVA_FORMAL <AST=MiniJava.Formal>;
  FORMAL_LIST <AST=MiniJava.FormalList>;
}



		
___________________________________________________________
 
«È»ÀΩ⁄£¨”√—≈ª¢” œ‰ÀÕ√µπÂ£° 

From ron at iesys.com.au  Wed Feb 22 17:10:32 2006
From: ron at iesys.com.au (de Jong, Ron)
Date: Wed Feb 22 17:12:00 2006
Subject: [antlr-interest] Implementing Preprocessor Functions
Message-ID: <F811E702E247DF47BFB8B8057E423401013153@sydmail.iesys.com.au>

Hi,

 

In the scripting language we've implemented we need to add similar
functionality

to the C++ #include, #ifdef, #else, #endif, #define.

 

I have already implemented #include by using a tokenstream filter - this
seems to work well.

Question: is this the best way of implementing preprocessing? Also does
anyone have

suggestions about how to implement the other preprocessing functions?

 

Cheers,

Ron

This e-mail (which includes any attachments) is intended only for the
use of the individual or entity named above and may contain information
that is confidential and privileged and the copyright of Intelligent
Energy Systems Pty Ltd or a third party. Any views expressed in this
e-mail are those of the individual sender, except where the sender
specifically states them to be the views of Intelligent Energy Systems
Pty Ltd. There is no warranty that this e-mail is error or virus free.
If you are not the intended recipient, you must not disclose or use the
information contained in it. If you have received this e-mail in error,
please notify the sender immediately by return e-mail and delete the
original message.

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060223/3233e273/attachment.html
From vanand at iupui.edu  Wed Feb 22 17:55:13 2006
From: vanand at iupui.edu (Anand, Vibha)
Date: Wed Feb 22 17:58:32 2006
Subject: [antlr-interest] literal and string distinction
Message-ID: <699B540027CE04479F2AB03AF730870D0FD200@iu-mssg-mbx105.ads.iu.edu>

I would be interested in knowing the solution. I have a similar issue
whereby I would like to turn "testLiterals" from the parser rule.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060222/5ef7478f/attachment.html
From greenj at ix.netcom.com  Wed Feb 22 18:07:50 2006
From: greenj at ix.netcom.com (John Green)
Date: Wed Feb 22 18:09:16 2006
Subject: [antlr-interest] Implementing Preprocessor Functions
In-Reply-To: <F811E702E247DF47BFB8B8057E423401013153@sydmail.iesys.com.au>
References: <F811E702E247DF47BFB8B8057E423401013153@sydmail.iesys.com.au>
Message-ID: <43FD18F6.9080108@ix.netcom.com>

1. Don't.
2. If it's not your decision anyway, then at least make sure there is an impenetrable barrier between your preprocessor and your lexer. In other words, the preprocessor supplies a character stream to the lexer, and there is no other communication between the two.

I wrote a parser for a pre-existing language (see joanju.com) and the preprocessor was the biggest hurdle. Not only did the preprocessing make it difficult for me to build the parser, but it continues to wreck havoc on all of the benefits that one would expect to gain from a parser, such as documentation generation, pretty printing, lint, and refactoring. No doubt it also makes it messy to build debuggers.

Macro-level processing is a very poor workaround for shortcomings in a language and its compiler.

John


de Jong, Ron wrote:
> Hi,
> 
> In the scripting language we?ve implemented we need to add similar 
> functionality to the C++ #include, #ifdef, #else, #endif, #define.
> 
> I have already implemented #include by using a tokenstream filter ? this 
> seems to work well.
> 
> Question: is this the best way of implementing preprocessing? Also does 
> anyone have suggestions about how to implement the other preprocessing 
> functions?
> 
> Cheers,
> Ron

From jsamort at sympatico.ca  Wed Feb 22 19:11:41 2006
From: jsamort at sympatico.ca (Scott Amort)
Date: Wed Feb 22 19:11:50 2006
Subject: [antlr-interest] ast validation question
Message-ID: <1140664301.7659.11.camel@localhost>

Hello All,

I am writing a parser library for a relatively simple textual
description language, and have progressed fairly well given my relative
lack of familiarity with compiler tools like ANTLR.  This list and the
sample code and grammars provided have been very helpful.

At this point, I have a functioning lexer and parser, and am now working
on a tree walker for validation purposes.  I am hoping to get some
opinions on how best to approach this - currently, I envision using the
tree walking phase to first validate type, then data.  The language
allows tags ( i.e. a '\' followed by text, e.g. \start or \stop).
Currently the lexer identifies the alphanumeric portion after the
backlash as a token and sends it on to the parser, which makes sure it
is found in the correct spots.  Now, in the tree walker, I would like to
make sure that this tag is valid.  Is there an ANTLR-specific way to
accomplish this?  Or perhaps I should develop my own code to deal with
this?  If so, what data structure do you think is best to store a fixed
number of strings, and allow efficient matching or finding?

As you may be able to tell, my programming background is not extensive,
but I am trying to pick up the best way to do things!  Thanks very much
for any assistance.

Best Regards,
Scott

From sohail at taggedtype.net  Wed Feb 22 19:50:58 2006
From: sohail at taggedtype.net (Sohail Somani)
Date: Wed Feb 22 19:51:02 2006
Subject: [antlr-interest] ast validation question
In-Reply-To: <1140664301.7659.11.camel@localhost>
References: <1140664301.7659.11.camel@localhost>
Message-ID: <1140666658.8051.7.camel@localhost.localdomain>

On Wed, 2006-02-22 at 22:11 -0500, Scott Amort wrote:
> Hello All,
> 
> I am writing a parser library for a relatively simple textual
> description language, and have progressed fairly well given my relative
> lack of familiarity with compiler tools like ANTLR.  This list and the
> sample code and grammars provided have been very helpful.
> 
> At this point, I have a functioning lexer and parser, and am now working
> on a tree walker for validation purposes.  I am hoping to get some
> opinions on how best to approach this - currently, I envision using the
> tree walking phase to first validate type, then data.  The language
> allows tags ( i.e. a '\' followed by text, e.g. \start or \stop).
> Currently the lexer identifies the alphanumeric portion after the
> backlash as a token and sends it on to the parser, which makes sure it
> is found in the correct spots.  Now, in the tree walker, I would like to
> make sure that this tag is valid.  Is there an ANTLR-specific way to
> accomplish this?  Or perhaps I should develop my own code to deal with
> this?  If so, what data structure do you think is best to store a fixed
> number of strings, and allow efficient matching or finding?

Couldn't you make these keywords and have them matched as in the parser?

Something like (probably doesnt compile):

class L extends  Lexer;
KEYWORDA:"FOO";
KEYWORDB:"BAR";
KEYWORDC:"NO";
SLASH:'\\';

class P extends Parser;
options
{
	importVocab=L;
}
{
	public static void main(String args[])
	{
		L l = new L(System.in);
		P p = new P(l);
		p.tagRule();
	}
}
tagRule:SLASH (KEYWORDA | KEYWORDB | KEYWORDC);

The key of course is fixed number of strings.

From vs667 at nyu.edu  Wed Feb 22 20:29:46 2006
From: vs667 at nyu.edu (Vladimir S.)
Date: Wed Feb 22 20:30:15 2006
Subject: [antlr-interest] What does this error mean? grammer.txt:10:1:
 Lexical rule Program defined outside of lexer
Message-ID: <43FD3A3A.6020607@nyu.edu>

I get a whole bunch of errors for different rules that all read 
something like this:

grammer.txt:10:1: Lexical rule Program defined outside of lexer

What does it mean  that lexcial rule "Program" was defined outside of lexer?
Sorry for the noob question.

I have attached the grammer file with this email. It is a grammer file 
for a pascal like language.

Thanks!
Vladimir
-------------- next part --------------
//******************************************************** [PARSER]
//********************************************************
//********************************************************
//  [X]                   0 or 1  = (X)? 
//  {X}                  0 or more instances  (X)* 


class ParserCore extends Parser;
//========================================================[]
Program:"Program" ID SEMI_COLON (TypeDefinitions)? (VariableDeclarations)? (SubprogramDeclarations)? CompoundStatement;

//========================================================[]
TypeDefinitions : TYPE TypeDefinition SEMI_COLON (TypeDefinition SEMI_COLON )*;

//========================================================[]
VariableDeclarations : VAR VariableDeclaration SEMI_COLON (VariableDeclaration SEMI_COLON ) ;

//========================================================[]

SubprogramDeclarations : ((ProcedureDeclaration | FunctionDeclaration) SEMI_COLON )*;
//========================================================[]

TypeDefinition : ID = Type; 
//========================================================[]

VariableDeclaration : IdentifierList COLON Type;

//========================================================[]

ProcedureDeclaration : PROCEDURE ID ( FormalParameterList ) SEMI_COLON ( Block | FORWARD ); 

//========================================================[]
FunctionDeclaration : FUNCTION ID ( FormalParameterList ) COLON ResultType SEMI_COLON ( Block | FORWARD ); 

//========================================================[]
FormalParameterList : (IdentifierList COLON Type ( SEMI_COLON IdentifierList : Type )* )?;

//========================================================[]
Block : (VariableDeclarations)? CompoundStatement;

//========================================================[]

CompoundStatement : BEGIN StatementSequence END; 

//========================================================[]

StatementSequence : Statement (SEMI_COLON Statement )?;

//========================================================[]

Statement : SimpleStatement | StructuredStatement;

//========================================================[]
SimpleStatement : ( (AssignmentStatement | ProcedureStatement) )?;

//========================================================[]
AssignmentStatement : Variable (":=") Expression; 

//========================================================[]
ProcedureStatement : ID ( ActualParameterList ); 

//========================================================[]

StructuredStatement :   CompoundStatement 
                        | IF Expression THEN Statement ( ELSE Statement )? 
                        | WHILE Expression DO Statement 
                        | FOR ID ":=" Expression TO Expression DO Statement
			;

//========================================================[]
Type : ID| ARRAY BRAKET_S_OPEN(Constant PERIOD_PERIOD Constant)BRACKET_S_CLOSE OF Type | RECORD FieldList END;

//========================================================[]
ResultType : ID; 

//========================================================[]
Fieldlist : ( IdentifierList : Type ( SEMI_COLON IdentifierList COLON Type )* )?; 

//========================================================[]
Constant : ( Sign )? INTEGER;

//========================================================[]
Expression : SimpleExpression ( RelationalOp SimpleExpression )*;

//========================================================[]
RelationalOp : OP_LESS| LESS_EQUAL | OP_GREATER| GREATER_EQUAL | NOT_EQUAL | EQUAL;

//========================================================[]
SimpleExpression : (Sign)? Term (AddOp Term )*; 

//========================================================[]
AddOp : OP_ADD_SUB| OR;

//========================================================[]
Term : Factor ( MulOp Factor )*; 

//========================================================[]
MulOp : OP_MULT|DIV|MOD|AND;

//========================================================[]
Factor :   INTEGER | STRING| Variable | FunctionReference 
           | NOT Factor | PAREN_OPEN Expression PAREN_CLOSE;
	   
//========================================================[]
FunctionReference : ID PAREN_OPEN ActualParameterList PAREN_CLOSE;

//========================================================[]
Variable : ID ComponentSelection; 

//========================================================[]
ComponentSelection : BRAKET_S_OPEN ( PERIOD ID ComponentSelection | (Expression)? ComponentSelection ) BRAKET_S_CLOSE;

//========================================================[]
ActualParameterList : BRAKET_S_OPEN Expression (COMMA Expression )* BRAKET_S_CLOSE;

//========================================================[]
IdentifierList : ID (COMMA ID)*; 

//========================================================[]
Sign : OP_ADD_SUB;


//******************************************************** LEXER
//********************************************************
//********************************************************
class LexerCore extends Lexer;
options {
	k=2;
}
//========================================================[STRING-ALL PRINTABLE CHARS]
STR 	:	BRACKET_C_OPEN (
			LETTER
			|DIGIT
			|'!'
			|'#'
			|'$'
			|'%'
			|'&'
			|'?'
			|'('
			|')'
			|OP_MULT
			|'/'
			|OP_ADD_SUB
			|','
			|OP_LESS
			|OP_GREATER
			|'='
			|'.'
			|':'
			|';'
			|'@'
			|'['
			|'\\'
			|']'
			|'^'
			|'_'
			|'?'
			|'|'
			|'~'
			|'?'
			|WS
			)* BRACKET_C_CLOSE 
			{ $setType(Token.SKIP); }
			;



//========================================================[KEYWORDS]


AND: "and";

BEGIN: "begin";

FORWARD: "forward";

DIV: "div";

DO: "do";

ELSE: "else";

END: "end";

FOR: "for"; 

FUNCTION: "function";

IF: "if";

ARRAY:"array";

MOD: "mod";

NOT: "not";

OF: "of"; 

OR: "or";

PROCEDURE: "procedure";

PROGRAM: "program";

RECORD: "record";

THEN: "then";

TO: "to";

TYPE: "type";

VAR: "var";

WHILE: "while";
//========================================================[IDENTIFIER]
ID	
options {testLiterals=true;}
	:	LETTER (LETTER|DIGIT|UNDERSCORE)*
	;

//========================================================[WHITE SPACE]
WS	
	:	(SPACE
	|	'\t'
	|	'\n'
	|	'\r')
		{ $setType(Token.SKIP); }
	;
//========================================================[INTEGER]
INT	
	:	(DIGIT)+
	;
//========================================================[SYMBOLS]
protected
SPACE
	:	' '
	;
PAREN_OPEN
	:	'('
	;
PAREN_CLOSE
	:	')'
	;
	
OP_MULT
	:	'*'
	;
OP_ADD_SUB
	:	'+'
	|	'-'
	;
NOT_EQUAL
	: 	"<>"
	;
EQUAL
	:	'='
	;
SEMICOLON
	:	';'
	;
COLON
	:	':'
	;
OP_GREATER
	: '>'
	;
OP_LESS
	: '<'
	;
GREATER_EQUAL
	:	">=";

LESS_EQUAL
	:	 "<="
	;
PIPE
	:	'|'
	;

BRAKET_S_OPEN
	:	'['
	;
BRACKET_S_CLOSE
	:	']'
	;
BRACKET_C_OPEN
	:	'{'
	;

BRACKET_C_CLOSE
	:	'}'
	;
PERIOD_PERIOD: PERIOD PERIOD
	;

PERIOD
	:	'.'
	;

UNDERSCORE
	:	'_'
	;

COMMA:	','
	;

QUOTE: '"';
//========================================================[DIGITS]
protected
DIGIT
	:	'0'..'9'
	;
//========================================================[LETTERS]
protected
LETTER
	:	('a'..'z'|'A'..'Z')
	;
From mail at martin-probst.com  Thu Feb 23 01:01:15 2006
From: mail at martin-probst.com (Martin Probst)
Date: Thu Feb 23 01:01:23 2006
Subject: [antlr-interest] What does this error mean? grammer.txt:10:1:
	Lexical rule Program defined outside of lexer
In-Reply-To: <43FD3A3A.6020607@nyu.edu>
References: <43FD3A3A.6020607@nyu.edu>
Message-ID: <1140685275.6287.3.camel@localhost.localdomain>

> grammer.txt:10:1: Lexical rule Program defined outside of lexer
> 
> What does it mean  that lexcial rule "Program" was defined outside of lexer?
> Sorry for the noob question.

In ANTLR all grammar rules have to start lowercase, all lexer rules have
to start uppercase. So ANTLR tells you it found an uppercase rule (which
should be a lexer rule) within the parser.

Martin

From jose.ventura.roda at gmail.com  Thu Feb 23 03:08:01 2006
From: jose.ventura.roda at gmail.com (Jose Ventura)
Date: Thu Feb 23 03:08:05 2006
Subject: [antlr-interest] How can I simulate states in antlr
Message-ID: <e39abda10602230308k78b26bcdr@mail.gmail.com>

I'm developing a lexical analizer for Cobol and I'm having problems with the
picture strings.

The sentence character separator in cobol is the sign '.', bud some sentence
can to contain this separator, for example in the data declaration:

01 DATA-ITEM    PIC   999.999,99 USAGE DISPLAY.

The sentence finalice with second '.'

Whit states I know how do the lexer, I will make one state SPIC than consume
all character after the token PIC until the next space, but I haven't found
the solution with antlr.

Can anyone help me?

Thanks in advance.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060223/2645ebcf/attachment.html
From sauravkg at huawei.com  Thu Feb 23 03:59:34 2006
From: sauravkg at huawei.com (saurav)
Date: Thu Feb 23 04:03:14 2006
Subject: [antlr-interest] Require Help...
Message-ID: <007e01c63870$9d8f3aa0$3704120a@china.huawei.com>

Hi,

 

I have a doubt. Can any one clarify the same?

 

Problem Statement:

 

Below is the code generated by the ANTLR Tool

 

for (;;) {  

                  if (((_tokenSet_2.member(LA(1))))&&( myErrorRecovery() ))
{

                        moduleDefinition();

                        if (inputState->guessing==0) {

                              

                        }

                        {

                        if ((LA(1) == SemiColon)) {

                              match(SemiColon);

                        }

                        else if (((_tokenSet_16.member(LA(1))))&&(
optionalSemicolon() )) {

                        }

                        else {

                              throw antlr::NoViableAltException(LT(1),
getFilename());

                        }

                        

                        }

                  }

      /* [1] */    else {

                              // I need to add statement here

                        if ( _cnt34>=1 ) { goto _loop34; } else {throw
antlr::NoViableAltException(LT(1), getFilename());}

                  }

                  

                  _cnt34++;

            }

 

The above code is generated by using the following .g code

 

moduleDefinitionsList  :  

  

  (   ({ myErrorRecovery() }? | moduleDefinition)+   ( SemiColon! | {
optionalSemicolon() }?   ) )+

;

 

 

I want to do some modifications on .g code so that either of the below
mentioned modifications will happen

1. Add some statement inside the "ELSE" block marked [1]

2. Alter the "IF" condition like 

    if (( myErrorRecovery() ) && ((_tokenSet_2.member(LA(1))))) {.}

                        

                          OR

 

  if (((_tokenSet_2.member(LA(1))))||( myErrorRecovery() )) {.}

 

Please help me for the same. We are using this code for Error Recovery.

 

Thanks.

Saurav

 

 

****************************************************************************
***********

            This e-mail and attachments contain confidential information
from HUAWEI, which is intended only for the person or entity whose address
is listed above. Any use of the information contained herein in any way
(including, but not limited to, total or partial disclosure, reproduction,
or dissemination) by persons other than the intended recipient's) is
prohibited. If you receive this e-mail in error, please notify the sender by
phone or email immediately and delete it!

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060223/8cef2324/attachment.html
From Anthony.Youngman at eca-international.com  Thu Feb 23 04:58:59 2006
From: Anthony.Youngman at eca-international.com (Anthony Youngman)
Date: Thu Feb 23 04:59:06 2006
Subject: [antlr-interest] Re: fingers need rest
Message-ID: <C7FE35004D40FD45AA342991B88CE4040129019C@lnml1.eca-international.local>

Or just a comfort keyboard. MS do one, I believe, but I use Logitech. Only available cordless now but I think I've seen them at ?45 - pretty cheap for a keyboard that will protect your hands ...

Cheers,
Wol

-----Original Message-----
From: antlr-interest-bounces@antlr.org [mailto:antlr-interest-bounces@antlr.org] On Behalf Of Ahmed Mohombe
Sent: 17 February 2006 12:11
To: antlr-interest@antlr.org
Subject: [antlr-interest] Re: fingers need rest

> ...and resting inflamed fingers...
Than maybe this is good for you:
http://www.datahand.com/

:).

Ahmed.


* ************************************************************************ *

This transmission is intended for the named recipient only. It may contain private and confidential information. If this has come to you in error you must not act on anything disclosed in it, nor must you copy it, modify it, disseminate it in any way, or show it to anyone. Please e-mail the sender to inform us of the transmission error or telephone ECA International immediately and delete the e-mail from your information system.

Telephone numbers for ECA International offices are: Sydney +61 (0)2 8272 5300, Hong Kong + 852 2121 2388, London +44 (0)20 7351 5000 and New York +1 212 582 2333.

* ************************************************************************ *

From sunjigang1965 at yahoo.com.cn  Thu Feb 23 07:44:22 2006
From: sunjigang1965 at yahoo.com.cn (=?gb2312?q?=CB=EF=BC=CD=B8=D5=20Jigang=20(Robert)=20Sun?=)
Date: Thu Feb 23 07:44:27 2006
Subject: [antlr-interest] Could anyone give an example definition of
	isType(IToken itk)
Message-ID: <20060223154422.60932.qmail@web15708.mail.cnb.yahoo.com>

Could anyone give an example definition of
isType(IToken itk) in 

http://www.antlr.org/doc/glossary.html

decl     : typename ID SEMICOLON
         | ID ID SEMICOLON
         ;
typename : {isType(LT(1))}? ID
         ;

I think typename() is used to declare user defined
variable type, can be any identifier names, not
predifined types. 

Cheers!

Jigang



		
___________________________________________________________
 
«È»ÀΩ⁄£¨”√—≈ª¢” œ‰ÀÕ√µπÂ£° 

From kroepke at dolphin-services.de  Thu Feb 23 08:06:05 2006
From: kroepke at dolphin-services.de (Kay Roepke)
Date: Thu Feb 23 08:06:10 2006
Subject: [antlr-interest] Could anyone give an example definition of
	isType(IToken itk)
In-Reply-To: <20060223154422.60932.qmail@web15708.mail.cnb.yahoo.com>
References: <20060223154422.60932.qmail@web15708.mail.cnb.yahoo.com>
Message-ID: <74FE73BB-30FC-4171-B896-C8D3681B3672@dolphin-services.de>


On 23. Feb 2006, at 16:44 Uhr, ??? Jigang (Robert) Sun wrote:

> Could anyone give an example definition of
> isType(IToken itk) in
>
> http://www.antlr.org/doc/glossary.html
>
> decl     : typename ID SEMICOLON
>          | ID ID SEMICOLON
>          ;
> typename : {isType(LT(1))}? ID
>          ;
>
> I think typename() is used to declare user defined
> variable type, can be any identifier names, not
> predifined types.

The paragraph you refer to is this one, is it not?

http://www.antlr.org/doc/glossary.html:
-------------------------------------
The predicate is not needed in typename as there is no decision,  
however, rule decl needs it to distinguish between its two  
alternatives. The first alternative would look like:
if ( LA(1)==ID && isType(LT(1)) ) {
   typename();
   match(ID);
   match(SEMICOLON);
}
-------------------------------------

Here 'typename();' is simply the method call for the invokation of  
the typename parser rule. It doesn't do anything related to types at  
all. If you would rename the rule 'typename'
to 'foobar' the code would have 'foobar();' in it.

isType() is user defined, there is no default implementation. You  
need to do that yourself (maintain a symbol table and whatnot). It is  
merely shown here for illustration purposes, to
demonstrate the effect predicate hoisting has.

HTH,

Kay
From vs667 at nyu.edu  Thu Feb 23 11:16:56 2006
From: vs667 at nyu.edu (Vladimir Sutskever)
Date: Thu Feb 23 11:17:00 2006
Subject: [antlr-interest] Understanding nondeterminism warnings: and how to
	debug them
Message-ID: <43FE0A28.70705@nyu.edu>

I cant seem to get rid of the few nondeterminism warnings that appear 
when I attempt to generate the parser.
How would I debug something like this? Line #14 does not have "BEGIN" 
...how do the warning line #'s correspond to my grammar?
This is my first attempt to generate some grammar, and I know I lack 
much(all) of the intuition behind it.

Hopefully you guys/gals can help me get trough this :)
I have attached my grammar file.
This is the error nondeterminism error I get:

grammer.txt:14:75: warning:nondeterminism between alts 1 and 2 of block upon
grammer.txt:14:75:     k==1:BEGIN
grammer.txt:40: warning:nondeterminism upon
grammer.txt:40:     k==1:SEMI_COLON
grammer.txt:40:     between alt 1 and exit branch of block
grammer.txt:58:21: warning:nondeterminism between alts 1 and 2 of block upon
grammer.txt:58:21:     k==1:ID
grammer.txt:69:56: warning:nondeterminism between alts 1 and 2 of block upon
grammer.txt:69:56:     k==1:ELSE
grammer.txt:105: warning:nondeterminism between alts 3 and 4 of block upon
grammer.txt:105:     k==1:ID

-Vladimir

-------------- next part --------------
//******************************************************** [PARSER]
//********************************************************
//********************************************************
//  [X]                   0 or 1  = (X)? 
//  {X}                  0 or more instances  (X)* 
options {
	language = "CSharp";
}


class ParserCore extends Parser;
//options { k=1; }
//========================================================[]
program: PROGRAM ID SEMI_COLON (typeDefinitions)? (variableDeclarations)? (subprogramDeclarations)? compoundStatement;

//========================================================[]
typeDefinitions : TYPE typeDefinition SEMI_COLON (typeDefinition SEMI_COLON )*;

//========================================================[]
variableDeclarations : VAR variableDeclaration SEMI_COLON (variableDeclaration SEMI_COLON ) ;

//========================================================[]

subprogramDeclarations : ((procedureDeclaration | functionDeclaration) SEMI_COLON )*;
//========================================================[]

typeDefinition: ID EQUAL type; 
//========================================================[]

variableDeclaration : identifierList COLON type;

//========================================================[]

procedureDeclaration : PROCEDURE ID ( formalParameterList ) SEMI_COLON ( block | FORWARD ); 

//========================================================[]
functionDeclaration : FUNCTION ID ( formalParameterList ) COLON resultType SEMI_COLON ( block | FORWARD ); 

//========================================================[]
formalParameterList : (identifierList COLON type ( SEMI_COLON identifierList : type )* )?;

//========================================================[]
block : (variableDeclarations)? compoundStatement;

//========================================================[]

compoundStatement : BEGIN statementSequence END; 

//========================================================[]

statementSequence : statement (SEMI_COLON statement )?;

//========================================================[]

statement : simpleStatement | structuredStatement;

//========================================================[]
simpleStatement : ( (assignmentStatement | procedureStatement) )?;

//========================================================[]
assignmentStatement : variable (":=") expression; 

//========================================================[]
procedureStatement : ID ( actualParameterList ); 

//========================================================[]

structuredStatement :   compoundStatement 
                        | IF expression THEN statement ( ELSE statement )? 
                        | WHILE expression DO statement 
                        | FOR ID ":=" expression TO expression DO statement
			;

//========================================================[]
type : ID| ARRAY BRAKET_S_OPEN(constant PERIOD_PERIOD constant)BRACKET_S_CLOSE OF type | RECORD fieldList END;

//========================================================[]
resultType : ID; 

//========================================================[]
fieldList : ( identifierList : type ( SEMI_COLON identifierList COLON type )* )?; 

//========================================================[]
constant : ( sign )? INTEGER;

//========================================================[]
expression : simpleExpression ( relationalOp simpleExpression )*;

//========================================================[]
relationalOp : OP_LESS| LESS_EQUAL | OP_GREATER| GREATER_EQUAL | NOT_EQUAL | EQUAL;

//========================================================[]
simpleExpression : (sign)? term (addOp term )*; 

//========================================================[]
addOp : OP_ADD_SUB| OR;

//========================================================[]
term : factor ( mulOp factor )*; 

//========================================================[]
mulOp : OP_MULT|DIV|MOD|AND;

//========================================================[]
factor :   INTEGER | STRING| variable | functionReference 
           | NOT factor | PAREN_OPEN expression PAREN_CLOSE;
	   
//========================================================[]
functionReference : ID PAREN_OPEN actualParameterList PAREN_CLOSE;

//========================================================[]
variable : ID componentSelection; 

//========================================================[]
componentSelection : BRAKET_S_OPEN ( PERIOD ID componentSelection | (expression)? componentSelection ) BRAKET_S_CLOSE;

//========================================================[]
actualParameterList : BRAKET_S_OPEN expression (COMMA expression )* BRAKET_S_CLOSE;

//========================================================[]
identifierList : ID (COMMA ID)*; 

//========================================================[]
sign : OP_ADD_SUB;



//******************************************************** LEXER
//********************************************************
//********************************************************
class LexerCore extends Lexer;
options {
	k=2;
}
//========================================================[STRING-ALL PRINTABLE CHARS]
STR 	:	BRACKET_C_OPEN (
			LETTER
			|DIGIT
			|'!'
			|'#'
			|'$'
			|'%'
			|'&'
			|'?'
			|'('
			|')'
			|OP_MULT
			|'/'
			|OP_ADD_SUB
			|','
			|OP_LESS
			|OP_GREATER
			|'='
			|'.'
			|':'
			|';'
			|'@'
			|'['
			|'\\'
			|']'
			|'^'
			|'_'
			|'?'
			|'|'
			|'~'
			|'?'
			|WS
			)* BRACKET_C_CLOSE 
			{ $setType(Token.SKIP); }
			;



//========================================================[KEYWORDS]


AND: "and";

BEGIN: "begin";

FORWARD_OR_FOR
	: ("forward") =>FORWARD{$setType(FORWARD);}
	| ("for")=>FOR {$setType(FOR); }
	;

protected
FORWARD: "forward";

protected
FOR: "for"; 

DIV: "div";

DO: "do";

ELSE: "else";

END: "end";

FUNCTION: "function";

IF: "if";

ARRAY:"array";

MOD: "mod";

NOT: "not";

OF: "of"; 

OR: "or";

PROCEDURE: "procedure";

PROGRAM: "Program";

RECORD: "record";

THEN: "then";

TO: "to";

TYPE: "type";

VAR: "var";

WHILE: "while";

//========================================================[WHITE SPACE]
WS	
	:	(SPACE
	|	'\t'
	|	'\n'
	|	'\r')
		{ $setType(Token.SKIP); }
	;
//========================================================[INTEGER]
INT	
	:	(DIGIT)+
	;
//========================================================[SYMBOLS]
protected
SPACE
	:	' '
	;
PAREN_OPEN
	:	'('
	;
PAREN_CLOSE
	:	')'
	;
	
OP_MULT
	:	'*'
	;
OP_ADD_SUB
	:	'+'
	|	'-'
	;
NOT_EQUAL
	: 	"<>"
	;
EQUAL
	:	'='
	;
SEMICOLON
	:	';'
	;
COLON
	:	':'
	;
OP_GREATER
	: '>'
	;
OP_LESS
	: '<'
	;
GREATER_EQUAL
	:	">=";

LESS_EQUAL
	:	 "<="
	;
PIPE
	:	'|'
	;

BRAKET_S_OPEN
	:	'['
	;
BRACKET_S_CLOSE
	:	']'
	;
BRACKET_C_OPEN
	:	'{'
	;

BRACKET_C_CLOSE
	:	'}'
	;
PERIOD_PERIOD: PERIOD PERIOD
	;

PERIOD
	:	'.'
	;

UNDERSCORE
	:	'_'
	;

COMMA:	','
	;

QUOTE: '"';
//========================================================[DIGITS]
protected
DIGIT
	:	'0'..'9'
	;
//========================================================[LETTERS]
protected
LETTER
	:	('a'..'z'|'A'..'Z')
	;

//========================================================[IDENTIFIER]
ID	
options 
	{
		testLiterals=true;
		generateAmbigWarnings=false;
	}
	
	:	LETTER (LETTER|DIGIT|UNDERSCORE)*
	;
From mail at martin-probst.com  Thu Feb 23 12:16:50 2006
From: mail at martin-probst.com (Martin Probst)
Date: Thu Feb 23 12:16:57 2006
Subject: [antlr-interest] Understanding nondeterminism warnings: and
	how to debug them
In-Reply-To: <43FE0A28.70705@nyu.edu>
References: <43FE0A28.70705@nyu.edu>
Message-ID: <1140725810.5569.4.camel@localhost.localdomain>

Hi,

> I cant seem to get rid of the few nondeterminism warnings that appear 
> when I attempt to generate the parser.
> How would I debug something like this? Line #14 does not have "BEGIN" 
> ...how do the warning line #'s correspond to my grammar?

Try to think like the parser. You're at some line after the PROGRAM ID
SEMI_COLON stuff and the next token you get is BEGIN. Now you have the
choice to enter one of the optional blocks, but which one? It always has
to be possible to decide from just the one token type (for k==1) which
rule to take. Apparently in your grammar that's not the case (though I
cannot see what's the problem in line #14 - are you sure the numbers are
right?).

You can get a better idea of what's going on by reading the source code,
that helps a lot to understand the whole thing.

Martin

From r.paterson at ioof.com.au  Thu Feb 23 13:46:59 2006
From: r.paterson at ioof.com.au (PATERSON, Robert)
Date: Thu Feb 23 13:47:06 2006
Subject: [antlr-interest] Understanding nondeterminism warnings: and how
	todebug them
Message-ID: <FB120A6865FF7741A38A948247A91F12030C6D33@MELSSRV007.ioof.com.au>

Let me preface these comments with "I'm an ANTLR newbie with an
imperfect mental map of what ANTLR does", but that said, I think it's
complaining because your compoundStatement can contain a compound
statements or empty simple statements.

So it's thinking goes something like this:

program: PROGRAM ID SEMI_COLON -> 
compoundStatement: BEGIN 
    and then either (simpleStatement/*completely optional so can be
empty*/ SEMI simpleStatement /*completely optional so can be empty*/)
    or
    compountStatement: BEGIN
;


So it gets to BEGIN and says to itself, "Well it looks like it's
complete valid to follow the BEGIN with another BEGIN or with a
completely empty simpleStatement followed by a SEMI colon..."

Anyway, that's my guess at it.

I'd say if you replaced:

program: PROGRAM ID SEMI_COLON (typeDefinitions)?
(variableDeclarations)? (subprogramDeclarations)? compoundStatement;

With something like:

program: PROGRAM ID SEMI_COLON (typeDefinitions)?
(variableDeclarations)? (subprogramDeclarations)? statementSequence;


And:

simpleStatement : ( (assignmentStatement | procedureStatement) )?;

With

simpleStatement : (assignmentStatement | procedureStatement);



A lot of your problems will go away.



-----Original Message-----
From: antlr-interest-bounces@antlr.org
[mailto:antlr-interest-bounces@antlr.org] On Behalf Of Vladimir
Sutskever
Sent: Friday, 24 February 2006 6:17 AM
To: antlr-interest@antlr.org
Subject: [antlr-interest] Understanding nondeterminism warnings: and how
todebug them

I cant seem to get rid of the few nondeterminism warnings that appear
when I attempt to generate the parser.
How would I debug something like this? Line #14 does not have "BEGIN" 
...how do the warning line #'s correspond to my grammar?
This is my first attempt to generate some grammar, and I know I lack
much(all) of the intuition behind it.

Hopefully you guys/gals can help me get trough this :) I have attached
my grammar file.
This is the error nondeterminism error I get:

grammer.txt:14:75: warning:nondeterminism between alts 1 and 2 of block
upon
grammer.txt:14:75:     k==1:BEGIN
grammer.txt:40: warning:nondeterminism upon
grammer.txt:40:     k==1:SEMI_COLON
grammer.txt:40:     between alt 1 and exit branch of block
grammer.txt:58:21: warning:nondeterminism between alts 1 and 2 of block
upon
grammer.txt:58:21:     k==1:ID
grammer.txt:69:56: warning:nondeterminism between alts 1 and 2 of block
upon
grammer.txt:69:56:     k==1:ELSE
grammer.txt:105: warning:nondeterminism between alts 3 and 4 of block
upon
grammer.txt:105:     k==1:ID

-Vladimir



****************************************************************************
IMPORTANT - PLEASE READ
This communication is intended only for the use of the addressee and 
may contain personal information, confidential information or legally 
privileged information. If personal information is contained in this e-mail, 
then it is governed by the Privacy Act 1988 and must be treated in 
accordance with the Privacy Act 1988 by the recipient. The legal 
privilege and confidentiality attached to this e-mail is not waivered, 
lost or destroyed by reason of mistaken delivery to you. If you are not 
the intended recipient, we would appreciate immediate notification by 
return e-mail or telephoning +61-3-8614-4444 and ask that the message 
be permanently deleted from your system. If you are the intended 
recipient of this communication you should not copy, disclose or distribute this communication without the authority of IOOF or its related entities (the IOOF Group).
Any views expressed in this message are those of the individual sender, 
except where they are specifically stated to be the views of the IOOF 
Group.
This e-mail and any attachments have been scanned for computer viruses 
using anti-viral software, but you should also perform your own scan. We 
do not accept liability for any loss or damage, whether caused by our own negligence or not, that results from a computer virus or a defect in the transmission of the e-mail or any attached file.
****************************************************************************

From r.paterson at ioof.com.au  Thu Feb 23 13:49:37 2006
From: r.paterson at ioof.com.au (PATERSON, Robert)
Date: Thu Feb 23 13:49:42 2006
Subject: [antlr-interest] Understanding nondeterminism warnings: and
	howtodebug them
Message-ID: <FB120A6865FF7741A38A948247A91F12030C6D34@MELSSRV007.ioof.com.au>

Actually I just realised that replacing compoundStatement with
statementSequence won't give you the grammar you're after. Perhaps just
making simpleStatement non-optional will do the trick... 

-----Original Message-----
From: antlr-interest-bounces@antlr.org
[mailto:antlr-interest-bounces@antlr.org] On Behalf Of PATERSON, Robert
Sent: Friday, 24 February 2006 8:47 AM
To: Vladimir Sutskever
Cc: antlr-interest@antlr.org
Subject: RE: [antlr-interest] Understanding nondeterminism warnings: and
howtodebug them

Let me preface these comments with "I'm an ANTLR newbie with an
imperfect mental map of what ANTLR does", but that said, I think it's
complaining because your compoundStatement can contain a compound
statements or empty simple statements.

So it's thinking goes something like this:

program: PROGRAM ID SEMI_COLON ->
compoundStatement: BEGIN 
    and then either (simpleStatement/*completely optional so can be
empty*/ SEMI simpleStatement /*completely optional so can be empty*/)
    or
    compountStatement: BEGIN
;


So it gets to BEGIN and says to itself, "Well it looks like it's
complete valid to follow the BEGIN with another BEGIN or with a
completely empty simpleStatement followed by a SEMI colon..."

Anyway, that's my guess at it.

I'd say if you replaced:

program: PROGRAM ID SEMI_COLON (typeDefinitions)?
(variableDeclarations)? (subprogramDeclarations)? compoundStatement;

With something like:

program: PROGRAM ID SEMI_COLON (typeDefinitions)?
(variableDeclarations)? (subprogramDeclarations)? statementSequence;


And:

simpleStatement : ( (assignmentStatement | procedureStatement) )?;

With

simpleStatement : (assignmentStatement | procedureStatement);



A lot of your problems will go away.



-----Original Message-----
From: antlr-interest-bounces@antlr.org
[mailto:antlr-interest-bounces@antlr.org] On Behalf Of Vladimir
Sutskever
Sent: Friday, 24 February 2006 6:17 AM
To: antlr-interest@antlr.org
Subject: [antlr-interest] Understanding nondeterminism warnings: and how
todebug them

I cant seem to get rid of the few nondeterminism warnings that appear
when I attempt to generate the parser.
How would I debug something like this? Line #14 does not have "BEGIN" 
...how do the warning line #'s correspond to my grammar?
This is my first attempt to generate some grammar, and I know I lack
much(all) of the intuition behind it.

Hopefully you guys/gals can help me get trough this :) I have attached
my grammar file.
This is the error nondeterminism error I get:

grammer.txt:14:75: warning:nondeterminism between alts 1 and 2 of block
upon
grammer.txt:14:75:     k==1:BEGIN
grammer.txt:40: warning:nondeterminism upon
grammer.txt:40:     k==1:SEMI_COLON
grammer.txt:40:     between alt 1 and exit branch of block
grammer.txt:58:21: warning:nondeterminism between alts 1 and 2 of block
upon
grammer.txt:58:21:     k==1:ID
grammer.txt:69:56: warning:nondeterminism between alts 1 and 2 of block
upon
grammer.txt:69:56:     k==1:ELSE
grammer.txt:105: warning:nondeterminism between alts 3 and 4 of block
upon
grammer.txt:105:     k==1:ID

-Vladimir



************************************************************************
****
IMPORTANT - PLEASE READ
This communication is intended only for the use of the addressee and 
may contain personal information, confidential information or legally 
privileged information. If personal information is contained in this
e-mail, 
then it is governed by the Privacy Act 1988 and must be treated in 
accordance with the Privacy Act 1988 by the recipient. The legal 
privilege and confidentiality attached to this e-mail is not waivered, 
lost or destroyed by reason of mistaken delivery to you. If you are not 
the intended recipient, we would appreciate immediate notification by 
return e-mail or telephoning +61-3-8614-4444 and ask that the message 
be permanently deleted from your system. If you are the intended 
recipient of this communication you should not copy, disclose or
distribute this communication without the authority of IOOF or its
related entities (the IOOF Group).
Any views expressed in this message are those of the individual sender, 
except where they are specifically stated to be the views of the IOOF 
Group.
This e-mail and any attachments have been scanned for computer viruses 
using anti-viral software, but you should also perform your own scan. We

do not accept liability for any loss or damage, whether caused by our
own negligence or not, that results from a computer virus or a defect in
the transmission of the e-mail or any attached file.
************************************************************************
****

From jsamort at sympatico.ca  Thu Feb 23 17:17:05 2006
From: jsamort at sympatico.ca (Scott Amort)
Date: Thu Feb 23 17:17:20 2006
Subject: [antlr-interest] ast validation question
In-Reply-To: <1140666658.8051.7.camel@localhost.localdomain>
References: <1140664301.7659.11.camel@localhost>
	<1140666658.8051.7.camel@localhost.localdomain>
Message-ID: <1140743825.7494.2.camel@localhost>

On Wed, 2006-02-22 at 19:50 -0800, Sohail Somani wrote:

> Couldn't you make these keywords and have them matched as in the parser?
> 
> Something like (probably doesnt compile):
> 
> class L extends  Lexer;
> KEYWORDA:"FOO";
> KEYWORDB:"BAR";
> KEYWORDC:"NO";
> SLASH:'\\';
> 
> class P extends Parser;
> options
> {
> 	importVocab=L;
> }
> {
> 	public static void main(String args[])
> 	{
> 		L l = new L(System.in);
> 		P p = new P(l);
> 		p.tagRule();
> 	}
> }
> tagRule:SLASH (KEYWORDA | KEYWORDB | KEYWORDC);
> 
> The key of course is fixed number of strings.

Thanks for the response!

Yes, I did consider going this route, but it seemed a bit cluttered to
have 50 or so identifiers that were all processed exactly the same way
by the lexer/parser.  So it seemed best to evaluate only the syntax, and
leave validation for a later step.

Best,
Scott

From sohail at taggedtype.net  Thu Feb 23 19:21:19 2006
From: sohail at taggedtype.net (Sohail Somani)
Date: Thu Feb 23 19:21:25 2006
Subject: [antlr-interest] ast validation question
In-Reply-To: <1140743825.7494.2.camel@localhost>
References: <1140664301.7659.11.camel@localhost>
	<1140666658.8051.7.camel@localhost.localdomain>
	<1140743825.7494.2.camel@localhost>
Message-ID: <1140751280.8158.7.camel@localhost.localdomain>

On Thu, 2006-02-23 at 20:17 -0500, Scott Amort wrote:
> Thanks for the response!
> 
> Yes, I did consider going this route, but it seemed a bit cluttered to
> have 50 or so identifiers that were all processed exactly the same way
> by the lexer/parser.  So it seemed best to evaluate only the syntax, and
> leave validation for a later step.

Its more readable if your keywords are actually part of your grammar!

From tony at bill.assist.uci.edu  Thu Feb 23 20:36:22 2006
From: tony at bill.assist.uci.edu (tony@bill.assist.uci.edu)
Date: Thu Feb 23 20:36:26 2006
Subject: [antlr-interest] "google like" quoted string parser/lexer 
Message-ID: <Pine.LNX.4.44.0602232036040.8459-100000@bill.assist.uci.edu>

Hi,

Can anyone point me in the right direction of how I'd write a lexer/parser 
that handles quoted strings.  Ultimately what I'm doing would be used as a 
translator into SQL, but I'm interested in anything that deals with 
quoted strings.  

It would have rules such as this:

1. this that -- the words 'this' and 'that' would have to appear somewhere 
in the text.

2. "a phrase" -- word/words quoted would signify that the words would have 
to appear exactly in the text as typed in a keyword search.

3. "some search terms" qualifier -- same as above, and the word 
'qualifier' would also have to appear anywhere in the text.  In other words,
there's an implicit "and" between the quoted string and the word 'qualifier'.  
There could be a 0 or more qualifier words, as well as 0 or more quoted 
strings.

4. There could also be typos that have a starting double quote, with no 
ending double quote (ie "not a phrase).  These would be treated as #1 
above, basically just stripping out the unbalanced quote.

Does anyone have or know of an example that I can use as a starting point?
I'm quiet a neophyte at using a lexer/parser so anything is useful.

Thanks a lot,
Tony




From ewbank at gmail.com  Fri Feb 24 02:14:18 2006
From: ewbank at gmail.com (Bryan Ewbank)
Date: Fri Feb 24 02:14:21 2006
Subject: [antlr-interest] Ambiguity warning (ANTLR 2.7.5, 2.7.6)
Message-ID: <dd3a065f0602240214vc73e498y425457891d8e1b18@mail.gmail.com>

I finally figured out why I was getting an TreeGrammar ambiguity
warning in places where others were saying that I should not - it's
because I have an action.

If you have a rule of the form, no warning is issued.
    a:  ( #(B ...)
        | .
        );

If; however, you add an action to the "." alternative, am ambiguity
warning is issued:
    a:  ( #(B ...)
        | e:. { error(#e); }
        );

The warning again disappears if you make the last alternative a #(...) tree:
    a:  ( #(B ...)
        | #( e:. { error(#e); } )
        );

It looks like it is supposed to be suppressed in LLkAnalyzer.java, by
altUsesWildcardDefault(), but I don't know the data shapes well enough
to propose a solution.

At the very least, turns out I'll been able to remove quite a few
predicates by using the last form.

Hope this helps someone,
- Bryan Ewbank
From stanio at myrealbox.com  Fri Feb 24 02:58:30 2006
From: stanio at myrealbox.com (Stanimir Stamenkov)
Date: Fri Feb 24 02:58:33 2006
Subject: [antlr-interest] [OT] Re: Understanding nondeterminism warnings:
	and howtodebug them
In-Reply-To: <FB120A6865FF7741A38A948247A91F12030C6D34@MELSSRV007.ioof.com.au>
References: <FB120A6865FF7741A38A948247A91F12030C6D34@MELSSRV007.ioof.com.au>
Message-ID: <43FEE6D6.5090605@myrealbox.com>

On Feb 24, 2006 /PATERSON, Robert/ posted to the "ANTLR Interest" 
mailing list:

> IMPORTANT - PLEASE READ
> This communication is intended only for the use of the addressee and 
> may contain personal information, confidential information or legally 
> privileged information.
[...]

Given you're posting to a public list I don't think your privacy 
note is relevant nor appropriate in any way. It just adds ~1.5 KB to 
every message you post and may make others fill somewhat uncomfortable.

-- 
Stanimir
From ewbank at gmail.com  Fri Feb 24 03:30:56 2006
From: ewbank at gmail.com (Bryan Ewbank)
Date: Fri Feb 24 03:30:58 2006
Subject: [antlr-interest] Understanding nondeterminism warnings: and how
	to debug them
In-Reply-To: <43FE0A28.70705@nyu.edu>
References: <43FE0A28.70705@nyu.edu>
Message-ID: <dd3a065f0602240330y676ef85cy341d36487697ddbd@mail.gmail.com>

Hi Vladimir,

Ambiguity errors are often very puzzling, as we often see only what we (as
humans) wnat to see, rather than what is actually there.

I hope the following helps to get your grammar working...

- Bryan Ewbank

=== === ===
> grammer.txt:14:75: warning:nondeterminism between alts 1 and 2 of block upon
> grammer.txt:14:75:     k==1:BEGIN

I think one of the problems is with interactions between <program> and
<subprogramDeclarations>.
    <program> says "( subprogramDeclarations )?"
    <subprogramDeclarations> says "( ... )*"
So, if there is no sequence of tokens that match subprogramDeclarations, what
does <program> do? It can either match one <subprogramDeclarations> (that
matches no tokens), or it can match no <subprogramDeclarations>.

If you replace "(...)*" with "(...)+" in <subprogramDeclarations>, you should
fix some of the warnings:

    subprogramDeclarations :
        (
            (procedureDeclaration | functionDeclaration)
            SEMI_COLON
        )+
    ;

=== === ===
> grammer.txt:40: warning:nondeterminism upon
> grammer.txt:40:     k==1:SEMI_COLON
> grammer.txt:40:     between alt 1 and exit branch of block

The error at line #40, from <formalParameterList>, is that when ANTLR sees a
SEMI_COLON it doesn't know if it's supposed to go "around" again, or quit.
Specifically, look at <procedureDeclaration> and you will see that
<formalParameterList is followed immediately by SEMI_COLON.

I would guess that you really want to see parenthesis in the input stream, so
probably <procedureDeclaration> (and <functionDeclaration>) should be using
quoted parenthesis -- '(' and ')' -- around the <formalParameterList>

=== === ===
> grammer.txt:58:21: warning:nondeterminism between alts 1 and 2 of block upon
> grammer.txt:58:21:     k==1:ID

The problem here is that both an assignmentStatement and a procedureStatement
start with an ID; if this is a correct language definition, you may require
k=2.  In procedureStatement, as in the procedureDeclaration, you need to quote
the parenthesis that you want as input tokens.

=== === ===
> grammer.txt:69:56: warning:nondeterminism between alts 1 and 2 of block upon
> grammer.txt:69:56:     k==1:ELSE

This is a classic ambiguity - does ELSE match the most recent IF, or not:
    if (e1)
        if (e2)
            s1
    else
        s2
The easiest solution, to me, is to add the option greedy=true to the (...)?
around ELSE; see the manual for exact syntax.

=== === ===
> grammer.txt:105: warning:nondeterminism between alts 3 and 4 of block upon
> grammer.txt:105:     k==1:ID

This is the same type of ambiguity as at line 51 - both <variable> and
<functionReference> start with an ID.
From antlr at jazillian.com  Fri Feb 24 07:11:02 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Fri Feb 24 07:11:01 2006
Subject: [antlr-interest] Preserving ALL comments!
In-Reply-To: <46762.127.0.0.1.1140542005.squirrel@taggedtype.net>
References: 43F99B33.8050703@fer.hr <43FAC2F8.5040004@fer.hr>
	<43FB417E.3050906@jazillian.com>
	<46762.127.0.0.1.1140542005.squirrel@taggedtype.net>
Message-ID: <43FF2206.60404@jazillian.com>

Well, it turns out I guess I haven't written much concrete about how to 
preserve whitespace.

I'd like to write a paper with more details in the next few weeks. I'm 
actually working on this
stuff now, too. For a good chuckle, take a look at this:
/* a multiline
* comment
*/

Imagine that's in C, indented as shown, as your input. And now, it needs 
to be indented
in your Java output because it's inside a class:
class whatever {
   /* a multiline
    * comment
    */
}

...so you actually have to add indenting to the comment token's text 
itself. So you have to
say "after every newline in a multiline comment, add indentation based 
on the current indentation
level".

Below is what I did write (Dick Cheney gave me permission to declassify 
it :) , but as you
can see, it give no real specifics, other than describe the general 
placement technique
Andy

-----------------------------------------
The CommentSaver <cid:part1.09050001.09010202@jazillian.com> class is 
responsible for saving comment information. The 
|CommentSaver.removeWhitespace()| method, in addition to actually 
removing whitespace, splits each file up into separate lines. The 
Source.addFile() method is called to read in each C file, and as it's 
removing whitespace, it also builds up a list of line descriptions if 
comments are being saved. So the code in |Source.addFile()| looks like 
this:

        List<List<Token>> linesInFile = 
CommentSaver.getInstance().removeWhitespace(this, javaFileName);
        //System.out.println("addFile: fileName=" + fileName + " size=" 
+ linesInFile.size());
        // saveComments == false indicates that the file doesn't have 
any comments, because
        // we generated it ourselves.
        // keepComments == false indicates that the user asked not to 
keep the comments.
        // Combine the two:
        if (Parameters.keepComments && saveComments) {
            List<LineDescription> list = lineDescriptions.create(this, 
linesInFile);
            lineDescriptions.add(this, javaFileName, list);
        }

Thus, we keep a single LineDescriptions 
<cid:part2.02040508.02070506@jazillian.com> object around, which 
contains a set of "loose descriptions" for each of the lines of the 
input C files. The |LineDescriptions.create()| method processes an 
entire C file and returns a List of LineDescription objects. The 
constructor for the LineDescription 
<cid:part3.03080806.01000808@jazillian.com> class takes a list of tokens 
on the line, and creates a "loose description" of the line from that.

Most lines are simply described by their first token. For example, if 
the line starts with "if", we set |LineDescription.LineType| to 
|LineType.IF|. Sometimes, we have to examine the whole line a little 
closer in order to categorize it. For example, suppose we have the line 
"int a = 3;". The |LineDescription.lookForDeclaration()| method is smart 
enough to look through that line and see that it looks like a 
declaration, and then a call to |source.isVariableDeclaration()| tells 
us that it's a variable declaration (as opposed to a function declaration).

So the main information that a LineDescription contains is the LineType 
<cid:part4.05010509.07040507@jazillian.com>. One of the types of lines 
is |MultiLineComment|, and another is |SingleLineComment|.


     Restoring Comments

Even though the storing of comments was not done by a rule, the 
restoring of comments is done by rule CommentRestoreRule. Comments are 
restored on a file-by-file basis, so CommentRestoreRule 
<cid:part5.06000101.02020009@jazillian.com> extends OncePerFileRule 
<cid:part6.05070104.03030302@jazillian.com> and has an applyToFile() 
method that's called for each file. It creates a single LineDescriptions 
<cid:part2.02040508.02070506@jazillian.com> object called "current", and 
adds LineDescription <cid:part3.03080806.01000808@jazillian.com> objects 
to it. So we now have loose line descriptions of both the original C 
code and the translated Java code. The |CommentRestoreRule.cleanup()| 
method, which is called just once, calls |align()| to match up the two 
sets of lines, and |addComments()| to add the comments into the Java 
code. The "alignment" algorithm basically loops through both sets of 
line descriptions together, keeping track of which file and function we 
are in. So a comment that comes before the third variable declaration in 
function f() in file myfile.c will get placed before the third variable 
declaration in function f() in file Myfile.java.

>
>

>
>
>  
>

From prashant.deva at gmail.com  Fri Feb 24 10:47:06 2006
From: prashant.deva at gmail.com (Prashant Deva)
Date: Fri Feb 24 10:47:09 2006
Subject: [antlr-interest] Need another name for ANTLR Studio's Flux Debugger
Message-ID: <41fed8f80602241047y25f7f193h40bef3249dfea59b@mail.gmail.com>

I guess everyone here who knows about the ANTLR Studio ide, knows about the
amazing 'Flux Debugger' which allows you to debug grammar files with java
code.

Apparently the term 'Flux' is trademarked by 'Flux Corp.' (fluxbpm.com).
They have requested me to change the name of Flux Debugger to something
else. I have accepted their request.

So if any of you have any nice names in mind for the Flux Debugger, feel
free to suggest them :)

For full detail on this, look at my blog entry here-
http://placidsystems.com/blog/2006/02/no-more-flux-in-flux-debugger.html

Thanks,
--
Prashant Deva
Creator, ANTLR Studio
Founder, Placid Systems, www.placidsystems.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060225/4129bf80/attachment.html
From antlr at jazillian.com  Fri Feb 24 11:09:20 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Fri Feb 24 11:09:20 2006
Subject: [antlr-interest] Need another name for ANTLR Studio's Flux
	Debugger
In-Reply-To: <41fed8f80602241047y25f7f193h40bef3249dfea59b@mail.gmail.com>
References: <41fed8f80602241047y25f7f193h40bef3249dfea59b@mail.gmail.com>
Message-ID: <43FF59E0.5050508@jazillian.com>

Instead of "Flux", how about "Disinfester" - something that removes bugs.
Or maybe "Flummox" :)

When you incorporate, your lawyer will do some kind of "trademark 
search" to make sure that
your name is not trademarked or otherwise "taken". I don't know the 
details of what they do, other
than they charge you money for it :)

Andy

Prashant Deva wrote:

> I guess everyone here who knows about the ANTLR Studio ide, knows 
> about the amazing 'Flux Debugger' which allows you to debug grammar 
> files with java code.
>
> Apparently the term 'Flux' is trademarked by 'Flux Corp.' ( 
> fluxbpm.com <http://fluxbpm.com>). They have requested me to change 
> the name of Flux Debugger to something else. I have accepted their 
> request.
>
> So if any of you have any nice names in mind for the Flux Debugger, 
> feel free to suggest them :)
>
> For full detail on this, look at my blog entry here-
> http://placidsystems.com/blog/2006/02/no-more-flux-in-flux-debugger.html
>
> Thanks,
> -- 
> Prashant Deva
> Creator, ANTLR Studio
> Founder, Placid Systems, www.placidsystems.com 
> <http://www.placidsystems.com>


From prashant.deva at gmail.com  Fri Feb 24 11:20:22 2006
From: prashant.deva at gmail.com (Prashant Deva)
Date: Fri Feb 24 11:20:25 2006
Subject: [antlr-interest] Need another name for ANTLR Studio's Flux
	Debugger
In-Reply-To: <43FF59E0.5050508@jazillian.com>
References: <41fed8f80602241047y25f7f193h40bef3249dfea59b@mail.gmail.com>
	<43FF59E0.5050508@jazillian.com>
Message-ID: <41fed8f80602241120r4752fa4dl96b1ac8a333fe92e@mail.gmail.com>

>
> When you incorporate, your lawyer will do some kind of "trademark
> search" to make sure that
> your name is not trademarked


Do trademarks in one country, eg India, hold in other countries, like US?


--
Prashant Deva
Creator, ANTLR Studio
Founder, Placid Systems, www.placidsystems.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060225/ed6b2156/attachment.html
From gbr at newtechlaw.com  Fri Feb 24 11:32:19 2006
From: gbr at newtechlaw.com (Gerald B. Rosenberg)
Date: Fri Feb 24 11:32:32 2006
Subject: [antlr-interest] Need another name for ANTLR Studio's Flux
	Debugger
Message-ID: <4.3.2.7.2.20060224113205.0ae7f1b0@pop3.newtechlaw.com>

At 11:09 AM 2/24/2006, you wrote:

>When you incorporate, your lawyer will do some kind of "trademark search" 
>to make sure that
>your name is not trademarked or otherwise "taken".


Lots of good TM information here:

www.uspto.gov/main/trademarks.htm

Easy to perform a preliminary TM search yourself:

http://tess2.uspto.gov/bin/gate.exe?f=login&p_lang=english&p_d=trmk

IAALBTINLA ;)
----
Gerald B. Rosenberg, Esq.
NewTechLaw
285 Hamilton Avenue, Suite 520
Palo Alto, CA  94301-2576

650.325.2100  (office)  /  650.703.1724  (cell)
650.325.2107  (facsimile)

www.newtechlaw.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060224/ef362643/attachment.html
From ewbank at gmail.com  Fri Feb 24 12:14:02 2006
From: ewbank at gmail.com (Bryan Ewbank)
Date: Fri Feb 24 12:14:05 2006
Subject: [antlr-interest] Implementing Preprocessor Functions
In-Reply-To: <F811E702E247DF47BFB8B8057E423401013153@sydmail.iesys.com.au>
References: <F811E702E247DF47BFB8B8057E423401013153@sydmail.iesys.com.au>
Message-ID: <dd3a065f0602241214j181a8b4as80a36a07a471e5ef@mail.gmail.com>

If there's really a need for a meta-language (why aren't existing flow
control good enough?)...

Rather than "similar to C++'s preprocessor", why not just preprocess
with "gcc -E" to use the C++ preprocessor.  That way, you don't need
to match an existing implementation, nor document your new language.

This model makes a firewall between the preprocessor and the
scanner/parser as well.

The only problem I've had with this model is some of the edge cases
around character literals and string processing...

On 2/22/06, de Jong, Ron <ron@iesys.com.au> wrote:
> to the C++ #include, #ifdef, #else, #endif, #define....
From sunjigang1965 at yahoo.com.cn  Fri Feb 24 13:18:53 2006
From: sunjigang1965 at yahoo.com.cn (=?gb2312?q?=CB=EF=BC=CD=B8=D5=20Jigang=20(Robert)=20Sun?=)
Date: Fri Feb 24 13:18:57 2006
Subject: [antlr-interest] Tree generation qestion 
Message-ID: <20060224211853.68753.qmail@web15707.mail.cnb.yahoo.com>

Code generated by the attached grammar only produces a
root StatementList node contains an empty list of
Statement. After remove ! from end of 
"statementList", desired result got. Is this normal?

While the following grammar works well.

formalList!
	:
	 (formal ( COMMA! formal)* { ## =
#(#[FORMAL_LIST,"FORMAL_LIST"],##); })?
	;

formal!
    :	dt:dataType id:ID<AST=MiniJava.Identifier>
	{
		## = #( #[MINI_JAVA_FORMAL, "MINI_JAVA_FORMAL"],
#dt, #id );
	}
	;

dataType
	:
	 ("int" LSQUARE)=> "int"! LSQUARE! RSQUARE
<AST=MiniJava.IntArrayType> //int []
	| "int" <AST=MiniJava.IntegerType >
	| "boolean" <AST=MiniJava.BooleanType>
	|  ID <AST=MiniJava.IdentifierType>
	;
Antlr ver is 2.7.6.

Cheers.

Jigang


		
___________________________________________________________ 
Œﬁœﬁ»›¡ø—≈ª¢œ‡≤·£¨‘≠Õºµ»¥Ûœ¬‘ÿ£¨≥¨øÏÀŸ∂»£¨∏œøÏ«¿◊¢£° 
http://cn.photos.yahoo.com
-------------- next part --------------
statementList!
	:
	(statement)* { ## = #(#[STATEMENT_LIST,"STATEMENT_LIST","MiniJava.StatementList"],##); }
	;
	
statement
	:
	"System"! DOT! "out"!  DOT! "println"! LPAREN^ <AST=MiniJava.Print> expression RPAREN! SEMI!
	| "while"! LPAREN! expression RPAREN^ <AST=MiniJava.While> statement 
	| "if"! LPAREN!  expression RPAREN^<AST=MiniJava.If> statement "else"! statement 
        | LBRACE^<AST=MiniJava.Block> statementList RBRACE! 
        | (ID BECOMES)=> ID<AST=MiniJava.Identifier> BECOMES^<AST=MiniJava.Assign> expression SEMI!//a=8;
        | ID<AST=MiniJava.Identifier> LSQUARE! expression RSQUARE^<AST=MiniJava.ArrayAssign> BECOMES! expression SEMI! //a[7]=7;
	;
	

expList
	:
	(andExp (COMMA^<AST=MiniJava.ExpList> andExp)* )? 
	;  	
	
expression     
	:
	andExp //EOF
	;		
	
andExp
	:
	lessThanExp ( AND^<AST=MiniJava.And> lessThanExp )*
	;

lessThanExp
	:
	additiveExp (LESS_THAN^ <AST=MiniJava.LessThan> additiveExp)?
	;
		
additiveExp 
	:
	timesExp ((PLUS^<AST=MiniJava.Plus>|MINUS^<AST=MiniJava.Minus>) timesExp)* 
	;
	
timesExp
	:
	prefixExp (TIMES^ <AST=MiniJava.Times>  prefixExp)* 
	;
	
prefixExp
	:
	notExp 
	|suffixExp
	;
	
notExp
	:
	BOMB^ <AST=MiniJava.Not> suffixExp
	; 	
	
suffixExp
	:
	primaryExp 
	(LSQUARE^<AST=MiniJava.ArrayLookup> andExp RSQUARE!//array[index], a[3]
	| (DOT "length")=> DOT^ <AST=MiniJava.ArrayLength> "length"!  // array.length 
	| DOT^ <AST=MiniJava.Call> ID<AST=MiniJava.Identifier> LPAREN! expList RPAREN! //classname.method(1,2,3), call a class method, class Call.cs 
	)*	
	;	    
   
primaryExp
	:
	INT <AST=MiniJava.IntegerLiteral>
	| "true" <AST=MiniJava.True>
	| "false"<AST=MiniJava.False>
	| ID <AST=MiniJava.Identifier>
	| "this" <AST=MiniJava.This>
	|("new" ID)=>"new"! ID <AST=MiniJava.NewObject> LPAREN! RPAREN!//new object
	| "new"! ("int"!  LSQUARE <AST=MiniJava.NewArray> andExp RSQUARE!) //new array creation: new int[9] primaryExp is Exp
	| LPAREN! andExp RPAREN! //primaryExp is Exp
	;

From open.zone at virgin.net  Fri Feb 24 16:16:30 2006
From: open.zone at virgin.net (Micheal J)
Date: Fri Feb 24 15:59:52 2006
Subject: [antlr-interest] Tree generation qestion 
In-Reply-To: <20060224211853.68753.qmail@web15707.mail.cnb.yahoo.com>
Message-ID: <002501c639a0$bc55d490$6502a8c0@hercules>

> Code generated by the attached grammar only produces a
> root StatementList node contains an empty list of
> Statement. After remove ! from end of 
> "statementList", desired result got. Is this normal?

Yes. "!" means don't generate standard tree creation code. You now have to
provide that yourself. For statementList, you should leave it out.

> While the following grammar works well.
> 
> formalList!
> 	:
> 	 (formal ( COMMA! formal)* { ## = 
> #(#[FORMAL_LIST,"FORMAL_LIST"],##); })?
> 	;

Strange. This should give the root node only as well.


Micheal

From prashant.deva at gmail.com  Fri Feb 24 18:46:31 2006
From: prashant.deva at gmail.com (Prashant Deva)
Date: Fri Feb 24 18:46:35 2006
Subject: [antlr-interest] Need another name for ANTLR Studio's Flux
	Debugger
In-Reply-To: <20060225002534.78528.qmail@web53011.mail.yahoo.com>
References: <41fed8f80602241047y25f7f193h40bef3249dfea59b@mail.gmail.com>
	<20060225002534.78528.qmail@web53011.mail.yahoo.com>
Message-ID: <41fed8f80602241846g28171944gdb3c5b8022b29298@mail.gmail.com>

Btw, do US trademarks even apply in India?
I mean I am located in India not in US. But FluxBpm is located and has a
trademark in the US.

--
Prashant Deva
Creator, ANTLR Studio
Founder, Placid Systems, www.placidsystems.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060225/a13482c8/attachment.html
From jbarnesweb at yahoo.com  Fri Feb 24 22:14:28 2006
From: jbarnesweb at yahoo.com (Jeff Barnes)
Date: Fri Feb 24 22:14:33 2006
Subject: [antlr-interest] disambiguation of petal identifiers
Message-ID: <20060225061428.1532.qmail@web54507.mail.yahoo.com>

This is an excerpt from my grammar file:

protected 
OBJECTS: "objects"
;

protected
OBJECTFLOWS: "objectflows"
;

protected
OBJECTFLOWLIST: "objectflow_list"
;

protected
OBJECT: "object"
;

KEYWORD_OR_IDENTIFIER:
       (OBJECTS) => OBJECTS {$setType(ID);}
   |    (OBJECTFLOWS) => OBJECTFLOWS {$setType(ID);}
   |    (OBJECTFLOWLIST) => (OBJECTFLOWLIST)
{$setType(ID);}
   |    (OBJECT) => OBJECT {$setType(OBJECT);}
   |    (ID) => ID {$setType(ID);}
;

Of course, OBJECT is the most often occurring one out
of the four...

Sigh.

Funny how little setup this joke needs.

Regards,
Jeff

From sunjigang1965 at yahoo.com.cn  Sat Feb 25 05:13:56 2006
From: sunjigang1965 at yahoo.com.cn (=?gb2312?q?=CB=EF=BC=CD=B8=D5=20Jigang=20(Robert)=20Sun?=)
Date: Sat Feb 25 05:14:03 2006
Subject: [antlr-interest] nondeterminism problem
Message-ID: <20060225131356.36062.qmail@web15707.mail.cnb.yahoo.com>

Error occurs when complie the attached grammar,

ANTLR Parser Generator   Version 2.7.6 (2005-12-22)  
1989-2005
p.g:196: warning:nondeterminism upon
p.g:196:     k==1:ID
p.g:196:     k==2:ID,LSQUARE
p.g:196:     k==3:SEMI
p.g:196:     between alt 1 and exit branch of block

line 196 is this part:

varDeclList
	:
	(varDecl)* { ## =
#(#[VAR_DECL_LIST,"VAR_DECL_LIST"],##); }
	;

I guessed it is "varDeclList  statementList" follow
set		problem. Both "varDeclList" and "statementList"
can be none,  maybe "varDeclList" could be taken as
"statementList". But no error reported when I put both
in

noComplainsTillNow
	:
	LBRACE! varDeclList  statementList
			 "return"! expression
	;

I added another token SEMI to the end,

complainsWhenSEMI_is_Added
	:
	LBRACE! varDeclList  statementList
			 "return"! expression SEMI!
	;	

error fires:

Refer code generated for "varDeclList" and "statement"
in attached file please. 

I think 
if
((LA(1)==ID||LA(1)==LITERAL_int||LA(1)==LITERAL_boolean)
&& (LA(2)==ID||LA(2)==LSQUARE) &&
(LA(3)==RSQUARE||LA(3)==SEMI))

is quite different from 
if ((LA(1)==ID) && (LA(2)==LSQUARE)) 


Cheers

Jigang

__________________________________________________
∏œøÏ◊¢≤·—≈ª¢≥¨¥Û»›¡ø√‚∑—” œ‰?
http://cn.mail.yahoo.com
-------------- next part --------------
/* this part is not passed

methodDecl
	:  "public"^<AST=MiniJava.MethodDecl> dataType ID<AST=MiniJava.Identifier> LPAREN! formalList RPAREN! 
			LBRACE! varDeclList  statementList
			 "return"! expression SEMI! RBRACE!
	;	
	
*/

complainsWhenSEMI_is_Added
	:
	LBRACE! varDeclList  statementList
			 "return"! expression SEMI! // adding SEMI!, one more token added
	;
		
noComplainsTillNow
	:
	LBRACE! varDeclList  statementList
			 "return"! expression
	;
	

formalList
	:
	 (formal ( COMMA! formal)* { ## = #(#[FORMAL_LIST,"FORMAL_LIST"],##); })?
	;

formal!
    :	dt:dataType id:ID<AST=MiniJava.Identifier>
	{
		## = #( #[MINI_JAVA_FORMAL, "MINI_JAVA_FORMAL"], #dt, #id );
	}
	;

varDeclList
	:
	(varDecl)* { ## = #(#[VAR_DECL_LIST,"VAR_DECL_LIST"],##); } //Line 196
	;
		
varDecl
	: 
	dataType ID <AST=MiniJava.Identifier> SEMI^<AST=MiniJava.VarDecl>
	;
	

dataType
	:
	 ("int" LSQUARE)=> "int"! LSQUARE! RSQUARE <AST=MiniJava.IntArrayType> //int []
	| "int" <AST=MiniJava.IntegerType >
	| "boolean" <AST=MiniJava.BooleanType>
	|  ID <AST=MiniJava.IdentifierType>
	;

statementList
	:
	(statement)* { ## = #(#[STATEMENT_LIST,"STATEMENT_LIST","MiniJava.StatementList"],##); }
	;
	
statement
	:
	"System"! DOT! "out"!  DOT! "println"! LPAREN^ <AST=MiniJava.Print> expression RPAREN! SEMI!
	| "while"! LPAREN! expression RPAREN^ <AST=MiniJava.While> statement 
        | "if"! LPAREN!  expression RPAREN^<AST=MiniJava.If> statement "else"! statement 
        | LBRACE^<AST=MiniJava.Block> statementList RBRACE! 
        | (ID BECOMES)=> ID<AST=MiniJava.Identifier> BECOMES^<AST=MiniJava.Assign> expression SEMI!//a=8;
        | ID<AST=MiniJava.Identifier> LSQUARE! expression RSQUARE^<AST=MiniJava.ArrayAssign> BECOMES! expression SEMI!//a[7]=7;
	;
	

expList
	:
	(expression (COMMA^<AST=MiniJava.ExpList> expression)* )? 
	;  	
	
expression     
	:
	andExp //EOF
	;		
	
andExp
	:
	lessThanExp ( AND^<AST=MiniJava.And> lessThanExp )*
	;

lessThanExp
	:
	additiveExp (LESS_THAN^ <AST=MiniJava.LessThan> additiveExp)?
	;
		
additiveExp 
	:
	timesExp ((PLUS^<AST=MiniJava.Plus>|MINUS^<AST=MiniJava.Minus>) timesExp)* 
	;
	
timesExp
	:
	prefixExp (TIMES^ <AST=MiniJava.Times>  prefixExp)* 
	;
	
prefixExp
	:
	notExp 
	|suffixExp
	;
	
notExp
	:
	BOMB^ <AST=MiniJava.Not> suffixExp
	; 	
	
suffixExp
	:
	primaryExp 
	(LSQUARE^<AST=MiniJava.ArrayLookup> expression RSQUARE!//array[index], a[3]
	| (DOT "length")=> DOT^ <AST=MiniJava.ArrayLength> "length"!  // array.length 
	| DOT^ <AST=MiniJava.Call> ID<AST=MiniJava.Identifier> LPAREN! expList RPAREN! //classname.method(1,2,3) 
	)*	
	;	    
   
primaryExp
	:
	INT <AST=MiniJava.IntegerLiteral>
	| "true" <AST=MiniJava.True>
	| "false"<AST=MiniJava.False>
	| ID <AST=MiniJava.Identifier>
	| "this" <AST=MiniJava.This>
	|("new" ID)=>"new"! ID <AST=MiniJava.NewObject> LPAREN! RPAREN!//new object
	| "new"! ("int"!  LSQUARE <AST=MiniJava.NewArray> andExp RSQUARE!) //new array creation: new int[9] 
	| LPAREN! expression RPAREN! 
	;

/* Code generated for varDeclList:

	public void varDeclList() //throws RecognitionException, TokenStreamException
{
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		AST varDeclList_AST = null;
		
		try {      // for error handling
			{    // ( ... )*
				for (;;)
				{
					if ((LA(1)==ID||LA(1)==LITERAL_int||LA(1)==LITERAL_boolean) && (LA(2)==ID||LA(2)==LSQUARE) && (LA(3)==RSQUARE||LA(3)==SEMI))
					{
						varDecl();
						if (0 == inputState.guessing)
						{
							astFactory.addASTChild(ref currentAST, returnAST);
						}
					}
					else 
.
.
.
.


// segment code for grammar "statement" :
				
.
.
.
else if ((LA(1)==ID) && (LA(2)==LSQUARE))
{
MiniJava.Identifier tmp35_AST = null;
tmp35_AST = (MiniJava.Identifier) astFactory.create(LT(1), "MiniJava.Identifier");
astFactory.addASTChild(ref currentAST, (AST)tmp35_AST);
match(ID);
match(LSQUARE);
expression();
if (0 == inputState.guessing)
{
	astFactory.addASTChild(ref currentAST, returnAST);
}
MiniJava.ArrayAssign tmp37_AST = null;
tmp37_AST = (MiniJava.ArrayAssign) astFactory.create(LT(1), "MiniJava.ArrayAssign");
astFactory.makeASTRoot(ref currentAST, (AST)tmp37_AST);
match(RSQUARE);
match(BECOMES);
expression();
if (0 == inputState.guessing)
{
astFactory.addASTChild(ref currentAST, returnAST);
}
	
match(SEMI);
statement_AST = currentAST.root;
}
else
.
.
.
*/
From chris at chrisseaton.com  Sat Feb 25 06:44:31 2006
From: chris at chrisseaton.com (Chris Seaton)
Date: Sat Feb 25 06:44:43 2006
Subject: [antlr-interest] Lexing C-style strings - problems matching
	characters not in vocab
Message-ID: <CA76A4A4-F773-46B3-AD4A-C691B8482723@chrisseaton.com>

Hello,

I'm writing a lexer that needs to recognise bog standard C-style strings

"like this"

At the moment I'm using the following, which seems to be how most of  
the grammars on the site also work,

STRING :
     '"' (~('\r' | '\n' | '"' | '\\') | '\\' '"')* '"'
   ;

Looking at the generated code I can see that this won't work though -  
the ~ operator doesn't match any character apart from the ones  
specified, it seems to match a set of basic characters minus the  
one's I've negated.

I don't think my STRING rule with match characters such as ?, ?, ?  
and so on. What do I do about this? Add them explicitly to the  
expression? I can't go through the entire Unicode specs adding every  
character to my rule - it would be huge.

I looked at Scanning Unicode Characters in the docs, but this only  
refers to 16bit Unicode characters - what do I do for characters  
outside this arbitary limit?

Thanks very much.

Chris Seaton
From ric.klaren at gmail.com  Sat Feb 25 11:03:56 2006
From: ric.klaren at gmail.com (Ric Klaren)
Date: Sat Feb 25 11:04:00 2006
Subject: [antlr-interest] Lexing C-style strings - problems matching
	characters not in vocab
In-Reply-To: <CA76A4A4-F773-46B3-AD4A-C691B8482723@chrisseaton.com>
References: <CA76A4A4-F773-46B3-AD4A-C691B8482723@chrisseaton.com>
Message-ID: <bc607a4e0602251103r38e74125h46c55880a8e14f59@mail.gmail.com>

On 2/25/06, Chris Seaton <chris@chrisseaton.com> wrote:
> At the moment I'm using the following, which seems to be how most of
> the grammars on the site also work,
>
> STRING :
>      '"' (~('\r' | '\n' | '"' | '\\') | '\\' '"')* '"'
>    ;
>
> Looking at the generated code I can see that this won't work though -
> the ~ operator doesn't match any character apart from the ones
> specified, it seems to match a set of basic characters minus the
> one's I've negated.

You have to set the charVocabulary option to make the ~ operator behave.

Cheers,

Ric
From mail at martin-probst.com  Sat Feb 25 14:57:59 2006
From: mail at martin-probst.com (Martin Probst)
Date: Sat Feb 25 14:58:04 2006
Subject: [antlr-interest] Lexing C-style strings - problems matching
	characters not in vocab
In-Reply-To: <CA76A4A4-F773-46B3-AD4A-C691B8482723@chrisseaton.com>
References: <CA76A4A4-F773-46B3-AD4A-C691B8482723@chrisseaton.com>
Message-ID: <1140908279.5694.4.camel@localhost.localdomain>

Hi,

> I don't think my STRING rule with match characters such as ?, ?, ?  
> and so on. What do I do about this? Add them explicitly to the  
> expression? I can't go through the entire Unicode specs adding every  
> character to my rule - it would be huge.
> 
> I looked at Scanning Unicode Characters in the docs, but this only  
> refers to 16bit Unicode characters - what do I do for characters  
> outside this arbitary limit?

Well, to Java 16bit is all Unicode. For Java characters outside of the
16bit range are represented by surrogate pairs, as far as I know. As
someone else said, you can use the charVocabulary option to include more
characters. If you use C++, it's going to be more difficult though.

Writing down all Unicode characters actually isn't that horrible. You
can use character ranges and end up with something sensible. I once ran
into a problem though when entering the character ranges from the XML
standard - the ANTLR generated arrays got too big for the Java compiler
and classformat :-(

Martin

From danspaven at hotmail.com  Sat Feb 25 16:55:30 2006
From: danspaven at hotmail.com (Dan Spaven)
Date: Sat Feb 25 16:55:33 2006
Subject: [antlr-interest] Wrong rule in parser gets matched
Message-ID: <BAY101-F54B5DA2E98D6DD79C96B4BBF10@phx.gbl>

Hi there,
I keep on getting an error at runtime because my parser is matching the  
wrong rule. Every time an expression is parsed that assigns a value to a 
variable reference, the "sensorCont" rule is matched instead. I understand 
that this is because both statements can start with an IDENT but i can't for 
the life of me solve the problem. Could this be solved by a semantic 
predicate that somehow recognises the variable type? Or does my code need 
restructuring?

Help would be very much appreciated unfortunately i'm not only a newbie to 
ANTLR but parsing in general and i'm finding the learning curve very hard 
going.

Here below is a simplified version of my code showing the statements that 
are the problem.

statement
	:	sensorDec
	|	sensorCont
	|	expression
	;

sensorDec //declaration of sensor reference variable
	:	"sensor"^ IDENT "on"! INT
	;

sensorCont //Defines sensor attributes
	:	IDENT "is"^ type ("as" mode)*
	|	IDENT "as"^ mode
	;
type
	:	"unknown"
	|	"switch"
	|	"temperature"
	|	"light"
	|	"rotation"
	;

mode
	:	"raw"
	|	"boolean"
	|	"transition"
	|	"periodic"
	|	"percent"
	|	"celsius"
	|	"fahrenheit"
	|	"angle"
	;

expression
	:	addExpr
		(
			ASSIGN^
			expression
		)?
	;

addExpr
	:	multExpr
		(
			pm:PLUS_MINUS^ {System.out.println("matched PLUS-MINUS");}
			me:multExpr
			exception
				catch [ RecognitionException ex ]
				{
					System.out.println("Caught error in addExpr");
					reportError(ex.toString());
				}
		)*
	;

multExpr
	:	unaryExpression
		(
			MULT_DIV^ {System.out.println("matched MULT_DIV");}
			unaryExpression
		)*
	;

unaryExpression
	:	MINUS^ atom {System.out.println("matched UNARY MINUS");}
	|	PLUS^ atom {System.out.println("matched UNARY PLUS");}

	;


atom	:	a:IDENT {System.out.println(a.getText());}
	|	b:INT {System.out.println(b.getText());}
	|	LPAREN! expression RPAREN! {System.out.println("CALLING EXPRESSION in 
atom");}
	;

Thanks for any replies,

Dan


From jbarnesweb at yahoo.com  Sat Feb 25 17:52:06 2006
From: jbarnesweb at yahoo.com (Jeff Barnes)
Date: Sat Feb 25 17:52:09 2006
Subject: [antlr-interest] Lexing C-style strings - problems matching
	characters not in vocab
In-Reply-To: <1140908279.5694.4.camel@localhost.localdomain>
Message-ID: <20060226015206.63927.qmail@web54507.mail.yahoo.com>

I recently had to convert IBM EBCDIC character sets to
Java's Unicode. I implemented a
java.nio.charset.spi.CharsetProvider that used
Unicode's Charset ML to map characters (see
http://www.unicode.org/unicode/reports/tr22/).

If this helps, I'd be happy to post code.

Regards,
Jeff

--- Martin Probst <mail@martin-probst.com> wrote:

> Hi,
> 
> > I don't think my STRING rule with match characters
> such as ?, ?, ?  
> > and so on. What do I do about this? Add them
> explicitly to the  
> > expression? I can't go through the entire Unicode
> specs adding every  
> > character to my rule - it would be huge.
> > 
> > I looked at Scanning Unicode Characters in the
> docs, but this only  
> > refers to 16bit Unicode characters - what do I do
> for characters  
> > outside this arbitary limit?
> 
> Well, to Java 16bit is all Unicode. For Java
> characters outside of the
> 16bit range are represented by surrogate pairs, as
> far as I know. As
> someone else said, you can use the charVocabulary
> option to include more
> characters. If you use C++, it's going to be more
> difficult though.
> 
> Writing down all Unicode characters actually isn't
> that horrible. You
> can use character ranges and end up with something
> sensible. I once ran
> into a problem though when entering the character
> ranges from the XML
> standard - the ANTLR generated arrays got too big
> for the Java compiler
> and classformat :-(
> 
> Martin
> 
> 


=========
Jeff Barnes
(206)245-6100


Few things are impossible to diligence and skill.
--- Samuel Johnson (Rasselas Chap. xii.)
From mail at martin-probst.com  Sun Feb 26 11:25:59 2006
From: mail at martin-probst.com (Martin Probst)
Date: Sun Feb 26 11:26:04 2006
Subject: [antlr-interest] Wrong rule in parser gets matched
In-Reply-To: <BAY101-F54B5DA2E98D6DD79C96B4BBF10@phx.gbl>
References: <BAY101-F54B5DA2E98D6DD79C96B4BBF10@phx.gbl>
Message-ID: <1140981959.7862.1.camel@localhost.localdomain>

> I understand 
> that this is because both statements can start with an IDENT but i can't for 
> the life of me solve the problem. Could this be solved by a semantic 
> predicate that somehow recognises the variable type? Or does my code need 
> restructuring?

You can try to increase lookahead to 2. Alternatively, you can use a
predicate, e.g.

expression
| ( IDENT ("is" | "as") ) => sensorCont

Martin

From danspaven at hotmail.com  Sun Feb 26 13:18:32 2006
From: danspaven at hotmail.com (Dan Spaven)
Date: Sun Feb 26 13:18:37 2006
Subject: [antlr-interest] Wrong rule in parser gets matched
In-Reply-To: <1140981959.7862.1.camel@localhost.localdomain>
Message-ID: <BAY101-F59B71B2740980136C244FBBF10@phx.gbl>

Thanks for the reply Martin but it doesn't seem to be working. My look ahead 
was 2 anyway and when i put the predicate in i got a nondetermnism error. I 
put the predicate into my sensorCont rule and not the expression rule as it 
is sensorCont that is being wrongly matched for an expression.

I've just been having a look at the code that ANTLR generates for my 
expression rules and i think here lies the problem. Here's the code ANTLR 
generates when the look ahead is 2 and there is no predicate:

public final void statement() throws RecognitionException, 
TokenStreamException {

     try {      // for error handling
	switch ( LA(1)) {
                      .
                      .   other alternatives
                      .
                      case IDENT:
	      case LITERAL_on:
                      case LITERAL_output:
	      case LITERAL_global:
                      case LITERAL_off:
	      case LITERAL_float:
	      case LITERAL_forward:
	      case LITERAL_fd:
	      case LITERAL_backward:
	      case LITERAL_bk:
	      case LITERAL_direction:
	      case LITERAL_dir:
	      case LITERAL_reverse:
	      case LITERAL_power:
	      case LITERAL_sensor:
	     {
		actionStatement();
		astFactory.addASTChild(currentAST, returnAST);
		statement_AST = (antlr.CommonAST)currentAST.root;
		break;
	     }
                      case MINUS:
	      case PLUS:
	     {
		expression();
		astFactory.addASTChild(currentAST, returnAST);
		System.out.println("called expression STATEMENT");
		statement_AST = (antlr.CommonAST)currentAST.root;
		break;
	     }
          }

As you can see it only ever tests a lookahead of 1. Also and expression is 
matched when the lookahead is a MINUS or a PLUS no mention of ASSIGN at all. 
Can anyone enlighten me on why this code is generated and is it my 
expression code that needs to be changed?

Thanks,

Dan


>From: Martin Probst <mail@martin-probst.com>
>To: antlr-interest@antlr.org
>Subject: Re: [antlr-interest] Wrong rule in parser gets matched
>Date: Sun, 26 Feb 2006 20:25:59 +0100
>
> > I understand
> > that this is because both statements can start with an IDENT but i can't 
>for
> > the life of me solve the problem. Could this be solved by a semantic
> > predicate that somehow recognises the variable type? Or does my code 
>need
> > restructuring?
>
>You can try to increase lookahead to 2. Alternatively, you can use a
>predicate, e.g.
>
>expression
>| ( IDENT ("is" | "as") ) => sensorCont
>
>Martin
>


From james.x.matthews at imperial.ac.uk  Sun Feb 26 17:09:15 2006
From: james.x.matthews at imperial.ac.uk (James Matthews)
Date: Sun Feb 26 17:09:05 2006
Subject: [antlr-interest] A parser nondeterminism error I just can't get my
	head around...
Message-ID: <4402513B.6050208@imperial.ac.uk>

Hi,

I apologies in advance if I'm missing something fundamental here, but 
I've been puzzling over this for a while and I'm stuck, so I thought I'd 
ask you guys.

To save you reading through all my grammar, I have broken the problem 
down to the simplest form I can find.

Can anyone please explain why:

   a : IDENT LPAREN (b)? RPAREN
       | LPAREN  a  RPAREN;

   b:  a
       | IDENT;


works fine with k=2, but

   a : IDENT LPAREN (b)? RPAREN
       | LPAREN  a  RPAREN
       | INT;

   b:  a
       | IDENT;


gives me the error on k=2:

model.g:118:5: warning:nondeterminism between alts 1 and 2 of block upon
model.g:118:5:     k==1:IDENT
model.g:118:5:     k==2:RPAREN

(and will not work for any k)

I do not understand why adding in the INT option makes any difference?

Many thanks if anyone can help,

James


P.S. If anyone feels it is easier for me to try and explain what I'm 
trying to achieve, here you go:

In the modeling language I am creating, I have an expression which as 
well as having the standard int, string, variable and boolean atoms, I 
would also like function calls which I would like to look like:  
"functionName(arg1, arg2 ... argN)".

The functions are passed a list of arguments, which can be of two types, 
another expression or an IDENT (representing a resource in my model). 
There is no sole IDENT in the expression and every function call must 
start IDENT LPAREN, so I was hoping k=2 should uniquely distinguish the 
two.

With the grammar below, I get the same error as above. However, I have 
discovered that if I remove all the "STRING_LITERAL | INT | VARIABLE  | 
"FALSE" | "TRUE"" base options from my expression, it works (but is not 
much use!)

expression   : or_expr ( IMPLIES ^ or_expr )*;
or_expr   : and_expr ( OR ^ and_expr )* ;
and_expr     : not_expr ( AND ^ not_expr ) * ;
not_expr : NOT ^ not_expr            | expr  ( ( NOT_EQUALS ^ | LTE ^ | 
LT ^ |
                      GTE ^ | GT ^ | EQUALS ^) expr )? ;
expr : MINUS ^ term
    |  term   (( PLUS ^ | MINUS ^ ) term )* ;
term : factor ( (TIMES ^ | DIV ^) factor)* ;

factor : STRING_LITERAL | INT | VARIABLE |"FALSE" | "TRUE" | function | 
LPAREN !  expression  RPAREN !;

function: IDENT^ LPAREN! (arguements)? RPAREN!;

arguements:  (expression | IDENT) (COMMA! (expression | IDENT))* ;
From ewbank at gmail.com  Sun Feb 26 17:18:51 2006
From: ewbank at gmail.com (Bryan Ewbank)
Date: Sun Feb 26 17:18:53 2006
Subject: [antlr-interest] Wrong rule in parser gets matched
In-Reply-To: <BAY101-F54B5DA2E98D6DD79C96B4BBF10@phx.gbl>
References: <BAY101-F54B5DA2E98D6DD79C96B4BBF10@phx.gbl>
Message-ID: <dd3a065f0602261718ra11dffevbb37066d4aa0f362@mail.gmail.com>

Dan,

The problem is, I think, that you didn't do what you thought you did in the
grammar.  Specifically, IDENT does not match an expression because
unaryExpression **requires** either a PLUS or MINUS before the identifier.
What you probably want is this:

    // first and second alternative consume unary operators; third alternative
    // is matched when there are no unary operators left...
    unaryExpression
            :       MINUS^ unaryExpression 
{System.out.println("matched UNARY MINUS");}
            |       PLUS^ unaryExpression  
{System.out.println("matched UNARY PLUS");}
            |       atom                   
{System.out.println("matched bar atom");}
            ;

sensorCont still looks a bit suspect with the "is" alternative -- why
is there ( )*
around the trailing "as" suffix, and why is the tree-shape different than for
the "as" alternative?

> statement
>         :       sensorDec
>         |       expression
>         ;
>
> expression
>         :       addExpr
>                 ( ASSIGN^ expression
>                 | "is"^ type ("as" mode)* // require addExpr to be IDENT
>                 | "as"^ mode              // require addExpr to be IDENT
>                 )?
>         ;

This focuses on the syntax of the language, rather than the meaning of that
syntax.

Hope this helps,
- Bryan
From mark.felzer at gmail.com  Sun Feb 26 20:36:30 2006
From: mark.felzer at gmail.com (Mark Felzer)
Date: Sun Feb 26 20:36:34 2006
Subject: [antlr-interest] Examples of extending CommonAST and
	instantantiating it inside the Parser
Message-ID: <b6a7b26c0602262036p4a3e390bta595be6e17f3d36d@mail.gmail.com>

Hey guys and gals,

Can someone direct me to a good examples of extending CommonAST and how to
instantatiate the custom Nodes inside of the Parser?

Thank You In Advance,
Mark F.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060226/b84953b5/attachment.html
From danspaven at hotmail.com  Mon Feb 27 02:56:43 2006
From: danspaven at hotmail.com (Dan Spaven)
Date: Mon Feb 27 02:56:51 2006
Subject: [antlr-interest] Wrong rule in parser gets matched
In-Reply-To: <dd3a065f0602261718ra11dffevbb37066d4aa0f362@mail.gmail.com>
Message-ID: <BAY101-F2148D49DC357131D618003BBF60@phx.gbl>

Thanks Bryan that cleared a few things up. The ( )* is sensorCont is a 
mistake, it was supposed to be an optional append that i've now changed to ( 
)?

With regards to the tree created i wouldn't be surprised if it looks a bit 
suspicious i'm still very much finding my way on that front. I'm not sure, 
but i don't think in my case the structure of the tree matters that much as 
i'm just using it to emit bytecode. The only reason i am infact constructing 
a tree is i wanted to record information about the function calls before 
emitting any bytecode.

Thanks for your help,

Dan


>From: "Bryan Ewbank" <ewbank@gmail.com>
>To: antlr-interest@antlr.org
>Subject: Re: [antlr-interest] Wrong rule in parser gets matched
>Date: Sun, 26 Feb 2006 20:18:51 -0500
>
>Dan,
>
>The problem is, I think, that you didn't do what you thought you did in the
>grammar.  Specifically, IDENT does not match an expression because
>unaryExpression **requires** either a PLUS or MINUS before the identifier.
>What you probably want is this:
>
>     // first and second alternative consume unary operators; third 
>alternative
>     // is matched when there are no unary operators left...
>     unaryExpression
>             :       MINUS^ unaryExpression
>{System.out.println("matched UNARY MINUS");}
>             |       PLUS^ unaryExpression
>{System.out.println("matched UNARY PLUS");}
>             |       atom
>{System.out.println("matched bar atom");}
>             ;
>
>sensorCont still looks a bit suspect with the "is" alternative -- why
>is there ( )*
>around the trailing "as" suffix, and why is the tree-shape different than 
>for
>the "as" alternative?
>
> > statement
> >         :       sensorDec
> >         |       expression
> >         ;
> >
> > expression
> >         :       addExpr
> >                 ( ASSIGN^ expression
> >                 | "is"^ type ("as" mode)* // require addExpr to be IDENT
> >                 | "as"^ mode              // require addExpr to be IDENT
> >                 )?
> >         ;
>
>This focuses on the syntax of the language, rather than the meaning of that
>syntax.
>
>Hope this helps,
>- Bryan


From sunjigang1965 at yahoo.com.cn  Mon Feb 27 03:37:06 2006
From: sunjigang1965 at yahoo.com.cn (=?gb2312?q?=CB=EF=BC=CD=B8=D5=20Jigang=20(Robert)=20Sun?=)
Date: Mon Feb 27 03:37:36 2006
Subject: =?gb2312?q?=BB=D8=B8=B4=A3=BA=20[antlr-interest]=20Examples=20of=20extend?=
	=?gb2312?q?ing=20CommonAST=20and=20instantantiating=20it=20inside=20the?=
	=?gb2312?q?=20Parser?=
In-Reply-To: <b6a7b26c0602262036p4a3e390bta595be6e17f3d36d@mail.gmail.com>
Message-ID: <20060227113706.63095.qmail@web15708.mail.cnb.yahoo.com>

Do you mean to create your own class object? If so,
the example told by Michael J, which is located in
antlr's source distribution, i.e.if you downloaded
antlr 2.7.6 onto c:, then it is in
C:\antlr-2.7.6\examples\csharp\heteroAST is a good
start.

Jigang  



--- Mark Felzer <mark.felzer@gmail.com>–¥µ¿:

> Hey guys and gals,
> 
> Can someone direct me to a good examples of
> extending CommonAST and how to
> instantatiate the custom Nodes inside of the Parser?
> 
> Thank You In Advance,
> Mark F.
> 



	

	
		
___________________________________________________________ 
—≈ª¢1G√‚∑—” œ‰∞Ÿ∑÷∞Ÿ∑¿¿¨ª¯–≈ 
http://cn.mail.yahoo.com/
From dejan.jovanovic at gmail.com  Mon Feb 27 08:21:25 2006
From: dejan.jovanovic at gmail.com (=?UTF-8?B?RGVqYW4gSm92YW5vdmnEhw==?=)
Date: Mon Feb 27 08:21:27 2006
Subject: [antlr-interest] C++ namespace/documentation
Message-ID: <44032705.1020203@gmail.com>

Hi,

I am using antlr 2.7.6 in C++ mode.

Is it possible to get rid of the ANTLR_BEGIN_NAMESPACE(parser) macros in
the generated sources and get the namespace declarations directly?

I need this because I am generating documentation from the sources using
doxygen, and it doesn't recognise the namespaces defined in this way.
The eclipse CDT also doesn't handle these macros which results in wrong
error annotations in the source.

Best, Dejan
From ric.klaren at gmail.com  Mon Feb 27 08:52:44 2006
From: ric.klaren at gmail.com (Ric Klaren)
Date: Mon Feb 27 08:52:47 2006
Subject: [antlr-interest] C++ namespace/documentation
In-Reply-To: <44032705.1020203@gmail.com>
References: <44032705.1020203@gmail.com>
Message-ID: <bc607a4e0602270852s25781b37h80f4a75485458f64@mail.gmail.com>

Hi,

On 2/27/06, Dejan Jovanovi? <dejan.jovanovic@gmail.com> wrote:
> I am using antlr 2.7.6 in C++ mode.
>
> Is it possible to get rid of the ANTLR_BEGIN_NAMESPACE(parser) macros in
> the generated sources and get the namespace declarations directly?

Currently not, for antlr 3 this may be possible. (but antlr3 is still
not for primetime) Well for antlr2 you might change the
CppCodegenerator.java and rebuild (should be straightforward).

> I need this because I am generating documentation from the sources using
> doxygen, and it doesn't recognise the namespaces defined in this way.

You can fix this according by telling doxygen to preprocess them:

http://www.stack.nl/~dimitri/doxygen/preprocessing.html

> The eclipse CDT also doesn't handle these macros which results in wrong
> error annotations in the source.

Don't know if there's a way to work around it for eclipse.

Cheers,

Ric
From a_shivaswamy at hotmail.com  Mon Feb 27 09:02:48 2006
From: a_shivaswamy at hotmail.com (Aparna Shivaswamy)
Date: Mon Feb 27 09:02:54 2006
Subject: [antlr-interest] Query regarding Error handling in Antlr parser
Message-ID: <BAY109-F134712408EDE77FEE453FFE5F60@phx.gbl>

Hi,
I see that all the functions in the parser code handle execeptions by 
calling restore(). This does not work very well for the application I am 
working on. There is no way to catch an error as no exceptions are thrown 
and there is no return value that indicates that there was an error. This 
results in a core dump in my application in case of an invalid input.
I have had to manually change the auto generated parser to throw exceptions 
instead of calling restore.
Is there a way to specify this in the grammar file?
Pl: I am using antlr version 2.7.5
Thanks,
Aparna

_________________________________________________________________
Is your PC infected? Get a FREE online computer virus scan from McAfeeÆ 
Security. http://clinic.mcafee.com/clinic/ibuy/campaign.asp?cid=3963

From seclib at seclib.com  Mon Feb 27 09:41:14 2006
From: seclib at seclib.com (Xue Yong Zhi)
Date: Mon Feb 27 09:42:34 2006
Subject: [antlr-interest] Re: A parser nondeterminism error I just can't get
	my head around...
In-Reply-To: <4402513B.6050208@imperial.ac.uk>
References: <4402513B.6050208@imperial.ac.uk>
Message-ID: <440339BA.2000500@seclib.com>

If you see no-sense nondeterminism errors from Antlr, there is great 
chance that you meet "linear approximate lookahead".

First I recommend the following articles:

http://www.antlr.org/doc/glossary.html#Linear_approximate_lookahead
and related entries in antlr's FAQ.
http://seclib.blogspot.com/2005/11/linear-approximate-lookahead.html

As for your grammar, when you add "INT" into rule "a", and since k=2, 
"whatever follows" rule will apply. In other words, FIRST(a) will 
include "INT whatever_token_follows". And at the same time, "linear 
approximate lookahead" will compress the lookahead set, and FIRST(a) 
will contain "IDENT whatever_token_follows" (therefore "IDENT RPAREN" is 
part of it).

In more details:
After rule "a" mathched "IDENT LPAREN", it will try to see if it should 
enter rule "b" (since b is optional).
For LA(1) == IDENT and LA(2) == RPAREN, it can either:
a) match "IDENT" as b, then match "RPAREN" as exit branch
b) try to match entire "IDENT RPAREN" as rule b , then blow up (since b 
does not accept it)!
But at that moment, antlr does not know where to to becuase "linear 
approximate lookahead" make it think "IDENT RPAREN" is valid lookahead 
set for rule a.(IDENT come from the first alt of rule a, RPAREN comes 
from the third alt of rule a-- remember "whatever follows" rule).


James Matthews wrote:

> 
> works fine with k=2, but
> 
>   a : IDENT LPAREN (b)? RPAREN
>       | LPAREN  a  RPAREN
>       | INT;
> 
>   b:  a
>       | IDENT;
> 
> 
> gives me the error on k=2:
> 
> model.g:118:5: warning:nondeterminism between alts 1 and 2 of block upon
> model.g:118:5:     k==1:IDENT
> model.g:118:5:     k==2:RPAREN
> 
> (and will not work for any k)
> 


-- 
Xue Yong Zhi
http://seclib.blogspot.com

From mail at martin-probst.com  Mon Feb 27 09:51:28 2006
From: mail at martin-probst.com (Martin Probst)
Date: Mon Feb 27 09:51:46 2006
Subject: [antlr-interest] Query regarding Error handling in Antlr parser
In-Reply-To: <BAY109-F134712408EDE77FEE453FFE5F60@phx.gbl>
References: <BAY109-F134712408EDE77FEE453FFE5F60@phx.gbl>
Message-ID: <1141062688.8687.21.camel@localhost.localdomain>

> I see that all the functions in the parser code handle execeptions by 
> calling restore(). This does not work very well for the application I am 
> working on. There is no way to catch an error as no exceptions are thrown 
> and there is no return value that indicates that there was an error. This 
> results in a core dump in my application in case of an invalid input.
> I have had to manually change the auto generated parser to throw exceptions 
> instead of calling restore.
> Is there a way to specify this in the grammar file?

defaultErrorHandler = false;

Martin

From ruben.laguna at gmail.com  Mon Feb 27 13:28:34 2006
From: ruben.laguna at gmail.com (Ruben Laguna)
Date: Mon Feb 27 13:28:37 2006
Subject: [antlr-interest] lexical nondeterminism
Message-ID: <f8d56a4d0602271328q4339406hc530655f58e370f2@mail.gmail.com>

Hello,

I have the following two lexical rules

BINDRULEKEYWORD: ("user" ("dn"|"attr")) | "groupdn" | "roledn"  |"ip" ;
RIGHT          : "read" | "write" | "add" | "delete" | ("se" ("arch"
|"lfwrite")) | "compare" | "proxy" ;

which give me the following warnings when I try to compile them
warning:lexical nondeterminism between rules BINDRULEKEYWORD and RIGHT upon
     k==1:'r'
     k==2:'o','r'
     k==3:'l','o'
     k==4:<end-of-token>,'e','r'
     k==5:<end-of-token>,'a'
     k==6:<end-of-token>

I've read about the linear approximate lookahead and I understand that this
is the problem but I haven't found which is the right way to tweak the
grammar file to bea ble to parse correctly "roledn" as a BINDRULEKEYWORD
token.

What are the ways to handle this nondeterminism?

do i need to set up two lexers one for the RIGHT rule and one for the
BINDRULEKEYWORD and then change the parsers rules to switch between lexer
with TokenStreamSelector or there is a better way to handle this?


Thanks in advance /Rub?n Laguna


--
/Rub?n
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060227/1e1da895/attachment.html
From seclib at seclib.com  Mon Feb 27 14:38:52 2006
From: seclib at seclib.com (Xue Yong Zhi)
Date: Mon Feb 27 14:39:31 2006
Subject: [antlr-interest] Re: lexical nondeterminism
In-Reply-To: <f8d56a4d0602271328q4339406hc530655f58e370f2@mail.gmail.com>
References: <f8d56a4d0602271328q4339406hc530655f58e370f2@mail.gmail.com>
Message-ID: <44037F7C.3020205@seclib.com>

Ruben Laguna wrote:
> Hello,
> 
> I have the following two lexical rules
> 

> 
> which give me the following warnings when I try to compile them
> warning:lexical nondeterminism between rules BINDRULEKEYWORD and RIGHT upon
>      k==1:'r'
>      k==2:'o','r'
>      k==3:'l','o'
>      k==4:<end-of-token>,'e','r'
>      k==5:<end-of-token>,'a'
>      k==6:<end-of-token>
> 
> I've read about the linear approximate lookahead and I understand that 
> this is the problem but I haven't found which is the right way to tweak 
> the grammar file to bea ble to parse correctly "roledn" as a 
> BINDRULEKEYWORD token.

Right, what you saw is linear approximate lookahead.

> What are the ways to handle this nondeterminism?
> 
> do i need to set up two lexers one for the RIGHT rule and one for the 
> BINDRULEKEYWORD and then change the parsers rules to switch between 
> lexer with TokenStreamSelector or there is a better way to handle this?
> 

That's overkill.

A easy fix can be:
Make BINDRULEKEYWORD and RIGHT "protected".

Then add a new one:
BINDRULEKEYWORD_OR_RIGHT
:BINDRULEKEYWORD {$setType(BINDRULEKEYWORD);}
| RIGHT {$setType(RIGHT);}
;

-- 
Xue Yong Zhi
http://seclib.blogspot.com

From zara.sheil at ucdconnect.ie  Tue Feb 28 04:01:33 2006
From: zara.sheil at ucdconnect.ie (Zara Jane Sheil)
Date: Tue Feb 28 04:01:39 2006
Subject: [antlr-interest] unexpected AST node
Message-ID: <5065299.1141128093395.JavaMail.cpadmin@mass>

Hi,
Im trying to build a parser that acts as a calculator as well as 
recognizing ==,>,>=,<,<=,& and |.

At the moment when I run the code it can determine that the input:
5==5 & 5>3
returns a true value.

However, it also prints out the following error msgs:
<AST>:0:0: unexpected AST node: &
0
<AST>:0:0: unexpected AST node: &
false
Also, when I give it input 3+4 it can return the value 7 but gives an 
error msg:
<AST>:0:0: unexpected AST node: +
false
<AST>:0:0: unexpected AST node: +
false
This happens for all input. Im not sure if theres something wrong with 
the grammar or my Main file.

Im also trying to put in a logical NOT !, any advice on how I might be 
able to achieve this?
Attached is the grammar file and my Main.
Thanks,
Zara

-------------- next part --------------
import antlr.*;
import antlr.collections.*;

public class Main {
    public static void main(String[] args) throws Exception {
        ExprLexer lexer = new ExprLexer(System.in);
        ExprParser parser = new ExprParser(lexer);
        parser.logicalOrExpression();
        AST t = parser.getAST();
        System.out.println(t.toStringTree());
        ExprTreeParser treeParser = new ExprTreeParser();
        //parser.expr();
	int y = treeParser.expr(t);
	System.out.println(y);
        boolean k = treeParser.bexpr(t);
        System.out.println(k);
        boolean w = treeParser.lexpr(t);
        System.out.println(w);
    }
}

-------------- next part --------------
class ExprParser extends Parser;

options {

buildAST = true;
defaultErrorHandler = false;

}

logicalOrExpression: logicalAndExpression (OR^ logicalAndExpression)*
;

logicalAndExpression: bexpr (AND^ bexpr)*
;

bexpr: expr ((EQUALS^|NOT_EQUALS^|GT^|GTE^|LT^|LTE^) expr)*
;

expr: mexpr ((PLUS^|MINUS^) mexpr)*
;

mexpr: atom ((MULT^|DIV^) atom)*
;

atom: INT

| LPAREN! logicalOrExpression RPAREN!

// | LPAREN! logicalOrExpression RPAREN!

;

class ExprLexer extends Lexer;

options {

k = 2; // two characters of lookahead

}

/* Integers */

INT : ('0'..'9')+ ;

/* Ignored characters */

WS
    :   '\r' '\n'   // DOS
    |   '\n'        // UNIX
    |   ' ' {$setType(Token.SKIP);} //ignore this token
    ;

/* Logical operators */

OR : "|";

AND : "&";

/* Comparison operators */

EQUALS : "==";

NOT_EQUALS : "<>";

GT : '>';

GTE : ">=";

LT : '<';

LTE : "<=";

/* Arithmetic operators */

PLUS : '+';

MINUS : '-';

MULT : '*';

DIV : '/';

/* Parentheses */

LPAREN : '(';

RPAREN : ')';

class ExprTreeParser extends TreeParser;

options {
importVocab=ExprParser;
}

expr returns [int r=0] { int a,b;}

: #(PLUS a=expr b=expr) { r = a + b;}
| #(MINUS a=expr b=expr) { r = a - b; }
| #(MULT a=expr b=expr) { r = a * b; }
| #(DIV a=expr b=expr) { r = a / b; }
| i:INT {r = (int)Integer.parseInt(i.getText());}
;

bexpr returns [boolean r=false] {int a,b;}
: #(EQUALS a=expr b=expr) { r = a == b; }
| #(GT a=expr b=expr) { r = a > b; }
| #(GTE a=expr b=expr) { r = a >= b; }
| #(LT a=expr b=expr) { r = a < b; }
| #(LTE a=expr b=expr) { r = a <= b; }
;

lexpr returns [boolean r= false] {boolean a, b;}
: #(OR a=bexpr b=bexpr) { r = a || b; }
| #(AND a=bexpr b=bexpr) { r = a && b; }

;



From jtl at ira.uka.de  Tue Feb 28 08:00:10 2006
From: jtl at ira.uka.de (Joshua LeVasseur)
Date: Tue Feb 28 07:58:55 2006
Subject: [antlr-interest] x86 assembler parser (AT&T syntax)
Message-ID: <F20252E7-A2A5-4216-91B7-8804A83C7E92@ira.uka.de>


Hello all,

In case anyone has interest in a grammar for assembler: I wrote a  
parser, transformer, and emitter for x86 assembler (AT&T syntax).  It  
successfully parses all assembler produced in a typical Linux kernel  
build (both Linux 2.4 and 2.6).  Its performance seems pretty nice  
(using the Antlr C++ backend).

This was my first Antlr grammar, and written in a big rush, thus  
excuse strangeness in my grammar, and feel free to share critique.

The grammar file is here:
http://l4hq.org/cvsweb/cvsweb/~checkout~/afterburner/asm-parser/Asm.g

The project plus build instructions are here:
http://l4ka.org/projects/virtualization/afterburn/

Some notes about the grammar :

Assembler has many mnemonics, and I wanted the mnemonic lookups to be  
fast via the hash table.  The problem: AT&T syntax appends a suffix  
to the mnemonics to denote bit-width.  I didn't see a way to separate  
the mnemonic from the suffix in the lexer when using the hash table,  
and so the grammar is a bit verbose with the mnemonic declarations.   
I probably should generate the grammar from another grammar, to avoid  
bugs that could easily accompany all of the tedious mnemonic  
declarations.

My grammar is covered with manual tree construction commands, because  
I want a tree without any syntax residue, i.e., I want the tree nodes  
to represent an intention, independent of the syntax.  Syntax is  
controversial for x86 assembler, because it has two types of syntax,  
Intel and AT&T, which are so different that they even reverse the  
ordering of source and destination operands.  The grammar could be  
the basis of a tool that transforms between the two syntax types  
(although perhaps the grammar is too attached to AT&T syntax).

The parser is incomplete for lack of time, and because I reverse  
engineered the GNU assembler syntax (commands, macros, etc.) for lack  
of a concise definition.  My goal for the grammar is to transform the  
x86 instructions that are sensitive to privilege level, while  
ignoring everything else, and thus I implemented an overly broad  
grammar that probably accepts illegal assembler (and probably raises  
errors on valid assembler).


Joshua

From ewbank at gmail.com  Tue Feb 28 09:00:18 2006
From: ewbank at gmail.com (Bryan Ewbank)
Date: Tue Feb 28 09:00:20 2006
Subject: [antlr-interest] Re: unexpected AST node
In-Reply-To: <dd3a065f0602280859g6cb87e02q673af8dab7ad9551@mail.gmail.com>
References: <5065299.1141128093395.JavaMail.cpadmin@mass>
	<dd3a065f0602280859g6cb87e02q673af8dab7ad9551@mail.gmail.com>
Message-ID: <dd3a065f0602280900r5ec5f4f9i61480a17d48751db@mail.gmail.com>

The problem is in your main program - you are calling the tree parser
three times for the input, and only the first call can accept a "+"
node.  The other calls fail because the root node of the tree is "+".

For logical not, "!", the trick is to use right-recursion:

    not_expr
        : NOT^ not_expr
        | bexpr
        ;

This will form the necessary tree for correct evaluation

On 2/28/06, Zara Jane Sheil <zara.sheil@ucdconnect.ie> wrote:
> Also, when I give it input 3+4 it can return the value 7 but gives an error:
>   <AST>:0:0: unexpected AST node: +
>   false
>   <AST>:0:0: unexpected AST node: +
>   false
> This happens for all input. Im not sure if there's something wrong with the
> grammar or my Main file.
From Kurt at AlphaSoftware.com  Tue Feb 28 09:36:55 2006
From: Kurt at AlphaSoftware.com (Kurt Rayner)
Date: Tue Feb 28 09:38:05 2006
Subject: [antlr-interest] Parsing Nested Multi-line text
Message-ID: <!&!AAAAAAAAAAAYAAAAAAAAAAFrvD8k4y1BvmbeLFcYHNLCgAAAEAAAAPraoqujyy9PviULZJMx6hwBAAAAAA==@AlphaSoftware.com>

While re-implementing a parser for a variant of BASIC, I got stuck on this
one.

 

The existing hand-coded parser supports nested multi-line string literals
(mainly for dynamic code generation) using the following form:

 

<<%identifier%

... 

%identifier%

 

A lame example:

 

MyCodeSegment = <<%code%

if a < 12 then

            evaluate_template(<<%code%

a = 12

%code%

else

            evaluate_template(<<%code%

a = 14

%code%

end if

%code%

 

One would expect the names in the nested blocks would be different, but the
existing parser doesn't seem to care, and I have found exceptions.

Also note that the embedded text does NOT have to be parseable.

 

Here's what I've tried most recently to make the lexer handle the syntax.
ANTLR obviously doesn't like that it doesn't have sufficient look-ahead.

 

protected

MultiLineLiteralIdentifier

            :  '%' Identifier '%'

            ;

 

protected

MultiLineLiteralInitiator

            : "<<" MultiLineLiteralIdentifier

            ;

 

protected

EmbeddedMultiLineLiteral           

            :           MultiLineLiteralInitiator 

                        (options { greedy=false; } :
(EmbeddedMultiLineLiteral | .) )*

                        MultiLineLiteralIdentifier

            ;

 

ASCIIStringLiteral 

            :           ('"'!        ( ('\\'! '\\') |  ('\\'! '"') | ('"'!
'"') | (~'"'))*              '"'!)

            |           MultiLineLiteralInitiator! 

                        (options { greedy=false; } :
(EmbeddedMultiLineLiteral | .)  )*

                        MultiLineLiteralIdentifier!

            ;

 

If I were using Flex, I would just take control of the input stream, but I
would prefer to use something a little more elegant.

 

Thanks in advance for any ideas.

 

 

Kurt Rayner

Development

Alpha Software, Inc.

83 Cambridge Street, Suite 3B

Burlington, MA 01803-4483

kurt@AlphaSoftware.com

(781) 229-4500 X 27

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060228/08b89b39/attachment-0001.html
From seclib at seclib.com  Tue Feb 28 10:42:58 2006
From: seclib at seclib.com (Xue Yong Zhi)
Date: Tue Feb 28 10:44:07 2006
Subject: [antlr-interest] Re: Parsing Nested Multi-line text
In-Reply-To: <!&!AAAAAAAAAAAYAAAAAAAAAAFrvD8k4y1BvmbeLFcYHNLCgAAAEAAAAPraoqujyy9PviULZJMx6hwBAAAAAA==@AlphaSoftware.com>
References: <!&!AAAAAAAAAAAYAAAAAAAAAAFrvD8k4y1BvmbeLFcYHNLCgAAAEAAAAPraoqujyy9PviULZJMx6hwBAAAAAA==@AlphaSoftware.com>
Message-ID: <440499B2.1080107@seclib.com>

Kurt Rayner wrote:

> 
> One would expect the names in the nested blocks would be different, but 
> the existing parser doesn?t seem to care, and I have found exceptions.
> 
> Also note that the embedded text does NOT have to be parseable.
>   

Are you aware you are parsing heredoc?

In my ruby antlr parser, I overwrite the generated lexer. The lexer will 
maitain states so that it can switch from "normal" mode to "heredoc 
content" mode.

-- 
Xue Yong Zhi
http://seclib.blogspot.com

From seclib at seclib.com  Tue Feb 28 10:55:34 2006
From: seclib at seclib.com (Xue Yong Zhi)
Date: Tue Feb 28 10:56:11 2006
Subject: [antlr-interest] Re: Parsing Nested Multi-line text
In-Reply-To: <440499B2.1080107@seclib.com>
References: <!&!AAAAAAAAAAAYAAAAAAAAAAFrvD8k4y1BvmbeLFcYHNLCgAAAEAAAAPraoqujyy9PviULZJMx6hwBAAAAAA==@AlphaSoftware.com>
	<440499B2.1080107@seclib.com>
Message-ID: <44049CA6.1070307@seclib.com>

Xue Yong Zhi wrote:

> 
> Are you aware you are parsing heredoc?
> 
> In my ruby antlr parser, I overwrite the generated lexer. The lexer will 
> maitain states so that it can switch from "normal" mode to "heredoc 
> content" mode.
> 


Oops, should be "override".

btw, since heredoc content can be anything, I think overriding 
nextToken() is the only way to handle heredoc with antlr. If you have 
other good ideas let me know.


-- 
Xue Yong Zhi
http://seclib.blogspot.com

From sunjigang1965 at yahoo.com.cn  Tue Feb 28 13:53:50 2006
From: sunjigang1965 at yahoo.com.cn (=?gb2312?q?=CB=EF=BC=CD=B8=D5=20Jigang=20(Robert)=20Sun?=)
Date: Tue Feb 28 13:53:55 2006
Subject: =?gb2312?q?=BB=D8=B8=B4=A3=BA=20RE:=20[antlr-interest]=20Tree=20generatio?=
	=?gb2312?q?n=20qestion=20?=
In-Reply-To: <002501c639a0$bc55d490$6502a8c0@hercules>
Message-ID: <20060228215350.41800.qmail@web15703.mail.cnb.yahoo.com>

The code generated by following grammar 

program
	:
	m:mainClass l:classDeclList  {## = #( #[PROGRAM,
"PROGRAM","MiniJava.Program"],#m,#l);} EOF
	; 	

runs into infinite iteration at

public virtual AST make(params AST[] nodes)
{
...
     while (tail.getNextSibling() != null) //could not
get out of here
    {
        tail = tail.getNextSibling();
        Console.WriteLine(tail.GetType());//added by
me
    }
  }
return root;
}

After putting to the end of ! program, got expected
tree.

What I remember last time for formalList, I put ! to
formalList after computer got into dead iteration,
then   I continue to other grammar modification which
is irrelavant to formalList, then remove the bomb off.
It worked normally.

Jigang  


--- Micheal J <open.zone@virgin.net>–¥µ¿:

> > Code generated by the attached grammar only
> produces a
> > root StatementList node contains an empty list of
> > Statement. After remove ! from end of 
> > "statementList", desired result got. Is this
> normal?
> 
> Yes. "!" means don't generate standard tree creation
> code. You now have to
> provide that yourself. For statementList, you should
> leave it  out.
> 
> > While the following grammar works well.
> > 
> > formalList!
> > 	:
> > 	 (formal ( COMMA! formal)* { ## = 
> > #(#[FORMAL_LIST,"FORMAL_LIST"],##); })?
> > 	;
> 
> Strange. This should give the root node only as
> well.
> 
> 
> Micheal
> 
> 



		
___________________________________________________________ 
—≈ª¢1G√‚∑—” œ‰∞Ÿ∑÷∞Ÿ∑¿¿¨ª¯–≈ 
http://cn.mail.yahoo.com/
From mark.felzer at gmail.com  Tue Feb 28 18:45:08 2006
From: mark.felzer at gmail.com (Mark Felzer)
Date: Tue Feb 28 18:45:12 2006
Subject: [antlr-interest] Syntax error in action: What is wrong with my
	syntax?
Message-ID: <b6a7b26c0602281845r1aa61edk58b2a5135c4cf984@mail.gmail.com>

For some reason I keep getting a syntax error, what is wrong with with this
syntax?

typeDefinition:
        ID EQUAL! type
        { #typeDefinition= #([TYPE_DEFINITION,"TypeDefinition"], ID,
([TEST1] ID),([TEST2] type) );     }
        ;

ANTLR Parser Generator   Version 2.7.5 (20050201)   1989-2005 jGuru.com
grammer.txt:55:53: Syntax error in action: grammer.txt:55:53: expecting ')',
found 'I'
Exiting due to errors.


I want the resulting AST tree to have TYPE_DEFINITION to be the rootnode
with the first child to be ID, the second CHILD to be a subtree, and third
to also be a subtree.
TYPE_DEFINITION, TEST1, TEST2 are all imaginary nodes. I am trying to follow
an example in the "TREE CONSTRUCTION" portion of the manual.


Thank you for your help
Mark F.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20060228/84d5c499/attachment.html
From z07165864809 at 163.com  Tue Feb 28 19:44:56 2006
From: z07165864809 at 163.com (=?gb2312?B?1uzV/ca9?=)
Date: Tue Feb 28 19:44:59 2006
Subject: [antlr-interest] is this a bug?
Message-ID: <440518AB.150880.29106>


dGhlIGZvbGxvd2luZyBncmFtbWVyIGZpbGU6DQoNCm9wdGlvbnMgew0KCWxhbmd1YWdlID0gIkNw
cCI7DQp9DQpjbGFzcyBNQ1BQTGV4ZXIgZXh0ZW5kcyBMZXhlcjsNCm9wdGlvbnMNCnsNCglrID0g
MzsJLy9MTCgzKc7Et6gNCn0NCg0KLy8gstnX97f7Og0KQVNTSUdORVFVQUwgICAgCTogJz0nIDsN
CkNPTE9OICAgICAgICAgICAJOiAnOicgOw0KQ09NTUEgICAgICAgICAgCTogJywnIDsNClFVRVNU
SU9OTUFSSyAgICA6ICc/JyA7DQpTRU1JQ09MT04gICAgICAgCTogJzsnIDsNClBPSU5URVJUTyAg
ICAgICAJOiAiLT4iIDsNCi8vILXjus3KocLUusXT62Zsb2F0wODQzbXEyv3X1rPlzbujrMv50tS2
vLfFtb3K/dfWwO/D5silDQovLyBET1QJCTonLicgOw0KLy8gRUxMSVBTSVMJOiAiLi4uIiA7DQoN
CkxQQVJFTiAgICAgICAgICAJOiAnKCcgOw0KUlBBUkVOICAgICAgICAgIAk6ICcpJyA7DQpMU1FV
QVJFICAgICAgICAJOiAnWycgOw0KUlNRVUFSRSAgICAgICAgIAk6ICddJyA7DQpMQ1VSTFkgICAg
ICAgICAgCTogJ3snIDsNClJDVVJMWSAgICAgICAgIAk6ICd9JyA7DQoNCkVRVUFMICAgICAgICAg
ICAJOiAiPT0iIDsNCk5PVEVRVUFMICAgICAgICAJOiAiIT0iIDsNCkxFU1NUSEFOT1JFUVVBTFRP
ICAgICAJOiAiPD0iIDsNCkxFU1NUSEFOICAgICAgICAgICAgICAJOiAiPCIgOw0KR1JFQVRFUlRI
QU5PUkVRVUFMVE8gCTogIj49IiA7DQpHUkVBVEVSVEhBTiAgICAgICAgICAgCTogIj4iIDsNCg0K
RElWSURFICAgICAgICAgIAk6ICcvJyA7DQpESVZJREVFUVVBTCAgICAgCTogIi89IiA7DQpQTFVT
ICAgICAgICAgICAgCTogJysnIDsNClBMVVNFUVVBTCAgICAgICAJOiAiKz0iIDsNClBMVVNQTFVT
ICAgICAgICAJOiAiKysiIDsNCk1JTlVTICAgICAgICAgICAJOiAnLScgOw0KTUlOVVNFUVVBTCAg
ICAgIAk6ICItPSIgOw0KTUlOVVNNSU5VUyAgICAgIAk6ICItLSIgOw0KU1RBUiAgICAgICAgICAg
IAk6ICcqJyA7DQpUSU1FU0VRVUFMICAgICAgCTogIio9IiA7DQpNT0QgICAgICAgICAgICAJOiAn
JScgOw0KTU9ERVFVQUwgICAgICAgIAk6ICIlPSIgOw0KU0hJRlRSSUdIVCAgICAgIAk6ICI+PiIg
Ow0KU0hJRlRSSUdIVEVRVUFMCTogIj4+PSIgOw0KU0hJRlRMRUZUICAgICAgIAk6ICI8PCIgOw0K
U0hJRlRMRUZURVFVQUwgIAk6ICI8PD0iIDsNCg0KQU5EICAgICAgICAgICAgCTogIiYmIiA7DQpO
T1QgICAgICAgICAgICAJOiAnIScgOw0KT1IJCTogInx8IiA7DQoNCkFNUEVSU0FORCAgICAgICAJ
OiAnJicgOw0KQklUV0lTRUFOREVRVUFMIDogIiY9IiA7DQpUSUxERSAgICAgICAgICAgCTogJ34n
IDsNCkJJVFdJU0VPUiAgICAgICAJOiAnfCcgOw0KQklUV0lTRU9SRVFVQUwgIDogInw9IiA7DQpC
SVRXSVNFWE9SICAgICAgCTogJ14nIDsNCkJJVFdJU0VYT1JFUVVBTCA6ICJePSIgOw0KDQpQT0lO
VEVSVE9NQlIgICAgCTogIi0+KiIgOw0KRE9UTUJSICAgICAgICAgIAk6ICIuKiIgIDsNCg0KU0NP
UEUgICAgICAgICAgIAk6ICI6OiIgIDsNCg0KV2hpdGVzcGFjZQkvL7/VsNcsdmM3LjG1xGZzdHJl
YW26w8/xsrvE3Lm7tcO1vSJcciKjrNa709AnXG4nDQoJOg0KCQkgKCcgJ3wnXHQnfCdcZicgfCAo
J1xyJydcbicpfCgnXHInKXwoJ1xuJyl8ICdcXCcnXHInJ1xuJykge190dHlwZSA9IAlBTlRMUl9V
U0VfTkFNRVNQQUNFKGFudGxyKVRva2VuLlNLSVA7fQ0KCTsNCkNvbW1lbnQgIAkvL9K7ts7XosrN
DQoJOgkNCgkJIi8qIiAoIHtMQSgyKSAhPSAnLyd9PyAnKicgIHwJficqJyApKiAiKi8ie190dHlw
ZSA9IEFOVExSX1VTRV9OQU1FU1BBQ0UoYW50bHIpVG9rZW4uU0tJUDt9DQoJOw0KQ1BQQ29tbWVu
dAkvL9K70NDXosrNDQoJOgkNCgkJIi8vIiAofignXG4nIHwgJ1xyJykpKiBFbmRPZkxpbmUJe190
dHlwZSA9CUFOVExSX1VTRV9OQU1FU1BBQ0UoYW50bHIpIFRva2VuLlNLSVA7fSANCgk7DQpwcm90
ZWN0ZWQgIA0KU3BhY2UJCS8vv9W48Q0KCToJKCcgJ3wnXHQnfCdcZicpCTsNCi8vIExpdGVyYWxz
Og0KQ2hhckxpdGVyYWwJLy/X1rf7s6PBvw0KCToJJ1wnJyAoRXNjYXBlIHwgfignXCcnKSkgJ1wn
JyA7DQpTdHJpbmdMaXRlcmFsCS8v19a3+7Sus6PBv6Osv8nS1M6qv9UNCgk6CQ0KCQknIicgKCBF
c2NhcGUgfAkgKAkiXFxcclxuIiApCXwgfignIid8J1xyJ3wnXG4nfCdcXCcpKSoJJyInDQoJOw0K
cHJvdGVjdGVkDQpFbmRPZkxpbmUJLy/Su9DQveHK+KOsTWljcm9zb2Z0IMq508MiXHJcbiKjrLu5
09DKudPDJ1xyJyhNQUMpus0nXG4nKFVuaXgptcShow0KCToJDQoJCSJcclxuIiAgLy8gTVMNCgk7
DQpwcm90ZWN0ZWQNCkVzY2FwZSAgCQkvL9eq0uW3+w0KCToJDQoJCSdcXCcNCgkJKCBvcHRpb25z
e3dhcm5XaGVuRm9sbG93QW1iaWcgPSBmYWxzZTt9Og0KCQkgICAgJ2EnIHwgJ2InCXwgJ2YnfCAn
bid8ICdyJ3wgJ3QnfCAndid8ICciJ3wgJ1wnJ3wgJ1xcJ3wgJz8nDQoJCXwgKCcwJy4uJzMnKSAo
T2N0RGlnaXQoT2N0RGlnaXQpPyApPwkvLzi9+Na1yv2jrDEtM867DQoJCXwgKCc0Jy4uJzcnKSAo
T2N0RGlnaXQpPwkJCS8vOL341rXK/aOsMS0yzrsNCgkJfCAneCcgKEhleERpZ2l0KSsJCQkJLy8x
Nr341rXK/aOszrvK/cO709DP3tbGDQoJCSkNCgk7DQovLyBOdW1lcmljIENvbnN0YW50czogDQov
LyDV+8r9oaK4obXjs6PBvw0KcHJvdGVjdGVkDQpEaWdpdA0KCToJCScwJy4uJzknCTsNCnByb3Rl
Y3RlZAkNCk9jdERpZ2l0DQoJOgkJJzAnLi4nNycJOw0KcHJvdGVjdGVkCQ0KSGV4RGlnaXQJDQoJ
OgkJRGlnaXR8J2EnLi4nZid8J0EnLi4nRicJOw0KcHJvdGVjdGVkDQpEZWNpbWFsDQoJOgkJKCcw
Jy4uJzknKSsJOw0KcHJvdGVjdGVkDQpMb25nU3VmZml4DQoJOgknbCcgfCAnTCcJOw0KcHJvdGVj
dGVkDQpVbnNpZ25lZFN1ZmZpeA0KCToJJ3UnIHwgJ1UnCTsNCnByb3RlY3RlZA0KRmxvYXRTdWZm
aXgNCgk6CSdmJyB8ICdGJwk7DQpwcm90ZWN0ZWQNCkV4cG9uZW50DQoJOgkoJ2UnfCdFJykgKCcr
J3wnLScpPyAoRGlnaXQpKwk7DQpwcm90ZWN0ZWQNClZvY2FidWxhcnkNCgk6CQ0KCQknXDMnLi4n
XDM3NycJOw0KTnVtYmVyDQoJOgkNCgkJe0xBKDIpID09ICd4JyB8fCBMQSgyKSA9PSAnWCd9Pw0K
CQknMCcgKCd4JyB8ICdYJykgKEhleERpZ2l0KSsgICAgICAgICAvLzE2vfjWxiAgICAgICAgICAg
ICAgICAgICAgICAgICANCgkJKExvbmdTdWZmaXggfCBVbnNpZ25lZFN1ZmZpeCk/ICB7X3R0eXBl
ID0gSEVYSU5UO30gICANCgl8DQoJCS8ve0xBKDIpID49ICcwJyAmJiBMQSgyKSA8PSAnNyd9Pw0K
CQknMCcgKE9jdERpZ2l0KSogICAgICAgICAgICAvLzi9+NbGDQoJCShMb25nU3VmZml4IHwgVW5z
aWduZWRTdWZmaXggKT8ge190dHlwZSA9IE9DVElOVDt9DQoJfAkvLyhEaWdpdCkrIGY9RmxvYXRU
YWlsIHtpZihmPT10cnVlKXtfdHR5cGUgPSBGTE9BVDt9ZWxzZXtfdHR5cGUgPSBERUNJTlQ7fX0N
CgkJKChEaWdpdCkrICgnLicgfCBFeHBvbmVudCkpPT4NCgkJKERpZ2l0KSsgKCcuJyAoRGlnaXQp
KiAoRXhwb25lbnQpPyB8IEV4cG9uZW50KShGbG9hdFN1ZmZpeCB8IExvbmdTdWZmaXgpP3tfdHR5
cGUgPSBGTE9BVDt9CQ0KCXwJKERpZ2l0KSsgKExvbmdTdWZmaXggfCBVbnNpZ25lZFN1ZmZpeCk/
IHtfdHR5cGUgPSBERUNJTlQ7fQ0KCXwJDQoJCSgiLi4uIik9PiAiLi4uIiAgICAgICAgICAgIHtf
dHR5cGUgPSBFTExJUFNJUzt9CS8vyqHC1LrFDQoJfAkNCgkJJy4nICAgICAgICAgICAgICAgICAg
ICAgICB7X3R0eXBlID0gRE9UO30JCS8vteO78tXfuKG14w0KCQkoCShEaWdpdCkrIChFeHBvbmVu
dCk/IChGbG9hdFN1ZmZpeCB8TG9uZ1N1ZmZpeCApPyB7X3R0eXBlID0gRkxPQVQ7fQ0KCQkpPw0K
CXwJDQoJOw0KSUQJLy+x6sq+t/ujrNXiwO/Du9PQttS52Lz819a9+NDQtKbA7Q0KCToJDQoJCSgn
YScuLid6J3wnQScuLidaJ3wnXycpICgnYScuLid6J3wnQScuLidaJ3wnXyd8JzAnLi4nOScpKg0K
CTsNCg0KZ2VuZXJhdGUgYW4gaW5jb3JyZWN0IE1DUFBMZXhlci5jcHAsIGhlcmUgaXMgdGhlIG5l
eHRUb2tlbigpIChmdW5jdGlvbiksIHlvdSBjYW4gc2VlIGNsZWFybHkgdGhhdCB0aGlzIGZ1bmN0
aW9uIGRvZXMgbm90IGRlYWwgd2l0aCBFT0YsIHNvIGl0IGNhbiBuZXZlciBzdG9wLg0KDQpBTlRM
Ul9VU0VfTkFNRVNQQUNFKGFudGxyKVJlZlRva2VuIE1DUFBMZXhlcjo6bmV4dFRva2VuKCkNCnsN
CglBTlRMUl9VU0VfTkFNRVNQQUNFKGFudGxyKVJlZlRva2VuIHRoZVJldFRva2VuOw0KCWZvciAo
OzspIHsNCgkJQU5UTFJfVVNFX05BTUVTUEFDRShhbnRscilSZWZUb2tlbiB0aGVSZXRUb2tlbjsN
CgkJaW50IF90dHlwZSA9IEFOVExSX1VTRV9OQU1FU1BBQ0UoYW50bHIpVG9rZW46OklOVkFMSURf
VFlQRTsNCgkJcmVzZXRUZXh0KCk7DQoJCXRyeSB7ICAgLy8gZm9yIGxleGljYWwgYW5kIGNoYXIg
c3RyZWFtIGVycm9yIGhhbmRsaW5nDQoJCQlzd2l0Y2ggKCBMQSgxKSkgew0KCQkJY2FzZSAweDJj
IC8qICcsJyAqLyA6DQoJCQl7DQoJCQkJbUNPTU1BKHRydWUpOw0KCQkJCXRoZVJldFRva2VuPV9y
ZXR1cm5Ub2tlbjsNCgkJCQlicmVhazsNCgkJCX0NCgkJCWNhc2UgMHgzZiAvKiAnPycgKi8gOg0K
CQkJew0KCQkJCW1RVUVTVElPTk1BUksodHJ1ZSk7DQoJCQkJdGhlUmV0VG9rZW49X3JldHVyblRv
a2VuOw0KCQkJCWJyZWFrOw0KCQkJfQ0KCQkJY2FzZSAweDNiIC8qICc7JyAqLyA6DQoJCQl7DQoJ
CQkJbVNFTUlDT0xPTih0cnVlKTsNCgkJCQl0aGVSZXRUb2tlbj1fcmV0dXJuVG9rZW47DQoJCQkJ
YnJlYWs7DQoJCQl9DQoJCQljYXNlIDB4MjggLyogJygnICovIDoNCgkJCXsNCgkJCQltTFBBUkVO
KHRydWUpOw0KCQkJCXRoZVJldFRva2VuPV9yZXR1cm5Ub2tlbjsNCgkJCQlicmVhazsNCgkJCX0N
CgkJCWNhc2UgMHgyOSAvKiAnKScgKi8gOg0KCQkJew0KCQkJCW1SUEFSRU4odHJ1ZSk7DQoJCQkJ
dGhlUmV0VG9rZW49X3JldHVyblRva2VuOw0KCQkJCWJyZWFrOw0KCQkJfQ0KCQkJY2FzZSAweDVi
IC8qICdbJyAqLyA6DQoJCQl7DQoJCQkJbUxTUVVBUkUodHJ1ZSk7DQoJCQkJdGhlUmV0VG9rZW49
X3JldHVyblRva2VuOw0KCQkJCWJyZWFrOw0KCQkJfQ0KCQkJY2FzZSAweDVkIC8qICddJyAqLyA6
DQoJCQl7DQoJCQkJbVJTUVVBUkUodHJ1ZSk7DQoJCQkJdGhlUmV0VG9rZW49X3JldHVyblRva2Vu
Ow0KCQkJCWJyZWFrOw0KCQkJfQ0KCQkJY2FzZSAweDdiIC8qICd7JyAqLyA6DQoJCQl7DQoJCQkJ
bUxDVVJMWSh0cnVlKTsNCgkJCQl0aGVSZXRUb2tlbj1fcmV0dXJuVG9rZW47DQoJCQkJYnJlYWs7
DQoJCQl9DQoJCQljYXNlIDB4N2QgLyogJ30nICovIDoNCgkJCXsNCgkJCQltUkNVUkxZKHRydWUp
Ow0KCQkJCXRoZVJldFRva2VuPV9yZXR1cm5Ub2tlbjsNCgkJCQlicmVhazsNCgkJCX0NCgkJCWNh
c2UgMHg3ZSAvKiAnficgKi8gOg0KCQkJew0KCQkJCW1USUxERSh0cnVlKTsNCgkJCQl0aGVSZXRU
b2tlbj1fcmV0dXJuVG9rZW47DQoJCQkJYnJlYWs7DQoJCQl9DQoJCQljYXNlIDB4OSAvKiAnXHQn
ICovIDoNCgkJCWNhc2UgMHhhIC8qICdcbicgKi8gOg0KCQkJY2FzZSAweGMgLyogJ1wxNCcgKi8g
Og0KCQkJY2FzZSAweGQgLyogJ1xyJyAqLyA6DQoJCQljYXNlIDB4MjAgLyogJyAnICovIDoNCgkJ
CWNhc2UgMHg1YyAvKiAnXFwnICovIDoNCgkJCXsNCgkJCQltV2hpdGVzcGFjZSh0cnVlKTsNCgkJ
CQl0aGVSZXRUb2tlbj1fcmV0dXJuVG9rZW47DQoJCQkJYnJlYWs7DQoJCQl9DQoJCQljYXNlIDB4
MjcgLyogJ1wnJyAqLyA6DQoJCQl7DQoJCQkJbUNoYXJMaXRlcmFsKHRydWUpOw0KCQkJCXRoZVJl
dFRva2VuPV9yZXR1cm5Ub2tlbjsNCgkJCQlicmVhazsNCgkJCX0NCgkJCWNhc2UgMHgyMiAvKiAn
XCInICovIDoNCgkJCXsNCgkJCQltU3RyaW5nTGl0ZXJhbCh0cnVlKTsNCgkJCQl0aGVSZXRUb2tl
bj1fcmV0dXJuVG9rZW47DQoJCQkJYnJlYWs7DQoJCQl9DQoJCQljYXNlIDB4NDEgLyogJ0EnICov
IDoNCgkJCWNhc2UgMHg0MiAvKiAnQicgKi8gOg0KCQkJY2FzZSAweDQzIC8qICdDJyAqLyA6DQoJ
CQljYXNlIDB4NDQgLyogJ0QnICovIDoNCgkJCWNhc2UgMHg0NSAvKiAnRScgKi8gOg0KCQkJY2Fz
ZSAweDQ2IC8qICdGJyAqLyA6DQoJCQljYXNlIDB4NDcgLyogJ0cnICovIDoNCgkJCWNhc2UgMHg0
OCAvKiAnSCcgKi8gOg0KCQkJY2FzZSAweDQ5IC8qICdJJyAqLyA6DQoJCQljYXNlIDB4NGEgLyog
J0onICovIDoNCgkJCWNhc2UgMHg0YiAvKiAnSycgKi8gOg0KCQkJY2FzZSAweDRjIC8qICdMJyAq
LyA6DQoJCQljYXNlIDB4NGQgLyogJ00nICovIDoNCgkJCWNhc2UgMHg0ZSAvKiAnTicgKi8gOg0K
CQkJY2FzZSAweDRmIC8qICdPJyAqLyA6DQoJCQljYXNlIDB4NTAgLyogJ1AnICovIDoNCgkJCWNh
c2UgMHg1MSAvKiAnUScgKi8gOg0KCQkJY2FzZSAweDUyIC8qICdSJyAqLyA6DQoJCQljYXNlIDB4
NTMgLyogJ1MnICovIDoNCgkJCWNhc2UgMHg1NCAvKiAnVCcgKi8gOg0KCQkJY2FzZSAweDU1IC8q
ICdVJyAqLyA6DQoJCQljYXNlIDB4NTYgLyogJ1YnICovIDoNCgkJCWNhc2UgMHg1NyAvKiAnVycg
Ki8gOg0KCQkJY2FzZSAweDU4IC8qICdYJyAqLyA6DQoJCQljYXNlIDB4NTkgLyogJ1knICovIDoN
CgkJCWNhc2UgMHg1YSAvKiAnWicgKi8gOg0KCQkJY2FzZSAweDVmIC8qICdfJyAqLyA6DQoJCQlj
YXNlIDB4NjEgLyogJ2EnICovIDoNCgkJCWNhc2UgMHg2MiAvKiAnYicgKi8gOg0KCQkJY2FzZSAw
eDYzIC8qICdjJyAqLyA6DQoJCQljYXNlIDB4NjQgLyogJ2QnICovIDoNCgkJCWNhc2UgMHg2NSAv
KiAnZScgKi8gOg0KCQkJY2FzZSAweDY2IC8qICdmJyAqLyA6DQoJCQljYXNlIDB4NjcgLyogJ2cn
ICovIDoNCgkJCWNhc2UgMHg2OCAvKiAnaCcgKi8gOg0KCQkJY2FzZSAweDY5IC8qICdpJyAqLyA6
DQoJCQljYXNlIDB4NmEgLyogJ2onICovIDoNCgkJCWNhc2UgMHg2YiAvKiAnaycgKi8gOg0KCQkJ
Y2FzZSAweDZjIC8qICdsJyAqLyA6DQoJCQljYXNlIDB4NmQgLyogJ20nICovIDoNCgkJCWNhc2Ug
MHg2ZSAvKiAnbicgKi8gOg0KCQkJY2FzZSAweDZmIC8qICdvJyAqLyA6DQoJCQljYXNlIDB4NzAg
LyogJ3AnICovIDoNCgkJCWNhc2UgMHg3MSAvKiAncScgKi8gOg0KCQkJY2FzZSAweDcyIC8qICdy
JyAqLyA6DQoJCQljYXNlIDB4NzMgLyogJ3MnICovIDoNCgkJCWNhc2UgMHg3NCAvKiAndCcgKi8g
Og0KCQkJY2FzZSAweDc1IC8qICd1JyAqLyA6DQoJCQljYXNlIDB4NzYgLyogJ3YnICovIDoNCgkJ
CWNhc2UgMHg3NyAvKiAndycgKi8gOg0KCQkJY2FzZSAweDc4IC8qICd4JyAqLyA6DQoJCQljYXNl
IDB4NzkgLyogJ3knICovIDoNCgkJCWNhc2UgMHg3YSAvKiAneicgKi8gOg0KCQkJew0KCQkJCW1J
RCh0cnVlKTsNCgkJCQl0aGVSZXRUb2tlbj1fcmV0dXJuVG9rZW47DQoJCQkJYnJlYWs7DQoJCQl9
DQoJCQlkZWZhdWx0Og0KCQkJCWlmICgoTEEoMSkgPT0gMHgzZSAvKiAnPicgKi8gKSAmJiAoTEEo
MikgPT0gMHgzZSAvKiAnPicgKi8gKSAmJiAoTEEoMykgPT0gMHgzZCAvKiAnPScgKi8gKSkgew0K
CQkJCQltU0hJRlRSSUdIVEVRVUFMKHRydWUpOw0KCQkJCQl0aGVSZXRUb2tlbj1fcmV0dXJuVG9r
ZW47DQoJCQkJfQ0KCQkJCWVsc2UgaWYgKChMQSgxKSA9PSAweDNjIC8qICc8JyAqLyApICYmIChM
QSgyKSA9PSAweDNjIC8qICc8JyAqLyApICYmIChMQSgzKSA9PSAweDNkIC8qICc9JyAqLyApKSB7
DQoJCQkJCW1TSElGVExFRlRFUVVBTCh0cnVlKTsNCgkJCQkJdGhlUmV0VG9rZW49X3JldHVyblRv
a2VuOw0KCQkJCX0NCgkJCQllbHNlIGlmICgoTEEoMSkgPT0gMHgyZCAvKiAnLScgKi8gKSAmJiAo
TEEoMikgPT0gMHgzZSAvKiAnPicgKi8gKSAmJiAoTEEoMykgPT0gMHgyYSAvKiAnKicgKi8gKSkg
ew0KCQkJCQltUE9JTlRFUlRPTUJSKHRydWUpOw0KCQkJCQl0aGVSZXRUb2tlbj1fcmV0dXJuVG9r
ZW47DQoJCQkJfQ0KCQkJCWVsc2UgaWYgKChMQSgxKSA9PSAweDJkIC8qICctJyAqLyApICYmIChM
QSgyKSA9PSAweDNlIC8qICc+JyAqLyApICYmICh0cnVlKSkgew0KCQkJCQltUE9JTlRFUlRPKHRy
dWUpOw0KCQkJCQl0aGVSZXRUb2tlbj1fcmV0dXJuVG9rZW47DQoJCQkJfQ0KCQkJCWVsc2UgaWYg
KChMQSgxKSA9PSAweDNkIC8qICc9JyAqLyApICYmIChMQSgyKSA9PSAweDNkIC8qICc9JyAqLyAp
KSB7DQoJCQkJCW1FUVVBTCh0cnVlKTsNCgkJCQkJdGhlUmV0VG9rZW49X3JldHVyblRva2VuOw0K
CQkJCX0NCgkJCQllbHNlIGlmICgoTEEoMSkgPT0gMHgyMSAvKiAnIScgKi8gKSAmJiAoTEEoMikg
PT0gMHgzZCAvKiAnPScgKi8gKSkgew0KCQkJCQltTk9URVFVQUwodHJ1ZSk7DQoJCQkJCXRoZVJl
dFRva2VuPV9yZXR1cm5Ub2tlbjsNCgkJCQl9DQoJCQkJZWxzZSBpZiAoKExBKDEpID09IDB4M2Mg
LyogJzwnICovICkgJiYgKExBKDIpID09IDB4M2QgLyogJz0nICovICkpIHsNCgkJCQkJbUxFU1NU
SEFOT1JFUVVBTFRPKHRydWUpOw0KCQkJCQl0aGVSZXRUb2tlbj1fcmV0dXJuVG9rZW47DQoJCQkJ
fQ0KCQkJCWVsc2UgaWYgKChMQSgxKSA9PSAweDNlIC8qICc+JyAqLyApICYmIChMQSgyKSA9PSAw
eDNkIC8qICc9JyAqLyApKSB7DQoJCQkJCW1HUkVBVEVSVEhBTk9SRVFVQUxUTyh0cnVlKTsNCgkJ
CQkJdGhlUmV0VG9rZW49X3JldHVyblRva2VuOw0KCQkJCX0NCgkJCQllbHNlIGlmICgoTEEoMSkg
PT0gMHgyZiAvKiAnLycgKi8gKSAmJiAoTEEoMikgPT0gMHgzZCAvKiAnPScgKi8gKSkgew0KCQkJ
CQltRElWSURFRVFVQUwodHJ1ZSk7DQoJCQkJCXRoZVJldFRva2VuPV9yZXR1cm5Ub2tlbjsNCgkJ
CQl9DQoJCQkJZWxzZSBpZiAoKExBKDEpID09IDB4MmIgLyogJysnICovICkgJiYgKExBKDIpID09
IDB4M2QgLyogJz0nICovICkpIHsNCgkJCQkJbVBMVVNFUVVBTCh0cnVlKTsNCgkJCQkJdGhlUmV0
VG9rZW49X3JldHVyblRva2VuOw0KCQkJCX0NCgkJCQllbHNlIGlmICgoTEEoMSkgPT0gMHgyYiAv
KiAnKycgKi8gKSAmJiAoTEEoMikgPT0gMHgyYiAvKiAnKycgKi8gKSkgew0KCQkJCQltUExVU1BM
VVModHJ1ZSk7DQoJCQkJCXRoZVJldFRva2VuPV9yZXR1cm5Ub2tlbjsNCgkJCQl9DQoJCQkJZWxz
ZSBpZiAoKExBKDEpID09IDB4MmQgLyogJy0nICovICkgJiYgKExBKDIpID09IDB4M2QgLyogJz0n
ICovICkpIHsNCgkJCQkJbU1JTlVTRVFVQUwodHJ1ZSk7DQoJCQkJCXRoZVJldFRva2VuPV9yZXR1
cm5Ub2tlbjsNCgkJCQl9DQoJCQkJZWxzZSBpZiAoKExBKDEpID09IDB4MmQgLyogJy0nICovICkg
JiYgKExBKDIpID09IDB4MmQgLyogJy0nICovICkpIHsNCgkJCQkJbU1JTlVTTUlOVVModHJ1ZSk7
DQoJCQkJCXRoZVJldFRva2VuPV9yZXR1cm5Ub2tlbjsNCgkJCQl9DQoJCQkJZWxzZSBpZiAoKExB
KDEpID09IDB4MmEgLyogJyonICovICkgJiYgKExBKDIpID09IDB4M2QgLyogJz0nICovICkpIHsN
CgkJCQkJbVRJTUVTRVFVQUwodHJ1ZSk7DQoJCQkJCXRoZVJldFRva2VuPV9yZXR1cm5Ub2tlbjsN
CgkJCQl9DQoJCQkJZWxzZSBpZiAoKExBKDEpID09IDB4MjUgLyogJyUnICovICkgJiYgKExBKDIp
ID09IDB4M2QgLyogJz0nICovICkpIHsNCgkJCQkJbU1PREVRVUFMKHRydWUpOw0KCQkJCQl0aGVS
ZXRUb2tlbj1fcmV0dXJuVG9rZW47DQoJCQkJfQ0KCQkJCWVsc2UgaWYgKChMQSgxKSA9PSAweDNl
IC8qICc+JyAqLyApICYmIChMQSgyKSA9PSAweDNlIC8qICc+JyAqLyApICYmICh0cnVlKSkgew0K
CQkJCQltU0hJRlRSSUdIVCh0cnVlKTsNCgkJCQkJdGhlUmV0VG9rZW49X3JldHVyblRva2VuOw0K
CQkJCX0NCgkJCQllbHNlIGlmICgoTEEoMSkgPT0gMHgzYyAvKiAnPCcgKi8gKSAmJiAoTEEoMikg
PT0gMHgzYyAvKiAnPCcgKi8gKSAmJiAodHJ1ZSkpIHsNCgkJCQkJbVNISUZUTEVGVCh0cnVlKTsN
CgkJCQkJdGhlUmV0VG9rZW49X3JldHVyblRva2VuOw0KCQkJCX0NCgkJCQllbHNlIGlmICgoTEEo
MSkgPT0gMHgyNiAvKiAnJicgKi8gKSAmJiAoTEEoMikgPT0gMHgyNiAvKiAnJicgKi8gKSkgew0K
CQkJCQltQU5EKHRydWUpOw0KCQkJCQl0aGVSZXRUb2tlbj1fcmV0dXJuVG9rZW47DQoJCQkJfQ0K
CQkJCWVsc2UgaWYgKChMQSgxKSA9PSAweDdjIC8qICd8JyAqLyApICYmIChMQSgyKSA9PSAweDdj
IC8qICd8JyAqLyApKSB7DQoJCQkJCW1PUih0cnVlKTsNCgkJCQkJdGhlUmV0VG9rZW49X3JldHVy
blRva2VuOw0KCQkJCX0NCgkJCQllbHNlIGlmICgoTEEoMSkgPT0gMHgyNiAvKiAnJicgKi8gKSAm
JiAoTEEoMikgPT0gMHgzZCAvKiAnPScgKi8gKSkgew0KCQkJCQltQklUV0lTRUFOREVRVUFMKHRy
dWUpOw0KCQkJCQl0aGVSZXRUb2tlbj1fcmV0dXJuVG9rZW47DQoJCQkJfQ0KCQkJCWVsc2UgaWYg
KChMQSgxKSA9PSAweDdjIC8qICd8JyAqLyApICYmIChMQSgyKSA9PSAweDNkIC8qICc9JyAqLyAp
KSB7DQoJCQkJCW1CSVRXSVNFT1JFUVVBTCh0cnVlKTsNCgkJCQkJdGhlUmV0VG9rZW49X3JldHVy
blRva2VuOw0KCQkJCX0NCgkJCQllbHNlIGlmICgoTEEoMSkgPT0gMHg1ZSAvKiAnXicgKi8gKSAm
JiAoTEEoMikgPT0gMHgzZCAvKiAnPScgKi8gKSkgew0KCQkJCQltQklUV0lTRVhPUkVRVUFMKHRy
dWUpOw0KCQkJCQl0aGVSZXRUb2tlbj1fcmV0dXJuVG9rZW47DQoJCQkJfQ0KCQkJCWVsc2UgaWYg
KChMQSgxKSA9PSAweDJlIC8qICcuJyAqLyApICYmIChMQSgyKSA9PSAweDJhIC8qICcqJyAqLyAp
KSB7DQoJCQkJCW1ET1RNQlIodHJ1ZSk7DQoJCQkJCXRoZVJldFRva2VuPV9yZXR1cm5Ub2tlbjsN
CgkJCQl9DQoJCQkJZWxzZSBpZiAoKExBKDEpID09IDB4M2EgLyogJzonICovICkgJiYgKExBKDIp
ID09IDB4M2EgLyogJzonICovICkpIHsNCgkJCQkJbVNDT1BFKHRydWUpOw0KCQkJCQl0aGVSZXRU
b2tlbj1fcmV0dXJuVG9rZW47DQoJCQkJfQ0KCQkJCWVsc2UgaWYgKChMQSgxKSA9PSAweDJmIC8q
ICcvJyAqLyApICYmIChMQSgyKSA9PSAweDJhIC8qICcqJyAqLyApKSB7DQoJCQkJCW1Db21tZW50
KHRydWUpOw0KCQkJCQl0aGVSZXRUb2tlbj1fcmV0dXJuVG9rZW47DQoJCQkJfQ0KCQkJCWVsc2Ug
aWYgKChMQSgxKSA9PSAweDJmIC8qICcvJyAqLyApICYmIChMQSgyKSA9PSAweDJmIC8qICcvJyAq
LyApKSB7DQoJCQkJCW1DUFBDb21tZW50KHRydWUpOw0KCQkJCQl0aGVSZXRUb2tlbj1fcmV0dXJu
VG9rZW47DQoJCQkJfQ0KCQkJCWVsc2UgaWYgKChMQSgxKSA9PSAweDNkIC8qICc9JyAqLyApICYm
ICh0cnVlKSkgew0KCQkJCQltQVNTSUdORVFVQUwodHJ1ZSk7DQoJCQkJCXRoZVJldFRva2VuPV9y
ZXR1cm5Ub2tlbjsNCgkJCQl9DQoJCQkJZWxzZSBpZiAoKExBKDEpID09IDB4M2EgLyogJzonICov
ICkgJiYgKHRydWUpKSB7DQoJCQkJCW1DT0xPTih0cnVlKTsNCgkJCQkJdGhlUmV0VG9rZW49X3Jl
dHVyblRva2VuOw0KCQkJCX0NCgkJCQllbHNlIGlmICgoTEEoMSkgPT0gMHgzYyAvKiAnPCcgKi8g
KSAmJiAodHJ1ZSkpIHsNCgkJCQkJbUxFU1NUSEFOKHRydWUpOw0KCQkJCQl0aGVSZXRUb2tlbj1f
cmV0dXJuVG9rZW47DQoJCQkJfQ0KCQkJCWVsc2UgaWYgKChMQSgxKSA9PSAweDNlIC8qICc+JyAq
LyApICYmICh0cnVlKSkgew0KCQkJCQltR1JFQVRFUlRIQU4odHJ1ZSk7DQoJCQkJCXRoZVJldFRv
a2VuPV9yZXR1cm5Ub2tlbjsNCgkJCQl9DQoJCQkJZWxzZSBpZiAoKExBKDEpID09IDB4MmYgLyog
Jy8nICovICkgJiYgKHRydWUpKSB7DQoJCQkJCW1ESVZJREUodHJ1ZSk7DQoJCQkJCXRoZVJldFRv
a2VuPV9yZXR1cm5Ub2tlbjsNCgkJCQl9DQoJCQkJZWxzZSBpZiAoKExBKDEpID09IDB4MmIgLyog
JysnICovICkgJiYgKHRydWUpKSB7DQoJCQkJCW1QTFVTKHRydWUpOw0KCQkJCQl0aGVSZXRUb2tl
bj1fcmV0dXJuVG9rZW47DQoJCQkJfQ0KCQkJCWVsc2UgaWYgKChMQSgxKSA9PSAweDJkIC8qICct
JyAqLyApICYmICh0cnVlKSkgew0KCQkJCQltTUlOVVModHJ1ZSk7DQoJCQkJCXRoZVJldFRva2Vu
PV9yZXR1cm5Ub2tlbjsNCgkJCQl9DQoJCQkJZWxzZSBpZiAoKExBKDEpID09IDB4MmEgLyogJyon
ICovICkgJiYgKHRydWUpKSB7DQoJCQkJCW1TVEFSKHRydWUpOw0KCQkJCQl0aGVSZXRUb2tlbj1f
cmV0dXJuVG9rZW47DQoJCQkJfQ0KCQkJCWVsc2UgaWYgKChMQSgxKSA9PSAweDI1IC8qICclJyAq
LyApICYmICh0cnVlKSkgew0KCQkJCQltTU9EKHRydWUpOw0KCQkJCQl0aGVSZXRUb2tlbj1fcmV0
dXJuVG9rZW47DQoJCQkJfQ0KCQkJCWVsc2UgaWYgKChMQSgxKSA9PSAweDIxIC8qICchJyAqLyAp
ICYmICh0cnVlKSkgew0KCQkJCQltTk9UKHRydWUpOw0KCQkJCQl0aGVSZXRUb2tlbj1fcmV0dXJu
VG9rZW47DQoJCQkJfQ0KCQkJCWVsc2UgaWYgKChMQSgxKSA9PSAweDI2IC8qICcmJyAqLyApICYm
ICh0cnVlKSkgew0KCQkJCQltQU1QRVJTQU5EKHRydWUpOw0KCQkJCQl0aGVSZXRUb2tlbj1fcmV0
dXJuVG9rZW47DQoJCQkJfQ0KCQkJCWVsc2UgaWYgKChMQSgxKSA9PSAweDdjIC8qICd8JyAqLyAp
ICYmICh0cnVlKSkgew0KCQkJCQltQklUV0lTRU9SKHRydWUpOw0KCQkJCQl0aGVSZXRUb2tlbj1f
cmV0dXJuVG9rZW47DQoJCQkJfQ0KCQkJCWVsc2UgaWYgKChMQSgxKSA9PSAweDVlIC8qICdeJyAq
LyApICYmICh0cnVlKSkgew0KCQkJCQltQklUV0lTRVhPUih0cnVlKTsNCgkJCQkJdGhlUmV0VG9r
ZW49X3JldHVyblRva2VuOw0KCQkJCX0NCgkJCQllbHNlew0KCQkJCQltTnVtYmVyKHRydWUpOw0K
CQkJCQl0aGVSZXRUb2tlbj1fcmV0dXJuVG9rZW47DQoJCQkJfQ0KCQkJfQ0KCQkJaWYgKCAhX3Jl
dHVyblRva2VuICkNCgkJCQlnb3RvIHRyeUFnYWluOyAvLyBmb3VuZCBTS0lQIHRva2VuDQoNCgkJ
CV90dHlwZSA9IF9yZXR1cm5Ub2tlbi0+Z2V0VHlwZSgpOw0KCQkJX3R0eXBlID0gdGVzdExpdGVy
YWxzVGFibGUoX3R0eXBlKTsNCgkJCV9yZXR1cm5Ub2tlbi0+c2V0VHlwZShfdHR5cGUpOw0KCQkJ
cmV0dXJuIF9yZXR1cm5Ub2tlbjsNCgkJfQ0KCQljYXRjaCAoQU5UTFJfVVNFX05BTUVTUEFDRShh
bnRscilSZWNvZ25pdGlvbkV4Y2VwdGlvbiYgZSkgew0KCQkJCXRocm93IEFOVExSX1VTRV9OQU1F
U1BBQ0UoYW50bHIpVG9rZW5TdHJlYW1SZWNvZ25pdGlvbkV4Y2VwdGlvbihlKTsNCgkJfQ0KCQlj
YXRjaCAoQU5UTFJfVVNFX05BTUVTUEFDRShhbnRscilDaGFyU3RyZWFtSU9FeGNlcHRpb24mIGNz
aWUpIHsNCgkJCXRocm93IEFOVExSX1VTRV9OQU1FU1BBQ0UoYW50bHIpVG9rZW5TdHJlYW1JT0V4
Y2VwdGlvbihjc2llLmlvKTsNCgkJfQ0KCQljYXRjaCAoQU5UTFJfVVNFX05BTUVTUEFDRShhbnRs
cilDaGFyU3RyZWFtRXhjZXB0aW9uJiBjc2UpIHsNCgkJCXRocm93IEFOVExSX1VTRV9OQU1FU1BB
Q0UoYW50bHIpVG9rZW5TdHJlYW1FeGNlcHRpb24oY3NlLmdldE1lc3NhZ2UoKSk7DQoJCX0NCnRy
eUFnYWluOjsNCgl9DQp9DQoNCkkgZG9uJ3Qga25vdyB3aGV0aGVyIHRoZSBncmFtbWVyIGlzIHdy
b25nIG9yIGl0IGlzIGEgYnVnLg0KDQo=


