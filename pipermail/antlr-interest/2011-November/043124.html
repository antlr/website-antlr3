<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Ambiguity between floating point literal and method call
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Ambiguity%20between%20floating%20point%20literal%20and%0A%20method%20call&In-Reply-To=%3Cd23a7c1eba8198bf0bef950838dbab40%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="043123.html">
   <LINK REL="Next"  HREF="043135.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Ambiguity between floating point literal and method call</H1>
    <B>Jim Idle</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Ambiguity%20between%20floating%20point%20literal%20and%0A%20method%20call&In-Reply-To=%3Cd23a7c1eba8198bf0bef950838dbab40%40mail.gmail.com%3E"
       TITLE="[antlr-interest] Ambiguity between floating point literal and method call">jimi at temporal-wave.com
       </A><BR>
    <I>Wed Nov  2 09:48:57 PDT 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="043123.html">[antlr-interest] Ambiguity between floating point literal and method call
</A></li>
        <LI>Next message: <A HREF="043135.html">[antlr-interest] Ambiguity between floating point literal and method call
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#43124">[ date ]</a>
              <a href="thread.html#43124">[ thread ]</a>
              <a href="subject.html#43124">[ subject ]</a>
              <a href="author.html#43124">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>You can browse it here. Try not to depart from the lexer until you have
this working.



<A HREF="http://kenai.com/projects/openjfx-compiler/sources/jfx-debug/show/src/share/classes/com/sun/tools/javafx/antlr?rev=6727">http://kenai.com/projects/openjfx-compiler/sources/jfx-debug/show/src/share/classes/com/sun/tools/javafx/antlr?rev=6727</A>



Jim



*From:* Ross Bamford [mailto:<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">roscoml at gmail.com</A>]
*Sent:* Wednesday, November 02, 2011 5:18 AM
*To:* Jim Idle
*Cc:* <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>
*Subject:* Re: [antlr-interest] Ambiguity between floating point literal
and method call



Thanks, Jim. I'd seen that FAQ page before, and had played with integrating
that approach into my grammar, however I still don't seem to be able to get
it to work - parsing input such as: &quot;1.foo()&quot; results in the 1 and it's
period being matched together (outputting '1.'), meaning that my parser
never sees the INTEGER DOT ID production, and I get NoViableAlt exceptions.
Interestingly, after integrating the changes you suggested hex literal
method calls also no longer work, which they do with my &quot;normal&quot; literal
lexing.



I would very much like to look at the JavaFX source and see how it's done
over there. Unfortunately though I have very limited Internet service here
(I live in a very rural area) and I wonder if you know if it's browseable
online rather than having to download the source tree?



Thanks again,

Ross

On Thu, Oct 27, 2011 at 12:02 AM, Jim Idle &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">jimi at temporal-wave.com</A>&gt; wrote:

Please see the FAQ:

<A HREF="http://www.antlr.org/wiki/display/ANTLR3/Lexer+grammar+for+floating+point%">http://www.antlr.org/wiki/display/ANTLR3/Lexer+grammar+for+floating+point%</A>
2C+dot%2C+range%2C+time+specs&lt;<A HREF="http://www.antlr.org/wiki/display/ANTLR3/Lexer+grammar+for+floating+point%25%0d%0a2C+dot%2C+range%2C+time+specs">http://www.antlr.org/wiki/display/ANTLR3/Lexer+grammar+for+floating+point%25%0d%0a2C+dot%2C+range%2C+time+specs</A>&gt;

Which you can modify for your purpose, then you can add INTEGER DOT ID in
your parser. If you were to download the source code for the JavaFX
compiler, you will see that it supports that exact syntax.


Jim

&gt;<i> -----Original Message-----
</I>&gt;<i> From: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-bounces at antlr.org</A> [mailto:antlr-interest-
</I>&gt;<i> <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">bounces at antlr.org</A>] On Behalf Of Ross Bamford
</I>&gt;<i> Sent: Wednesday, October 26, 2011 3:37 PM
</I>&gt;<i> To: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>
</I>&gt;<i> Subject: [antlr-interest] Ambiguity between floating point literal and
</I>&gt;<i> method call
</I>
&gt;<i>
</I>&gt;<i> Hi all,
</I>&gt;<i>
</I>&gt;<i> Have posted here recently, and thanks again for all your help in
</I>&gt;<i> getting my various problems fixed. I'm implementing a basic scripting
</I>&gt;<i> language for use in embedded systems, and I've come across another
</I>&gt;<i> problem that, after much googling and tinkering I still can seem to
</I>&gt;<i> fix. In this language, numbers are first-class objects, and I need to
</I>&gt;<i> be able to call methods on them, in the standard way, e.g. 1.foo() .
</I>&gt;<i> However, I'm coming up against a problem whereby the parser can't
</I>&gt;<i> distinguish between this and floating point literals. I've tried
</I>&gt;<i> various combinations of predicates and the like, but just don't seem to
</I>&gt;<i> be able to get it working. Any help would be much appreciated!
</I>&gt;<i>
</I>&gt;<i> Thanks in advance,
</I>&gt;<i> Ross Bamford
</I>&gt;<i>
</I>&gt;<i> /* ** GRAMMAR FOLLOWS ** */
</I>&gt;<i> grammar BasicLang;
</I>&gt;<i>
</I>&gt;<i> options {
</I>&gt;<i>     output=AST;
</I>&gt;<i>     ASTLabelType=CommonTree;
</I>&gt;<i>     backtrack=true;
</I>&gt;<i>     memoize=true;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> tokens {
</I>&gt;<i>   ASSIGN;
</I>&gt;<i>   METHOD_CALL;
</I>&gt;<i>   ARGS;
</I>&gt;<i>   BLOCK;
</I>&gt;<i>   ORBLOCK;
</I>&gt;<i>   SELF;
</I>&gt;<i>   ASSIGN_RECEIVER;
</I>&gt;<i>   ASSIGN_LOCAL;
</I>&gt;<i>   FIELD_ACCESS;
</I>&gt;<i>   LVALUE;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> start_rule
</I>&gt;<i>   :   script
</I>&gt;<i>   ;
</I>&gt;<i>
</I>&gt;<i> script
</I>&gt;<i>   :   statement+
</I>&gt;<i>   |   EOF!
</I>&gt;<i>   ;
</I>&gt;<i>
</I>&gt;<i> statement
</I>&gt;<i>   :   expr terminator!
</I>&gt;<i>   ;
</I>&gt;<i>
</I>&gt;<i> expr
</I>&gt;<i>   :   assign_expr
</I>&gt;<i>   |   math_expr
</I>&gt;<i>   ;
</I>&gt;<i>
</I>&gt;<i> assign_expr
</I>&gt;<i> @init {boolean explicitReceiver=false;}
</I>&gt;<i>   :   (rec=IDENTIFIER DOT {explicitReceiver=true;})? id=IDENTIFIER
</I>&gt;<i> ASSIGN
</I>&gt;<i> expr -&gt; {explicitReceiver}? ^(ASSIGN ASSIGN_RECEIVER[$rec.getText()]
</I>&gt;<i> LVALUE[$id.getText()] expr) -&gt; ^(ASSIGN ASSIGN_LOCAL
</I>&gt;<i> LVALUE[$id.getText()]
</I>&gt;<i> expr)
</I>&gt;<i>   ;
</I>&gt;<i>
</I>&gt;<i> math_expr
</I>&gt;<i>   :   mult_expr ((ADD^|SUB^) mult_expr)*
</I>&gt;<i>   ;
</I>&gt;<i>
</I>&gt;<i> mult_expr
</I>&gt;<i>   :   pow_expr ((MUL^|DIV^|MOD^) pow_expr)*
</I>&gt;<i>   ;
</I>&gt;<i>
</I>&gt;<i> pow_expr
</I>&gt;<i>   :   unary_expr ((POW^) unary_expr)*
</I>&gt;<i>   ;
</I>&gt;<i>
</I>&gt;<i> unary_expr
</I>&gt;<i>   :   NOT? atom
</I>&gt;<i>   ;
</I>&gt;<i>
</I>&gt;<i> meth_call
</I>&gt;<i> @init {boolean explicitReceiver=false;}
</I>&gt;<i>   :   (IDENTIFIER DOT {explicitReceiver=true;})? func_call_expr -&gt;
</I>&gt;<i> {explicitReceiver}? ^(METHOD_CALL IDENTIFIER func_call_expr) -&gt;
</I>&gt;<i> ^(METHOD_CALL SELF func_call_expr)
</I>&gt;<i>   |   literal DOT func_call_expr -&gt; ^(METHOD_CALL literal
</I>&gt;<i> func_call_expr)
</I>&gt;<i>   ;
</I>&gt;<i>
</I>&gt;<i> fragment
</I>&gt;<i> func_call_expr
</I>&gt;<i>   :   IDENTIFIER^ argument_list block? orblock?
</I>&gt;<i>   ;
</I>&gt;<i>
</I>&gt;<i> fragment
</I>&gt;<i> block
</I>&gt;<i>   :   LCURLY TERMINATOR? statement* RCURLY -&gt; ^(BLOCK statement*)
</I>&gt;<i>   ;
</I>&gt;<i>
</I>&gt;<i> fragment
</I>&gt;<i> orblock
</I>&gt;<i>   :   OR LCURLY TERMINATOR? statement* RCURLY -&gt; ^(ORBLOCK statement*)
</I>&gt;<i>   ;
</I>&gt;<i>
</I>&gt;<i> fragment
</I>&gt;<i> argument_list
</I>&gt;<i>   :   LPAREN (expr (COMMA expr)*)? RPAREN -&gt; ^(ARGS expr expr*)?
</I>&gt;<i>   ;
</I>&gt;<i>
</I>&gt;<i> class_identifier
</I>&gt;<i>   :     rec=IDENTIFIER DOT id=IDENTIFIER -&gt; ^(FIELD_ACCESS $rec $id)
</I>&gt;<i>   ;
</I>&gt;<i>
</I>&gt;<i> literal
</I>&gt;<i>   :     DECIMAL_LITERAL
</I>&gt;<i>   |     OCTAL_LITERAL
</I>&gt;<i>   |     HEX_LITERAL
</I>&gt;<i>   |     FLOATING_POINT_LITERAL
</I>&gt;<i>   |     STRING_LITERAL
</I>&gt;<i>   |     CHARACTER_LITERAL
</I>&gt;<i>   ;
</I>&gt;<i>
</I>&gt;<i> atom
</I>&gt;<i>   :     literal
</I>&gt;<i>   |     meth_call
</I>&gt;<i>   |     IDENTIFIER
</I>&gt;<i>   |     class_identifier
</I>&gt;<i>   |     LPAREN! expr RPAREN!
</I>&gt;<i>   ;
</I>&gt;<i>
</I>&gt;<i> terminator
</I>&gt;<i>   :     TERMINATOR
</I>&gt;<i>   |     EOF
</I>&gt;<i>   ;
</I>&gt;<i>
</I>&gt;<i> OR  :   'or';
</I>&gt;<i>
</I>&gt;<i> POW :   '^' ;
</I>&gt;<i> MOD :   '%' ;
</I>&gt;<i> ADD :   '+' ;
</I>&gt;<i> SUB :   '-' ;
</I>&gt;<i> DIV :   '/' ;
</I>&gt;<i> MUL :   '*' ;
</I>&gt;<i> NOT :   '!' ;
</I>&gt;<i>
</I>&gt;<i> ASSIGN
</I>&gt;<i>     :   '='
</I>&gt;<i>     ;
</I>&gt;<i>
</I>&gt;<i> LPAREN
</I>&gt;<i>     :   '('
</I>&gt;<i>     ;
</I>&gt;<i>
</I>&gt;<i> RPAREN
</I>&gt;<i>     :   ')'
</I>&gt;<i>     ;
</I>&gt;<i>
</I>&gt;<i> LCURLY
</I>&gt;<i>     :   '{'
</I>&gt;<i>     ;
</I>&gt;<i>
</I>&gt;<i> RCURLY
</I>&gt;<i>     :   '}'
</I>&gt;<i>     ;
</I>&gt;<i>
</I>&gt;<i> COMMA
</I>&gt;<i>     :   ','
</I>&gt;<i>     ;
</I>&gt;<i>
</I>&gt;<i> DOT :   '.' ;
</I>&gt;<i>
</I>&gt;<i> IDENTIFIER
</I>&gt;<i>   : ID_LETTER (ID_LETTER|'0'..'9')*
</I>&gt;<i>   ;
</I>&gt;<i>
</I>&gt;<i> fragment
</I>&gt;<i> ID_LETTER
</I>&gt;<i>   : '$'
</I>&gt;<i>   | 'A'..'Z'
</I>&gt;<i>   | 'a'..'z'
</I>&gt;<i>   | '_'
</I>&gt;<i>   ;
</I>&gt;<i>
</I>&gt;<i> CHARACTER_LITERAL
</I>&gt;<i>     :   '\'' ( EscapeSequence | ~('\''|'\\') ) '\''
</I>&gt;<i>     ;
</I>&gt;<i>
</I>&gt;<i> STRING_LITERAL
</I>&gt;<i>     :  '&quot;' ( EscapeSequence | ~('\\'|'&quot;') )* '&quot;'
</I>&gt;<i>     ;
</I>&gt;<i>
</I>&gt;<i> HEX_LITERAL : '0' ('x'|'X') HexDigit+ IntegerTypeSuffix? ;
</I>&gt;<i>
</I>&gt;<i> DECIMAL_LITERAL : ('0' | '1'..'9' '0'..'9'*) IntegerTypeSuffix? ;
</I>&gt;<i>
</I>&gt;<i> OCTAL_LITERAL : '0' ('0'..'7')+ IntegerTypeSuffix? ;
</I>&gt;<i>
</I>&gt;<i> fragment
</I>&gt;<i> HexDigit : ('0'..'9'|'a'..'f'|'A'..'F') ;
</I>&gt;<i>
</I>&gt;<i> fragment
</I>&gt;<i> IntegerTypeSuffix
</I>&gt;<i>   : ('l'|'L')
</I>&gt;<i>   | ('u'|'U')  ('l'|'L')?
</I>&gt;<i>   ;
</I>&gt;<i>
</I>&gt;<i> FLOATING_POINT_LITERAL
</I>&gt;<i>     :   ('0'..'9')+ '.' ('0'..'9')* Exponent? FloatTypeSuffix?
</I>&gt;<i>     |   '.' ('0'..'9')+ Exponent? FloatTypeSuffix?
</I>&gt;<i>     |   ('0'..'9')+ Exponent? FloatTypeSuffix?
</I>&gt;<i>   ;
</I>&gt;<i>
</I>&gt;<i> fragment
</I>&gt;<i> Exponent : ('e'|'E') ('+'|'-')? ('0'..'9')+ ;
</I>&gt;<i>
</I>&gt;<i> fragment
</I>&gt;<i> FloatTypeSuffix : ('f'|'F'|'d'|'D') ;
</I>&gt;<i>
</I>&gt;<i> fragment
</I>&gt;<i> EscapeSequence
</I>&gt;<i>     :   '\\' ('b'|'t'|'n'|'f'|'r'|'\&quot;'|'\''|'\\'|'/')
</I>&gt;<i>     |   OctalEscape
</I>&gt;<i>     |   UnicodeEscape
</I>&gt;<i>     ;
</I>&gt;<i>
</I>&gt;<i> fragment
</I>&gt;<i> OctalEscape
</I>&gt;<i>     :   '\\' ('0'..'3') ('0'..'7') ('0'..'7')
</I>&gt;<i>     |   '\\' ('0'..'7') ('0'..'7')
</I>&gt;<i>     |   '\\' ('0'..'7')
</I>&gt;<i>     ;
</I>&gt;<i>
</I>&gt;<i> fragment
</I>&gt;<i> UnicodeEscape
</I>&gt;<i>     :   '\\' 'u' HexDigit HexDigit HexDigit HexDigit
</I>&gt;<i>     ;
</I>&gt;<i> COMMENT
</I>&gt;<i>     :   '/*' ( options {greedy=false;} : . )* '*/' {$channel=HIDDEN;}
</I>&gt;<i>     ;
</I>&gt;<i>
</I>&gt;<i> LINE_COMMENT
</I>&gt;<i>     : '//' ~('\n'|'\r')* '\r'? '\n' {$channel=HIDDEN;}
</I>&gt;<i>     ;
</I>&gt;<i>
</I>&gt;<i> TERMINATOR
</I>&gt;<i>   : '\r'? '\n'
</I>&gt;<i>   | ';'
</I>&gt;<i>   ;
</I>&gt;<i>
</I>&gt;<i> WS  :  (' '|'\r'|'\t'|'\u000C') {$channel=HIDDEN;}
</I>&gt;<i>     |  '...' '\r'? '\n'  {$channel=HIDDEN;}
</I>&gt;<i>     ;
</I>&gt;<i>
</I>
&gt;<i> List: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">http://www.antlr.org/mailman/listinfo/antlr-interest</A>
</I>&gt;<i> Unsubscribe: <A HREF="http://www.antlr.org/mailman/options/antlr-interest/your-">http://www.antlr.org/mailman/options/antlr-interest/your-</A>
</I>&gt;<i> email-address
</I>
List: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">http://www.antlr.org/mailman/listinfo/antlr-interest</A>
Unsubscribe:
<A HREF="http://www.antlr.org/mailman/options/antlr-interest/your-email-address">http://www.antlr.org/mailman/options/antlr-interest/your-email-address</A>
</PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="043123.html">[antlr-interest] Ambiguity between floating point literal and method call
</A></li>
	<LI>Next message: <A HREF="043135.html">[antlr-interest] Ambiguity between floating point literal and method call
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#43124">[ date ]</a>
              <a href="thread.html#43124">[ thread ]</a>
              <a href="subject.html#43124">[ subject ]</a>
              <a href="author.html#43124">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
