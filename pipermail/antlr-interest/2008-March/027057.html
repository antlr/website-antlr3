<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Pruning the Parse Tree
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Pruning%20the%20Parse%20Tree&In-Reply-To=%3C5a086d5a0803102214n2937abb3rd0d2e5ae9cba0b1d%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="027052.html">
   <LINK REL="Next"  HREF="027058.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Pruning the Parse Tree</H1>
    <B>Aaron Armstrong</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Pruning%20the%20Parse%20Tree&In-Reply-To=%3C5a086d5a0803102214n2937abb3rd0d2e5ae9cba0b1d%40mail.gmail.com%3E"
       TITLE="[antlr-interest] Pruning the Parse Tree">ae.armstrong at gmail.com
       </A><BR>
    <I>Mon Mar 10 22:14:59 PDT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="027052.html">[antlr-interest] Pruning the Parse Tree
</A></li>
        <LI>Next message: <A HREF="027058.html">[antlr-interest] Fwd:  Pruning the Parse Tree
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27057">[ date ]</a>
              <a href="thread.html#27057">[ thread ]</a>
              <a href="subject.html#27057">[ subject ]</a>
              <a href="author.html#27057">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I'm not trying to pick and choose.  In fact, I would like to preserve all
the original code elements.  Parser grammars can give you a lot of baggage
(for example, separating method declarations and formal parameters out).
Right now, I have most of the base algorithm written and I just need the
parser to properly chop up the code.  I'm not interested in putting the
algorithm (which requires passing over nodes several times) into ANTLR
actions; that would be extremely messy.

When I took my compilers class, I remembered distinct parts of the
compiler.  First the lexer, then the parser, then the AST, then the symbol
table, semantics checking, and finally output.  With our parser generator
(JCup) it seemed like creating the AST was easy: each rule was a node, and
the node's children were the lexer or parser tokens that made up the rule.
I would be very happy with output like this.  When I learned that ANTLR
outputs a flat AST by default, and that I would need to write another
grammar to produce an AST of this nature, I was not happy.  I did take some
time to write AST output for importDecl; after successfully kludging
something together for this one rule (out of around 50), I decided this
would not work.

Then I did some more reading in TDAR and read about a Parse Tree.  Thinking
this would meet my simple needs, I followed the example given on the
website.  At first I got a NullPointerException following the example, but
I've worked with it more and I no longer get that.

I have been happy with the Parse Tree output.  It's just that it gives me
these extra nodes.  ANTLRWorks can recognize these extra nodes (and colors
them differently).  If someone knows how to recognize which nodes are extra,
I would be very grateful.

I understand that features like rewrite rules and StringTemplates allow for
more expressivity.  These are interesting and powerful concepts for writing
new languages.  In fact, ANTLR could probably represent all of my work so
far. However, tools this powerful require much time to master.  I just need
ANTLR to properly break up the code and give me the AST (or Parse Tree in
this case).  I can take care of the rest.

Thank you for reading my rant.

On Mon, Mar 10, 2008 at 7:22 PM, Richard Clark &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">rdclark at gmail.com</A>&gt; wrote:

&gt;<i> So Aaron, what are you trying to identify in the target language?
</I>&gt;<i> If you need to pick and choose, why not write a filter using ANTLR?
</I>&gt;<i> Filters use lexer rules to identify and extract parts of larger files.
</I>&gt;<i>
</I>&gt;<i> Krugle uses ANTLR filters to extract method declarations from multiple
</I>&gt;<i> languages. I've used filters to extract database table definitions from a
</I>&gt;<i> giant mix of table defs and procedural code (over 10,000 lines) and then
</I>&gt;<i> used the lexer definitions as the base of a SQL dialect translator.
</I>&gt;<i>
</I>&gt;<i> With as many struggles as you seem to be having, the right answer is
</I>&gt;<i> usually to back up and look at other ways to use the tool. (Years of working
</I>&gt;<i> tech support taught me this.)
</I>&gt;<i>
</I>&gt;<i> ...Richard
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://www.antlr.org/pipermail/antlr-interest/attachments/20080310/15640f16/attachment.html">http://www.antlr.org/pipermail/antlr-interest/attachments/20080310/15640f16/attachment.html</A> 
</PRE>










































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="027052.html">[antlr-interest] Pruning the Parse Tree
</A></li>
	<LI>Next message: <A HREF="027058.html">[antlr-interest] Fwd:  Pruning the Parse Tree
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27057">[ date ]</a>
              <a href="thread.html#27057">[ thread ]</a>
              <a href="subject.html#27057">[ subject ]</a>
              <a href="author.html#27057">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
