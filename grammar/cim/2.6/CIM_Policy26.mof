// ==================================================================
// Title:     Policy MOF Specification 2.6
// Filename:  CIM_Policy26.MOF
// Version:   2.6.0
// Status:    Final
// Date:      06/04/2002
// ===================================================================
// Copyright 2000-2002 Distributed Management Task Force, Inc. (DMTF).
// All rights reserved.  
// DMTF is a not-for-profit association of industry members dedicated 
// to promoting enterprise and systems management and interoperability. 
// DMTF specifications and documents may be reproduced for uses
// consistent with this purpose by members and non-members, 
// provided that correct attribution is given. 
// As DMTF specifications may be revised from time to time, 
// the particular version and release date should always be noted.
//
// Implementation of certain elements of this standard or proposed 
// standard may be subject to third party patent rights, including 
// provisional patent rights (herein "patent rights"). DMTF makes 
// no representations to users of the standard as to the existence 
// of such rights, and is not responsible to recognize, disclose, or
// identify any or all such third party patent right, owners or 
// claimants, nor for any incomplete or inaccurate identification or 
// disclosure of such rights, owners or claimants. DMTF shall have no 
// liability to any party, in any manner or circumstance, under any 
// legal theory whatsoever, for failure to recognize, disclose, or 
// identify any such third party patent rights, or for such party's
// reliance on the standard or incorporation thereof in its product, 
// protocols or testing procedures. DMTF shall have no liability to 
// any party implementing such standard, whether such implementation 
// is foreseeable or not, nor to any patent owner or claimant, and shall 
// have no liability or responsibility for costs or losses incurred if 
// a standard is withdrawn or modified after publication, and shall be
// indemnified and held harmless by any party implementing the 
// standard from any and all claims of infringement by a patent owner 
// for such implementations.
//
// For information about patents held by third-parties which have 
// notified the DMTF that, in their opinion, such patent may relate to 
// or impact implementations of DMTF standards, visit 
// http://www.dmtf.org/about/policies/disclosures.php.
// ===================================================================
// Description: The Policy Model provides a framework for specifying 
//              configuration and operational information in a scalable 
//              way using rules composed of conditions and actions.
// 
//              The object classes below are listed in an order that
//              avoids forward references. Required objects, defined
//                  by other working groups, are omitted.
// ===================================================================
//     CIMCR614 - Add CompoundPolicyAction for CIM 2.6 
//          - Add CompoundPolicyAction as a subclass of PolicyAction 
//          - Add PolicyActionStructure abstract aggregation as a 
//            subclass of PolicyComponent 
//          - Change derivation of PolicyActionInPolicyRule from 
//            PolicyComponent to PolicyActionStructure and, thus,
//            move ActionOrder property up to parent class 
//          - Add PolicyActionInPolicyAction aggregation as a 
//            subclass of PolicyActionStructure 
//
//     CIMCR597a - PCIMe updates for 2.6
//              - Edit Policy description
//              - Add PolicySet & derive PolicyGroup & PolicyRule
//              - Deprecate PolicyRule.Priority for 
//                PolicySetComponent.Priority
//              - Remove PolicyRule.PolicyRoles (it's in PolicySet)
//              - Add PolicyRule.ExecutionStrategy
//              - Deprecate PolicyRepository & replace with 
//                ReusablePolicyContainer
//              - Add PolicySetInSystem 
//              - Add PolicySetComponent & deprecate ...InPolicyGroup
//                & derive PolicyGroupInSystem & PolicyRuleInSystem
//              - Add ContainedDomain (to Core)
//                & deprecate PolicyRepositoryInPolicyRepository
//              - Add ReusablePolicy & deprecate ...InPolicyRepository
//
//     CIMCR516a - Rooted the model associations under Policy
//              Component or PolicyInSystem.  Corrected PolicyCondition/
//              PolicyActionInPolicyRepository to subclass from 
//              PolicyInSystem (similar to Groups and Roles 'InSystem')
//
//     CIMCR746 - Add the Version ("2.6.0") qualifier
//
// ==================================================================

// ==================================================================
// Pragmas
// ==================================================================
#pragma Locale ("en-US")

// ==================================================================
// Policy
// ==================================================================
   [Abstract, Version ("2.6.0"), Description (
   "An abstract class defining the common properties of the policy "
   "managed elements derived from CIM_Policy.  The subclasses are "
   "used to create rules and groups of rules that work together to "
   "form a coherent set of policies within an administrative domain "
   "or set of domains.") ]
class CIM_Policy : CIM_ManagedElement {
        [Description (
        "A user-friendly name of this policy-related object.") ]
    string CommonName;
        [Description (
        "An array of keywords for characterizing / categorizing "
        "policy objects. Keywords are of one of two types: \n"
        "- Keywords defined in this and other MOFs, or in DMTF"
        "white papers. These keywords provide a vendor-"
        "independent, installation-independent way of "
        "characterizing policy objects. \n"
        "- Installation-dependent keywords for characterizing "
        "policy objects. Examples include 'Engineering', "
        "'Billing', and 'Review in December 2000'. \n"
        "This MOF defines the following keywords:  'UNKNOWN', "
        "'CONFIGURATION', 'USAGE', 'SECURITY', 'SERVICE', "
        "'MOTIVATIONAL', 'INSTALLATION', and 'EVENT'. These "
        "concepts are self-explanatory and are further discussed "
        "in the SLA/Policy White Paper. One additional keyword "
        "is defined: 'POLICY'. The role of this keyword is to "
        "identify policy-related instances that may not be otherwise "
        "identifiable, in some implementations. The keyword 'POLICY' "
        "is NOT mutually exclusive of the other keywords "
        "specified above.") ]
    string PolicyKeywords[];
};


// ==================================================================
// PolicySet
// ==================================================================
   [Abstract, Version ("2.6.0"), 
   Description ("PolicySet is an abstract class that "
   "represents a set of policies that form a coherent set.  The "
   "set of contained policies has a common decision strategy and "
   "a common set of policy roles.  Subclasses include "
   "PolicyGroup and PolicyRule.") ]
class CIM_PolicySet : CIM_Policy {
        [Description ("PolicyDecisionStrategy defines the evaluation "
          "method used for policies contained in the PolicySet.  "
          "FirstMatching enforces the actions of the first rule that "
          "evaluates to TRUE.  It is the only value currently defined."),
          ValueMap {"1"},
          Values {"FirstMatching"} ]
    uint16 PolicyDecisionStrategy;
          [Description (
          "The PolicyRoles property represents the roles and role "
          "combinations associated with a PolicySet.  All contained "
          "PolicySet instances inherit the values of the PolicyRoles of "
        "the aggregating PolicySet but the values are not copied. "
        "A contained PolicySet instance may, however, add additional "
        "PolicyRoles to those it inherits from its aggregating "
        "PolicySet(s). \n"
        "\n"
        "Each value represents one role or role combination.  Since "
        "this is a multi-valued property, more than one role or "
        "combination can be associated with a single PolicySet.  Each "
        "value is a string of the form: \n"
        "  <RoleName>[&&<RoleName>]* \n"
        "where the individual role names appear in alphabetical order "
        "(according to the collating sequence for UCS-2).") ]
    string PolicyRoles[];
};


// ==================================================================
// PolicyGroup
// ==================================================================
   [Version ("2.6.0"), Description (
   "An aggregation of PolicySet instances (PolicyGroups and/or "
   "PolicyRules) that have the same decision strategy and inherit "
   "policy roles.   PolicyGroup instances are defined and named "
   "relative to the CIM_System that provides their context.") ]
class CIM_PolicyGroup : CIM_PolicySet {
        [Propagated("CIM_System.CreationClassName"),
        Key, MaxLen (256),
        Description ("The scoping System's CreationClassName.") ]
    string SystemCreationClassName;
        [Propagated("CIM_System.Name"),
        Key, MaxLen (256),
        Description ("The scoping System's Name.") ]
    string SystemName;
        [Key, MaxLen (256), Description (
        "CreationClassName indicates the name of the class or the "
        "subclass used in the creation of an instance. When used "
        "with the other key properties of this class, this property "
        "allows all instances of this class and its subclasses to "
        "be uniquely identified.") ]
    string CreationClassName;
        [Key, MaxLen (256), Description (
        "A user-friendly name of this PolicyGroup.") ]
    string PolicyGroupName;
};


// ==================================================================
// PolicyRule
// ==================================================================
   [Version ("2.6.0"), Description (
   "The central class used for representing the 'If Condition then "
   "Action' semantics of a policy rule. A PolicyRule condition, in "
   "the most general sense, is represented as either an ORed set of "
   "ANDed conditions (Disjunctive Normal Form, or DNF) or an ANDed "
   "set of ORed conditions (Conjunctive Normal Form, or CNF).  "
   "Individual conditions may either be negated (NOT C) or "
   "unnegated (C).  The actions specified by a PolicyRule are to be "
   "performed if and only if the PolicyRule condition (whether it "
   "is represented in DNF or CNF) evaluates to TRUE. \n"
   "\n"
   "The conditions and actions associated with a PolicyRule are "
   "modeled, respectively, with subclasses of PolicyCondition and "
   "PolicyAction.  These condition and action objects are tied to "
   "instances of PolicyRule by the PolicyConditionInPolicyRule and "
   "PolicyActionInPolicyRule aggregations. \n"
   "\n"
   "A PolicyRule may also be associated with one or more policy "
   "time periods, indicating the schedule according to which the "
   "policy rule is active and inactive.  In this case it is the "
   "PolicyRuleValidityPeriod aggregation that provides this "
   "linkage. \n"
   "\n"
   "The PolicyRule class uses the property ConditionListType, to "
   "indicate whether the conditions for the rule are in DNF or "
   "CNF.  The PolicyConditionInPolicyRule aggregation contains "
   "two additional properties to complete the representation of "
   "the Rule's conditional expression.  The first of these "
   "properties is an integer to partition the referenced "
   "PolicyConditions into one or more groups, and the second is a "
   "Boolean to indicate whether a referenced Condition is "
   "negated.  An example shows how ConditionListType and these "
   "two additional properties provide a unique representation "
   "of a set of PolicyConditions in either DNF or CNF. \n"
   "\n"
   "Suppose we have a PolicyRule that aggregates five "
   "PolicyConditions C1  through C5, with the following values "
   "in the properties of the five PolicyConditionInPolicyRule "
   "associations: \n"
   "    C1:  GroupNumber = 1, ConditionNegated = FALSE \n"
   "    C2:  GroupNumber = 1, ConditionNegated = TRUE \n"
   "    C3:  GroupNumber = 1, ConditionNegated = FALSE \n"
   "    C4:  GroupNumber = 2, ConditionNegated = FALSE \n"
   "    C5:  GroupNumber = 2, ConditionNegated = FALSE \n"
   "\n"
   "If ConditionListType = DNF, then the overall condition for "
   "the PolicyRule is: \n"
   "        (C1 AND (NOT C2) AND C3) OR (C4 AND C5) \n"
   "\n"
   "On the other hand, if ConditionListType = CNF, then the "
   "overall condition for the PolicyRule is: \n"
   "        (C1 OR (NOT C2) OR C3) AND (C4 OR C5) \n"
   "\n"
   "In both cases, there is an unambiguous specification of "
   "the overall condition that is tested to determine whether "
   "to perform the PolicyActions associated with the PolicyRule. \n"
   "\n"
   "PolicyRule instances may also be used to aggregate other "
   "PolicyRules and/or PolicyGroups.  When used in this way to "
   "implement nested rules, the conditions of the aggregating rule "
   "apply to the subordinate rules as well.  However, any side "
   "effects of condition evaluation or the execution of actions MUST "
   "NOT affect the result of the evaluation of other conditions "
   "evaluated by the rule engine in the same evaluation pass.  That "
   "is, an implementation of a rule engine MAY evaluate all "
   "conditions in any order before applying the priority and "
   "determining which actions are to be executed.") ]
class CIM_PolicyRule : CIM_PolicySet {
        [Propagated("CIM_System.CreationClassName"),
        Key, MaxLen (256),
        Description ("The scoping System's CreationClassName.") ]
    string SystemCreationClassName;
        [Propagated("CIM_System.Name"),
        Key, MaxLen (256),
        Description ("The scoping System's Name.") ]
    string SystemName;
        [Key, MaxLen (256), Description (
        "CreationClassName indicates the name of the class or the "
        "subclass used in the creation of an instance. When used "
        "with the other key properties of this class, this property "
        "allows all instances of this class and its subclasses to "
        "be uniquely identified.") ]
    string CreationClassName;
        [Key, MaxLen (256), Description (
        "A user-friendly name of this PolicyRule.") ]
    string PolicyRuleName;
        [Description (
        "Indicates whether this PolicyRule is administratively "
        "enabled, administratively disabled, or enabled for "
        "debug. When the property has the value 3 (\"enabledFor"
        "Debug\"), the entity evaluating the PolicyConditions is "
        "instructed to evaluate the conditions for the Rule, but not "
        "to perform the actions if the PolicyConditions evaluate to "
        "TRUE. This serves as a debug vehicle when attempting to "
        "determine what policies would execute in a particular "
        "scenario, without taking any actions to change state "
        "during the debugging. The default value is 1 "
        "(\"Enabled\")."),
        ValueMap {"1", "2", "3"},
        Values {"Enabled", "Disabled", "EnabledForDebug"} ]
    uint16 Enabled;
        [Description (
        "Indicates whether the list of PolicyConditions "
        "associated with this PolicyRule is in disjunctive "
        "normal form (DNF) or conjunctive normal form (CNF)."
        "The default value is 1 (\"DNF\")."),
        ValueMap {"1", "2"},
        Values {"DNF", "CNF"} ]
    uint16 ConditionListType;
        [Description (
        "A free-form string that can be used to provide "
        "guidelines on how this PolicyRule should be used.") ]
    string RuleUsage;
        [DEPRECATED {"CIM_PolicySetComponent.Priority"},
        Description (
        "PolicyRule.Priority is deprecated and replaced by "
        "providing the priority for a rule (and a group) in the "
        "context of the aggregating PolicySet instead of the "
        "priority being used for all aggregating PolicySet "
        "instances.  Thus, the assignment of priority values is "
        "much simpler. \n"
        "\n"
        "A non-negative integer for prioritizing this Policy"
        "Rule relative to other Rules. A larger value "
        "indicates a higher priority. The default value is 0.") ]
    uint16 Priority;
        [Description (
        "A flag indicating that the evaluation of the Policy"
        "Conditions and execution of PolicyActions (if the "
        "Conditions evaluate to TRUE) is required. The "
        "evaluation of a PolicyRule MUST be attempted if the "
        "Mandatory property value is TRUE.  If the Mandatory "
        "property is FALSE, then the evaluation of the Rule "
        "is 'best effort' and MAY be ignored.") ]
    boolean Mandatory;
        [Description (
        "This property gives a policy administrator a way "
        "of specifying how the ordering of the PolicyActions "
        "associated with this PolicyRule is to be interpreted. "
        "Three values are supported: \n"
        "  o mandatory(1): Do the actions in the indicated "
        "    order, or don't do them at all. \n"
        "  o recommended(2): Do the actions in the indicated "
        "    order if you can, but if you can't do them in this "
        "    order, do them in another order if you can. \n"
        "  o dontCare(3): Do them -- I don't care about the "
        "    order. \n"
        "The default value is 3 (\"DontCare\")."),
        ValueMap {"1", "2", "3"},
        Values {"Mandatory", "Recommended", "DontCare"} ]
    uint16 SequencedActions;
        [Description (
        "ExecutionStrategy defines the strategy to be used in "
        "executing the sequenced actions aggregated by this "
        "PolicyRule. There are three execution strategies: \n"
        "\n"
        "Do Until Success - execute actions according to predefined \n"
        "                   order, until successful execution of a \n"
        "                   single action. \n"
        "Do All -           execute ALL actions which are part of \n"
        "                   the modeled set, according to their \n"
        "                   predefined order. Continue doing this, \n"
        "                   even if one or more of the actions fails. \n"
        "Do Until Failure - execute actions according to predefined \n"
        "                   order, until the first failure in \n"
        "                   execution of an action instance."),
        ValueMap {"1", "2", "3"},
        Values {"Do Until Success", "Do All", "Do Until Failure"} ]
    uint16 ExecutionStrategy;
};


// ==================================================================
// ReusablePolicyContainer
// ==================================================================
   [Version ("2.6.0"), Description (
   "A class representing an administratively defined "
   "container for reusable policy-related information. "
   "This class does not introduce any additional "
   "properties beyond those in its superclass "
   "AdminDomain.  It does, however, participate in a "
   "unique association for containing policy elements. \n"
   "\n"
   "An instance of this class uses the NameFormat value"
   "\"ReusablePolicyContainer\".") ]
class CIM_ReusablePolicyContainer : CIM_AdminDomain {
};


// ==================================================================
// PolicyRepository  *** deprecated
// ==================================================================
   [DEPRECATED{"CIM_ReusablePolicyContainer"}, 
   Version ("2.6.0"), Description (
   "The term 'PolicyRepository' has been confusing to both "
   "developers and users of the model.  The replacement class "
   "name describes model element properly and is less likely "
   "to be confused with a data repository. \n"
   "\n"
   "A class representing an administratively defined "
   "container for reusable policy-related information. "
   "This class does not introduce any additional "
   "properties beyond those in its superclass "
   "AdminDomain.  It does, however, participate in a "
   "number of unique associations. \n"
   "\n"
   "An instance of this class uses the NameFormat value"
   "\"PolicyRepository\".") ]
class CIM_PolicyRepository : CIM_AdminDomain {
};


// ==================================================================
// PolicyCondition
// ==================================================================
   [Abstract, Version ("2.6.0"), Description (
   "A class representing a rule-specific or reusable policy "
   "condition to be evaluated in conjunction with a Policy"
   "Rule. Since all operational details of a PolicyCondition "
   "are provided in subclasses of this object, this class is "
   "abstract.") ]
class CIM_PolicyCondition : CIM_Policy {
        [Key, MaxLen (256), Description (
        "  The name of the class or the subclass used in the "
        "creation of the System object in whose scope this "
        "PolicyCondition is defined. \n"
        "\n"
        "This property helps to identify the System object in "
        "whose scope this instance of PolicyCondition exists. "
        "For a rule-specific PolicyCondition, this is the System "
        "in whose context the PolicyRule is defined. For a "
        "reusable PolicyCondition, this is the instance of "
        "PolicyRepository (which is a subclass of System) that "
        "holds the Condition. \n"
        "\n"
        "Note that this property, and the analogous property "
        "SystemName, do not represent propagated keys from an "
        "instance of the class System. Instead, they are "
        "properties defined in the context of this class, which "
        "repeat the values from the instance of System to which "
        "this PolicyCondition is related, either directly via the "
        "PolicyConditionInPolicyRepository association or indirectly "
        "via the PolicyConditionInPolicyRule aggregation.") ]
    string SystemCreationClassName;
        [Key, MaxLen (256), Description (
        "The name of the System object in whose scope this "
        "PolicyCondition is defined. \n"
        "\n"
        "This property completes the identification of the System "
        "object in whose scope this instance of PolicyCondition "
        "exists.  For a rule-specific PolicyCondition, this is the "
        "System in whose context the PolicyRule is defined.  For a "
        "reusable PolicyCondition, this is the instance of "
        "PolicyRepository (which is a subclass of System) that "
        "holds the Condition.") ]
    string SystemName;
        [Key, MaxLen (256), Description (
        "For a rule-specific PolicyCondition, the "
        "CreationClassName of the PolicyRule object with which "
        "this Condition is associated.  For a reusable Policy"
        "Condition, a special value, 'NO RULE', should be used to "
        "indicate that this Condition is reusable and not "
        "associated with a single PolicyRule.") ]
    string PolicyRuleCreationClassName;
        [Key, MaxLen (256), Description (
        "For a rule-specific PolicyCondition, the name of "
        "the PolicyRule object with which this Condition is "
        "associated.  For a reusable PolicyCondition, a "
        "special value, 'NO RULE', should be used to indicate "
        "that this Condition is reusable and not associated "
        "with a single PolicyRule.") ]
    string PolicyRuleName;
        [Key, MaxLen (256), Description (
        "CreationClassName indicates the name of the class or the "
        "subclass used in the creation of an instance. When used "
        "with the other key properties of this class, this property "
        "allows all instances of this class and its subclasses to "
        "be uniquely identified.") ]
    string CreationClassName;
        [Key, MaxLen (256), Description (
        "A user-friendly name of this PolicyCondition.") ]
    string PolicyConditionName;
};


// ==================================================================
// PolicyTimePeriodCondition
// ==================================================================
   [Version ("2.6.0"), Description (
   "This class provides a means of representing the time "
   "periods during which a PolicyRule is valid, i.e., active. "
   "At all times that fall outside these time periods, the "
   "PolicyRule has no effect.  A Rule is treated as valid "
   "at ALL times, if it does not specify a "
   "PolicyTimePeriodCondition. \n"
   "\n"
   "In some cases a Policy Consumer may need to perform "
   "certain setup / cleanup actions when a PolicyRule becomes "
   "active / inactive.  For example, sessions that were "
   "established while a Rule was active might need to "
   "be taken down when the Rule becomes inactive.  In other "
   "cases, however, such sessions might be left up.  In this "
   "case, the effect of deactivating the PolicyRule would "
   "just be to prevent the establishment of new sessions. \n"
   "\n"
   "Setup / cleanup behaviors on validity period "
   "transitions are not currently addressed by the Policy "
   "Model, and must be specified in 'guideline' documents or "
   "via subclasses of CIM_PolicyRule, CIM_PolicyTimePeriod"
   "Condition or other concrete subclasses of CIM_Policy. If "
   "such behaviors need to be under the control of the policy "
   "administrator, then a mechanism to allow this control "
   "must also be specified in the subclasses. \n"
   "\n"
   "PolicyTimePeriodCondition is defined as a subclass of "
   "PolicyCondition. This is to allow the inclusion of "
   "time-based criteria in the AND/OR condition definitions "
   "for a PolicyRule. \n"
   "\n"
   "Instances of this class may have up to five properties "
   "identifying time periods at different levels. The values "
   "of all the properties present in an instance are ANDed "
   "together to determine the validity period(s) for the "
   "instance. For example, an instance with an overall "
   "validity range of January 1, 2000 through December 31, "
   "2000; a month mask that selects March and April; a "
   "day-of-the-week mask that selects Fridays; and a time "
   "of day range of 0800 through 1600 would be represented "
   "using the following time periods: \n"
   "   Friday, March  5, 2000, from 0800 through 1600; \n "
   "   Friday, March 12, 2000, from 0800 through 1600; \n "
   "   Friday, March 19, 2000, from 0800 through 1600; \n "
   "   Friday, March 26, 2000, from 0800 through 1600; \n "
   "   Friday, April  2, 2000, from 0800 through 1600; \n "
   "   Friday, April  9, 2000, from 0800 through 1600; \n "
   "   Friday, April 16, 2000, from 0800 through 1600; \n "
   "   Friday, April 23, 2000, from 0800 through 1600; \n "
   "   Friday, April 30, 2000, from 0800 through 1600. \n"
   "\n"
   "Properties not present in an instance of "
   "PolicyTimePeriodCondition are implicitly treated as having "
   "their value 'always enabled'. Thus, in the example above, "
   "the day-of-the-month mask is not present, and so the "
   "validity period for the instance implicitly includes a "
   "day-of-the-month mask that selects all days of the month. "
   "If this 'missing property' rule is applied to its fullest, we "
   "see that there is a second way to indicate that a Policy"
   "Rule is always enabled: associate with it an instance of "
   "PolicyTimePeriodCondition whose only properties with "
   "specific values are its key properties.") ]
class CIM_PolicyTimePeriodCondition : CIM_PolicyCondition {
        [Description (
        "This property identifies an overall range of calendar "
        "dates and times over which a PolicyRule is valid.  It is "
        "formatted as a string representing a start date and time, "
        "in which the character 'T' indicates the beginning of the "
        "time portion, followed by the solidus character '/', "
        "followed by a similar string representing an end date and "
        "time.  The first date indicates the beginning of the range, "
        "while the second date indicates the end.  Thus, the second "
        "date and time must be later than the first.  Date/times are "
        "expressed as substrings of the form yyyymmddThhmmss.  For "
        "example: \n"
        "   20000101T080000/20000131T120000 defines \n"
        "   January 1, 2000, 0800 through January 31, 2000, noon \n"
        "\n"
        "There are also two special cases in which one of the "
        "date/time strings is replaced with a special string defined "
        "in RFC 2445. \n "
        "   o If the first date/time is replaced with the string "
        "     'THISANDPRIOR', then the property indicates that a "
        "     PolicyRule is valid [from now] until the date/time "
        "     that appears after the '/'. \n"
        "   o If the second date/time is replaced with the string "
        "     'THISANDFUTURE', then the property indicates that a "
        "     PolicyRule becomes valid on the date/time that "
        "     appears before the '/', and remains valid from that "
        "     point on."),
        ModelCorrespondence {
        "CIM_PolicyTimePeriodCondition.MonthOfYearMask",
        "CIM_PolicyTimePeriodCondition.DayOfMonthMask",
        "CIM_PolicyTimePeriodCondition.DayOfWeekMask",
        "CIM_PolicyTimePeriodCondition.TimeOfDayMask",
        "CIM_PolicyTimePeriodCondition.LocalOrUtcTime"} ]
    string TimePeriod;
        [Octetstring, Description (
        "The purpose of this property is to refine the valid time "
        "period that is defined by the TimePeriod property, by "
        "explicitly specifying in which months the PolicyRule is "
        "valid. These properties work together, with the "
        "TimePeriod used to specify the overall time period in "
        "which the PolicyRule is valid, and the MonthOfYearMask used "
        "to pick out the months during which the Rule is valid. \n"
        "\n"
        "This property is formatted as an octet string, structured "
        "as follows: \n"
        "   o a 4-octet length field, indicating the length of the "
        "    entire octet string; this field is always set to "
        "    0x00000006 for this property; \n"
        "   o a 2-octet field consisting of 12 bits identifying the "
        "     12 months of the year, beginning with January and "
        "     ending with December, followed by 4 bits that are "
        "     always set to '0'.  For each month, the value '1' "
        "     indicates that the policy is valid for that month, "
        "     and the value '0' indicates that it is not valid. \n"
        "\n"
        "The value 0x000000060830, for example, indicates that a "
        "PolicyRule is valid only in the months May, November, "
        "and December. \n"
        "\n"
        "If a value for this property is not provided, then the "
        "PolicyRule is treated as valid for all twelve months, and "
        "only restricted by its TimePeriod property value and the "
        "other Mask properties."),
        ModelCorrespondence {
        "CIM_PolicyTimePeriodCondition.TimePeriod",
        "CIM_PolicyTimePeriodCondition.LocalOrUtcTime"} ]
    uint8 MonthOfYearMask[];
        [Octetstring, Description (
        "The purpose of this property is to refine the valid time "
        "period that is defined by the TimePeriod property, by "
        "explicitly specifying in which days of the month the Policy"
        "Rule is valid. These properties work together, "
        "with the TimePeriod used to specify the overall time period "
        "in which the PolicyRule is valid, and the DayOfMonthMask used "
        "to pick out the days of the month during which the Rule "
        "is valid. \n"
        "\n "
        "This property is formatted as an octet string, structured "
        "as follows: \n"
        "   o a 4-octet length field, indicating the length of the "
        "     entire octet string; this field is always set to "
        "     0x0000000C for this property; \n"
        "   o an 8-octet field consisting of 31 bits identifying "
        "     the days of the month counting from the beginning, "
        "     followed by 31 more bits identifying the days of the "
        "     month counting from the end, followed by 2 bits that "
        "     are always set to '0'.  For each day, the value '1' "
        "     indicates that the policy is valid for that day, and "
        "     the value '0' indicates that it is not valid. \n"
        "\n"
        "The value 0x0000000C8000000100000000, for example, "
        "indicates that a PolicyRule is valid on the first and "
        "last days of the month. \n"
        "\n "
        "For months with fewer than 31 days, the digits corresponding "
        "to days that the months do not have (counting in both "
        "directions) are ignored. \n"
        "\n"
        "If a value for this property is not provided, then the "
        "PolicyRule is treated as valid for all days of the month, and "
        "only restricted by its TimePeriod property value and the "
        "other Mask properties."),
        ModelCorrespondence {
        "CIM_PolicyTimePeriodCondition.TimePeriod",
        "CIM_PolicyTimePeriodCondition.LocalOrUtcTime"} ]
    uint8 DayOfMonthMask[];
        [Octetstring, Description (
        "The purpose of this property is to refine the valid time "
        "period that is defined by the TimePeriod property, by "
        "explicitly specifying in which days of the month the Policy"
        "Rule is valid. These properties work together, "
        "with the TimePeriod used to specify the overall time period "
        "in which the PolicyRule is valid, and the DayOfWeekMask used "
        "to pick out the days of the week during which the Rule "
        "is valid. \n"
        "\n "
        "This property is formatted as an octet string, structured "
        "as follows: \n "
        "  o a 4-octet length field, indicating the length of the "
        "    entire octet string; this field is always set to "
        "    0x00000005 for this property; \n"
        "  o a 1-octet field consisting of 7 bits identifying the 7 "
        "    days of the week, beginning with Sunday and ending with "
        "    Saturday, followed by 1 bit that is always set to '0'. "
        "    For each day of the week, the value '1' indicates that "
        "    the policy is valid for that day, and the value '0' "
        "    indicates that it is not valid. \n"
        "\n"
        "The value 0x000000057C, for example, indicates that a "
        "PolicyRule is valid Monday through Friday. \n"
        "\n"
        "If a value for this property is not provided, then the "
        "PolicyRule is treated as valid for all days of the week, "
        "and only restricted by its TimePeriod property value and "
        "the other Mask properties."),
        ModelCorrespondence {
        "CIM_PolicyTimePeriodCondition.TimePeriod",
        "CIM_PolicyTimePeriodCondition.LocalOrUtcTime"} ]
    uint8 DayOfWeekMask[];
        [Description (
        "The purpose of this property is to refine the valid time "
        "period that is defined by the TimePeriod property, by "
        "explicitly specifying a range of times in a day during which "
        "the PolicyRule is valid. These properties work "
        "together, with the TimePeriod used to specify the overall "
        "time period in which the PolicyRule is valid, and the "
        "TimeOfDayMask used to pick out the range of time periods "
        "in a given day of during which the Rule is valid. \n"
        "\n"
        "This property is formatted in the style of RFC 2445:  a "
        "time string beginning with the character 'T', followed by "
        "the solidus character '/', followed by a second time string. "
        "The first time indicates the beginning of the range, while "
        "the second time indicates the end.  Times are expressed as "
        "substrings of the form 'Thhmmss'. \n"
        "\n"
        "The second substring always identifies a later time than "
        "the first substring.  To allow for ranges that span "
        "midnight, however, the value of the second string may be "
        "smaller than the value of the first substring.  Thus, "
        "'T080000/T210000' identifies the range from 0800 until 2100, "
        "while 'T210000/T080000' identifies the range from 2100 until "
        "0800 of the following day. \n"
        "\n"
        "When a range spans midnight, it by definition includes "
        "parts of two successive days.  When one of these days is "
        "also selected by either the MonthOfYearMask, "
        "DayOfMonthMask, and/or DayOfWeekMask, but the other day is "
        "not, then the policy is active only during the portion of "
        "the range that falls on the selected day.  For example, if "
        "the range extends from 2100 until 0800, and the day of "
        "week mask selects Monday and Tuesday, then the policy is "
        "active during the following three intervals: \n"
        "    From midnight Sunday until 0800 Monday; \n"
        "    From 2100 Monday until 0800 Tuesday; \n"
        "    From 2100 Tuesday until 23:59:59 Tuesday. \n"
        "\n"
        "If a value for this property is not provided, then the "
        "PolicyRule is treated as valid for all hours of the day, "
        "and only restricted by its TimePeriod property value and "
        "the other Mask properties."),
        ModelCorrespondence {
        "CIM_PolicyTimePeriodCondition.TimePeriod",
        "CIM_PolicyTimePeriodCondition.LocalOrUtcTime"} ]
    string TimeOfDayMask;
        [Description (
        "This property indicates whether the times represented "
        "in the TimePeriod property and in the various Mask "
        "properties represent local times or UTC times.  There is "
        "no provision for mixing of local times and UTC times:  the "
        "value of this property applies to all of the other "
        "time-related properties."),
        ValueMap {"1", "2"},
        Values {"LocalTime", "UTCTime"}, 
        ModelCorrespondence {
        "CIM_PolicyTimePeriodCondition.TimePeriod",
        "CIM_PolicyTimePeriodCondition.MonthOfYearMask",
        "CIM_PolicyTimePeriodCondition.DayOfMonthMask",
        "CIM_PolicyTimePeriodCondition.DayOfWeekMask",
        "CIM_PolicyTimePeriodCondition.TimeOfDayMask"} ]
    uint16 LocalOrUtcTime;
};


// ==================================================================
// VendorPolicyCondition
// ==================================================================
   [Version ("2.6.0"), Description (
   "A class that provides a general extension mechanism for "
   "representing PolicyConditions that have not been modeled "
   "with specific properties. Instead, the two properties "
   "Constraint and ConstraintEncoding are used to define the "
   "content and format of the Condition, as explained below. \n"
   "\n"
   "As its name suggests, VendorPolicyCondition is intended for "
   "vendor-specific extensions to the Policy Core Information "
   "Model.  Standardized extensions are not expected to use "
   "this class.") ]
class CIM_VendorPolicyCondition : CIM_PolicyCondition {
        [Octetstring, Description (
        "This property provides a general extension mechanism for "
        "representing PolicyConditions that have not been "
        "modeled with specific properties. The format of the "
        "octet strings in the array is left unspecified in "
        "this definition.  It is determined by the OID value "
        "stored in the property ConstraintEncoding.  Since "
        "ConstraintEncoding is single-valued, all the values of "
        "Constraint share the same format and semantics."),
        ModelCorrespondence {
        "CIM_VendorPolicyCondition.ConstraintEncoding"} ]
    string Constraint[];
        [Description (
        "An OID encoded as a string, identifying the format "
        "and semantics for this instance's Constraint property."),
        ModelCorrespondence {
        "CIM_VendorPolicyCondition.Constraint"} ]
    string ConstraintEncoding;
};

// ==================================================================
// PolicyAction
// ==================================================================
   [Abstract, Version ("2.6.0"), Description (
   "A class representing a rule-specific or reusable policy "
   "action to be performed if the PolicyConditions for a Policy"
   "Rule evaluate to TRUE. Since all operational details of a "
   "PolicyAction are provided in subclasses of this object, "
   "this class is abstract.") ]
class CIM_PolicyAction : CIM_Policy {
        [Key, MaxLen (256), Description (
        "The name of the class or the subclass used in the "
        "creation of the System object in whose scope this "
        "PolicyAction is defined. \n"
        "\n"
        "This property helps to identify the System object in "
        "whose scope this instance of PolicyAction exists. "
        "For a rule-specific PolicyAction, this is the System "
        "in whose context the PolicyRule is defined. For a "
        "reusable PolicyAction, this is the instance of "
        "PolicyRepository (which is a subclass of System) that "
        "holds the Action. \n"
        "\n"
        "Note that this property, and the analogous property "
        "SystemName, do not represent propagated keys from an "
        "instance of the class System. Instead, they are "
        "properties defined in the context of this class, which "
        "repeat the values from the instance of System to which "
        "this PolicyAction is related, either directly via the "
        "PolicyActionInPolicyRepository association or indirectly "
        "via the PolicyActionInPolicyRule aggregation.") ]
    string SystemCreationClassName;
        [Key, MaxLen (256), Description (
        "The name of the System object in whose scope this "
        "PolicyAction is defined. \n"
        "\n"
        "This property completes the identification of the System "
        "object in whose scope this instance of PolicyAction "
        "exists.  For a rule-specific PolicyAction, this is the "
        "System in whose context the PolicyRule is defined.  For "
        "a reusable PolicyAction, this is the instance of "
        "PolicyRepository (which is a subclass of System) that "
        "holds the Action.") ]
    string SystemName;
        [Key, MaxLen (256), Description (
        "For a rule-specific PolicyAction, the CreationClassName "
        "of the PolicyRule object with which this Action is "
        "associated.  For a reusable PolicyAction, a "
        "special value, 'NO RULE', should be used to "
        "indicate that this Action is reusable and not "
        "associated with a single PolicyRule.") ]
    string PolicyRuleCreationClassName;
        [Key, MaxLen (256), Description (
        "For a rule-specific PolicyAction, the name of "
        "the PolicyRule object with which this Action is "
        "associated.  For a reusable PolicyAction, a "
        "special value, 'NO RULE', should be used to "
        "indicate that this Action is reusable and not "
        "associated with a single PolicyRule.") ]
    string PolicyRuleName;
        [Key, MaxLen (256), Description (
        "CreationClassName indicates the name of the class or the "
        "subclass used in the creation of an instance. When used "
        "with the other key properties of this class, this property "
        "allows all instances of this class and its subclasses to "
        "be uniquely identified.") ]
    string CreationClassName;
        [Key, MaxLen (256), Description (
        "A user-friendly name of this PolicyAction.") ]
    string PolicyActionName;
};


// ==================================================================
// VendorPolicyAction
// ==================================================================
   [Version ("2.6.0"), Description (
   "A class that provides a general extension mechanism for "
   "representing PolicyActions that have not been modeled "
   "with specific properties. Instead, the two properties "
   "ActionData and ActionEncoding are used to define the "
   "content and format of the Action, as explained below. \n"
   "\n"
   "As its name suggests, VendorPolicyAction is intended for "
   "vendor-specific extensions to the Policy Core Information "
   "Model.  Standardized extensions are not expected to use "
   "this class.")  ]
class CIM_VendorPolicyAction : CIM_PolicyAction {
        [Octetstring, Description (
        "This property provides a general extension mechanism for "
        "representing PolicyActions that have not been "
        "modeled with specific properties. The format of the "
        "octet strings in the array is left unspecified in "
        "this definition.  It is determined by the OID value "
        "stored in the property ActionEncoding.  Since "
        "ActionEncoding is single-valued, all the values of "
        "ActionData share the same format and semantics."),
        ModelCorrespondence {
        "CIM_VendorPolicyAction.ActionEncoding"} ]
    string ActionData[];
        [Description (
        "An OID encoded as a string, identifying the format "
        "and semantics for this instance's ActionData property."),
        ModelCorrespondence {
        "CIM_VendorPolicyAction.ActionData"} ]
    string ActionEncoding;
};


// ==================================================================
// CompoundPolicyAction
// ==================================================================
   [Version ("2.6.0"), 
   Description ("CompoundPolicyAction is used to represent an "
   "expression consisting of an ordered sequence of action "
   "terms.  Each action term is represented as a subclass of "
   "the PolicyAction class.  Compound actions are constructed "
   "by associating dependent action terms together using the "
   "PolicyActionInPolicyAction aggregation.") ]
class CIM_CompoundPolicyAction : CIM_PolicyAction {
        [Description (
        "This property gives a policy administrator a way "
        "of specifying how the ordering of the PolicyActions "
        "associated with this PolicyRule is to be interpreted. "
        "Three values are supported: \n"
        "  o mandatory(1): Do the actions in the indicated "
        "    order, or don't do them at all. \n"
        "  o recommended(2): Do the actions in the indicated "
        "    order if you can, but if you can't do them in this "
        "    order, do them in another order if you can. \n"
        "  o dontCare(3): Do them -- I don't care about the "
        "    order. \n"
        "The default value is 3 (\"DontCare\")."),
        ValueMap {"1", "2", "3"},
        Values {"Mandatory", "Recommended", "DontCare"} ]
    uint16 SequencedActions;
        [Description ("ExecutionStrategy defines the strategy to be "
        "used in executing the sequenced actions aggregated by this "
        "CompoundPolicyAction. There are three execution strategies: \n"
        "\n"
        "Do Until Success - execute actions according to predefined \n"
        "                   order, until successful execution of a \n"
        "                   single action. \n"
        "Do All -           execute ALL actions which are part of \n"
        "                   the modeled set, according to their \n"
        "                   predefined order. Continue doing this, \n"
        "                   even if one or more of the actions "
        "                   fails. \n"
        "Do Until Failure - execute actions according to predefined \n"
        "                   order, until the first failure in \n"
        "                   execution of an action instance. \n"
        "The default value is 2 (\"Do All\")."),
      ValueMap {"1", "2", "3"},
      Values {"Do Until Success", "Do All", "Do Until Failure"} ]
   uint16 ExecutionStrategy;
};


// ==================================================================
// ===                   Association classes                      ===
// ==================================================================


// ==================================================================
// PolicyComponent
// ==================================================================
   [Association, Abstract, Aggregation, Version ("2.6.0"), 
   Description (
   "CIM_PolicyComponent is a generic association used to "
   "establish 'part of' relationships between the subclasses of "
   "CIM_Policy. For example, the PolicyConditionInPolicyRule "
   "association defines that PolicyConditions are part of a "
   "PolicyRule.") ]
class CIM_PolicyComponent {
        [Aggregate, Key, Description (
        "The parent Policy in the association.") ]
    CIM_Policy REF GroupComponent;
        [Key, Description (
        "The child/part Policy in the association.") ]
    CIM_Policy REF PartComponent;
};


// ==================================================================
// PolicyInSystem
// ==================================================================
   [Association, Abstract, Version ("2.6.0"), Description (
   "CIM_PolicyInSystem is a generic association used to "
   "establish dependency relationships between Policies and the "
   "Systems that host them. These Systems may be ComputerSystems "
   "where Policies are 'running' or they may be Policy"
   "Repositories where Policies are stored. This relationship "
   "is similar to the concept of CIM_Services being dependent "
   "on CIM_Systems as defined by the HostedService "
   "association. \n"
   "\n"
   "Cardinality is Max (1) for the Antecedent/System "
   "reference since Policies can only be hosted in at most one "
   "System context. Some subclasses of the association will "
   "further refine this definition to make the Policies Weak "
   "to Systems. Other subclasses of PolicyInSystem will "
   "define an optional hosting relationship. Examples of each "
   "of these are the PolicyRuleInSystem and PolicyConditionIn"
   "PolicyRepository associations, respectively.") ]
class CIM_PolicyInSystem : CIM_Dependency {
        [Override ("Antecedent"), Max (1), Description (
        "The hosting System.") ]
    CIM_System REF Antecedent;
        [Override ("Dependent"), Description (
        "The hosted Policy.") ]
    CIM_Policy REF Dependent;
};


// ==================================================================
// PolicySetInSystem
// ==================================================================
   [Association, Abstract, Version ("2.6.0"), Description (
   "PolicySetInSystem is an abstract association class that "
   "represents a relationship between a System and a PolicySet used "
   "in the administrative scope of that system (e.g., AdminDomain, "
   "ComputerSystem).  The Priority property is used to assign a "
   "relative priority to a PolicySet within the administrative "
   "scope in contexts where it is not a component of another "
   "PolicySet.") ]
class CIM_PolicySetInSystem : CIM_PolicyInSystem {
        [Override ("Antecedent"), Min (1), Max (1), Description (
        "The System in whose scope a PolicySet is defined.") ]
    CIM_System REF Antecedent;
        [Override ("Dependent"), Description (
        "A PolicySet named within the scope of a System.") ]
    CIM_PolicySet REF Dependent;
          [Description (
          "The Priority property is used to specify the relative "
          "priority of the referenced PolicySet when there are more "
        "than one PolicySet instances applied to a managed resource "
        "that are not PolicySetComponents and, therefore, have no "
        "other relative priority defined.  The priority is a "
        "non-negative integer; a larger value indicates a higher "
        "priority.") ]
    uint16 Priority;
};


// ==================================================================
// PolicyGroupInSystem
// ==================================================================
   [Association, Version ("2.6.0"), Description (
   "An association that links a PolicyGroup to the System "
   "in whose scope the Group is defined.") ]
class CIM_PolicyGroupInSystem : CIM_PolicySetInSystem {
        [Override ("Antecedent"), Min (1), Max (1), Description (
        "The System in whose scope a PolicyGroup is defined.") ]
    CIM_System REF Antecedent;
        [Override ("Dependent"), Weak, Description (
        "A PolicyGroup named within the scope of a System.") ]
    CIM_PolicyGroup REF Dependent;
};


// ==================================================================
// PolicyRuleInSystem
// ==================================================================
   [Association, Version ("2.6.0"), Description (
   "An association that links a PolicyRule to the System "
   "in whose scope the Rule is defined.") ]
class CIM_PolicyRuleInSystem : CIM_PolicySetInSystem {
        [Override ("Antecedent"), Min (1), Max (1), Description (
        "The System in whose scope a PolicyRule is defined.") ]
    CIM_System REF Antecedent;
        [Override ("Dependent"), Weak, Description (
        "A PolicyRule named within the scope of a System.") ]
    CIM_PolicyRule REF Dependent;
};


// ==================================================================
// PolicySetComponent 
// ==================================================================
   [Association, Aggregation, Version ("2.6.0"), Description (
   "PolicySetComponent is a concrete aggregation class that "
   "collects instances of PolicySet subclasses (PolicyGroups and "
   "PolicyRules) into coherent sets of policies that have the same "
   "decision strategy and are prioritized within the set.") ]
class CIM_PolicySetComponent : CIM_PolicyComponent {
        [Override ("GroupComponent"), Aggregate, Description (
        "A PolicySet that aggregates other PolicySet instances.") ]
    CIM_PolicySet REF GroupComponent;
        [Override ("PartComponent"), Description (
        "A PolicySet aggregated into a PolicySet.") ]
    CIM_PolicySet REF PartComponent;
        [Description (
        "A non-negative integer for prioritizing this PolicySet"
        "component relative to components of the same PolicySet. A "
        "larger value indicates a higher priority.") ]
    uint16 Priority;
};


// ==================================================================
// PolicyGroupInPolicyGroup *** deprecated
// ==================================================================
   [Association, Aggregation, DEPRECATED {"CIM_PolicySetComponent"},
   Version ("2.6.0"), Description (
   "PolicySetComponent provides a more general mechanism for "
   "aggregating both PolicyGroups and PolicyRules and doing so with "
   "the priority value applying only to the aggregated set rather "
   "than policy wide. \n"
   "\n"
   "A relationship that aggregates one or more lower-level " 
   "PolicyGroups into a higher-level Group.  A Policy" 
   "Group may aggregate PolicyRules and/or other Policy" 
   "Groups.") ]
class CIM_PolicyGroupInPolicyGroup : CIM_PolicyComponent {
        [Override ("GroupComponent"), Aggregate, Description (
        "A PolicyGroup that aggregates other Groups.") ]
    CIM_PolicyGroup REF GroupComponent;
        [Override ("PartComponent"), Description (
        "A PolicyGroup aggregated by another Group.") ]
    CIM_PolicyGroup REF PartComponent;
};


// ==================================================================
// PolicyRuleInPolicyGroup *** deprecated
// ==================================================================
   [Association, Aggregation, DEPRECATED {"CIM_PolicySetComponent"},
   Version ("2.6.0"), Description (
   "PolicySetComponent provides a more general mechanism for "
   "aggregating both PolicyGroups and PolicyRules and doing so with "
   "the priority value applying only to the aggregated set rather "
   "than policy wide. \n"
   "\n"
   "A relationship that aggregates one or more PolicyRules " 
   "into a PolicyGroup.  A PolicyGroup may aggregate " 
   "PolicyRules and/or other PolicyGroups.") ]
class CIM_PolicyRuleInPolicyGroup : CIM_PolicyComponent {
        [Override ("GroupComponent"), Aggregate, Description (
        "A PolicyGroup that aggregates one or more PolicyRules.") ]
    CIM_PolicyGroup REF GroupComponent;
        [Override ("PartComponent"), Description (
        "A PolicyRule aggregated by a PolicyGroup.") ]
    CIM_PolicyRule REF PartComponent;
};


// ==================================================================
// PolicyConditionInPolicyRule
// ==================================================================
   [Association, Aggregation, Version ("2.6.0"), Description (
   "A PolicyRule aggregates zero or more instances of the "
   "PolicyCondition class, via the PolicyConditionInPolicyRule "
   "association.  A Rule that aggregates zero Conditions is not "
   "valid -- it may, however, be in the process of being entered "
   "into a PolicyRepository or being defined for a System. Note "
   "that a PolicyRule should have no effect until it is valid. \n"
   "\n"
   "The Conditions aggregated by a PolicyRule are grouped into "
   "two levels of lists: either an ORed set of ANDed sets of "
   "conditions (DNF, the default) or an ANDed set of ORed sets "
   "of conditions (CNF).  Individual PolicyConditions in these "
   "lists may be negated.  The property ConditionListType "
   "specifies which of these two grouping schemes applies to a "
   "particular PolicyRule. \n"
   "\n"
   "In either case, PolicyConditions are used to determine whether "
   "to perform the PolicyActions associated with the PolicyRule. \n"
   "\n"
   "One or more PolicyTimePeriodConditions may be among the "
   "conditions associated with a PolicyRule via the Policy"
   "ConditionInPolicyRule association.  In this case, the time "
   "periods are simply additional Conditions to be evaluated "
   "along with any others that are specified for the Rule.") ]
class CIM_PolicyConditionInPolicyRule : CIM_PolicyComponent {
        [Override ("GroupComponent"), Aggregate, Description (
        "This property represents the PolicyRule that "
        "contains one or more PolicyConditions.") ]
    CIM_PolicyRule REF GroupComponent;
        [Override ("PartComponent"), Description (
        "This property holds the name of a PolicyCondition "
        "contained by one or more PolicyRules.") ]
    CIM_PolicyCondition REF PartComponent;
        [Description (
        "Unsigned integer indicating the group to which the "
        "PolicyCondition identified by the ContainedCondition "
        "property belongs. This integer segments the Conditions "
        "into the ANDed sets (when the ConditionListType is "
        "\"DNF\") or similarly the ORed sets (when the Condition"
        "ListType is \"CNF\") that are then evaluated.") ]
    uint16 GroupNumber;
        [Description (
        "Indication of whether the Condition identified by "
        "the ContainedCondition property is negated.  TRUE "
        "indicates that the PolicyCondition IS negated, FALSE "
        "indicates that it IS NOT negated.") ]
    boolean ConditionNegated;
};


// ==================================================================
// PolicyRuleValidityPeriod
// ==================================================================
   [Association, Aggregation, Version ("2.6.0"), Description (
   "The PolicyRuleValidityPeriod aggregation represents "
   "scheduled activation and deactivation of a PolicyRule. "
   "If a PolicyRule is associated with multiple policy time "
   "periods via this association, then the Rule is active if "
   "at least one of the time periods indicates that it is "
   "active.  (In other words, the PolicyTimePeriodConditions "
   "are ORed to determine whether the Rule is active.)  A Time"
   "Period may be aggregated by multiple PolicyRules.  A Rule "
   "that does not point to a PolicyTimePeriodCondition via this "
   "association is, from the point of view of scheduling, "
   "always active.  It may, however, be inactive for other "
   "reasons.  For example, the Rule's Enabled property may "
   "be set to \"disabled\" (value=2).") ]
class CIM_PolicyRuleValidityPeriod : CIM_PolicyComponent {
        [Override ("GroupComponent"), Aggregate, Description (
        "This property contains the name of a PolicyRule that "
        "contains one or more PolicyTimePeriodConditions.") ]
    CIM_PolicyRule REF GroupComponent;
        [Override ("PartComponent"), Description (
        "This property contains the name of a "
        "PolicyTimePeriodCondition defining the valid time periods "
        "for one or more PolicyRules.") ]
    CIM_PolicyTimePeriodCondition REF PartComponent;
};
 

// ==================================================================
// PolicyActionStructure
// ==================================================================   
   [Association, Aggregation, Abstract, Version ("2.6.0"), 
   Description (
   "PolicyActions may be aggregated into rules and into "
   "compound actions.  PolicyActionStructure is the abstract "
   "aggregation class for the structuring of policy actions.") ]
class CIM_PolicyActionStructure : CIM_PolicyComponent {
        [Override ("GroupComponent"), Aggregate, Description (
        "PolicyAction instances may be aggregated into either "
        "PolicyRule instances or CompoundPolicyAction instances.") ]
    CIM_Policy REF GroupComponent;
        [Override ("PartComponent"), Description (
        "A PolicyAction aggregated by a PolicyRule or "
        "CompoundPolicyAction.") ]
    CIM_PolicyAction REF PartComponent;
        [Description (
        "ActionOrder is an unsigned integer 'n' that indicates the "
        "relative position of a PolicyAction in the sequence of"
        "actions associated with a PolicyRule or "
        "CompoundPolicyAction.  When 'n' is a positive integer, it "
        "indicates a place in the sequence of actions to be "
        "performed, with smaller integers indicating earlier "
        "positions in the sequence. The special value '0' indicates "
        "'don't care'.  If two or more PolicyActions have the same "
        "non-zero sequence number, they may be performed in any "
        "order, but they must all be performed at the appropriate "
        "place in the  overall action sequence. \n"
        "\n"
        "A series of examples will make ordering of PolicyActions "
        "clearer: \n"
        "    o If all actions have the same sequence number, \n"
        "      regardless of whether it is '0' or non-zero, any \n"
        "      order is acceptable. \n"
        "    o The values: \n"
        "          1:ACTION A \n"
        "          2:ACTION B \n"
        "          1:ACTION C \n"
        "          3:ACTION D \n"
        "      indicate two acceptable orders: A,C,B,D or C,A,B,D, \n"
        "      since A and C can be performed in either order, but \n"
        "      only at the '1' position. \n"
        "    o The values: \n"
        "          0:ACTION A \n"
        "          2:ACTION B \n"
        "          3:ACTION C \n"
        "          3:ACTION D \n"
        "      require that B,C, and D occur either as B,C,D or as \n"
        "      B,D,C.  Action A may appear at any point relative to \n"
        "      B, C, and D. Thus the complete set of acceptable \n"
        "      orders is:  A,B,C,D; B,A,C,D; B,C,A,D; B,C,D,A; \n"
        "      A,B,D,C; B,A,D,C; B,D,A,C; B,D,C,A. \n"
        "\n"
        "Note that the non-zero sequence numbers need not start with "
        "'1', and they need not be consecutive.  All that matters is "
        "their relative magnitude.") ]
    uint16 ActionOrder;
};
 

// ==================================================================
// PolicyActionInPolicyRule
// ==================================================================
   [Association, Aggregation, Version ("2.6.0"), Description (
   "A PolicyRule aggregates zero or more instances of the "
   "PolicyAction class, via the PolicyActionInPolicyRule "
   "association.  A Rule that aggregates zero Actions is not "
   "valid--it may, however, be in the process of being entered "
   "into a PolicyRepository or being defined for a System. "
   "Alternately, the actions of the policy may be explicit in "
   "the definition of the PolicyRule. Note that a PolicyRule "
   "should have no effect until it is valid. \n"
   "\n"
   "The Actions associated with a PolicyRule may be given a "
   "required order, a recommended order, or no order at all.  "
   "For Actions represented as separate objects, the "
   "PolicyActionInPolicyRule aggregation can be used to express "
   "an order. \n"
   "\n"
   "This aggregation does not indicate whether a specified "
   "action order is required, recommended, or of no "
   "significance; the property SequencedActions in the "
   "aggregating instance of PolicyRule provides this "
   "indication.") ]
class CIM_PolicyActionInPolicyRule : CIM_PolicyActionStructure {
        [Override ("GroupComponent"), Aggregate, Description (
        "This property represents the PolicyRule that "
        "contains one or more PolicyActions.") ]
    CIM_PolicyRule REF GroupComponent;
        [Override ("PartComponent"), Description (
        "This property holds the name of a PolicyAction "
        "contained by one or more PolicyRules.") ]
    CIM_PolicyAction REF PartComponent;
};
 

// ==================================================================
// PolicyActionInPolicyAction
// ==================================================================
   [Association, Aggregation, Version ("2.6.0"), Description (
   "PolicyActionInPolicyAction is used to represent the "
   "compounding of policy actions into a higher-level policy "
   "action.") ]
class CIM_PolicyActionInPolicyAction : CIM_PolicyActionStructure {
        [Override ("GroupComponent"), Aggregate, Description (
        "This property represents the CompoundPolicyAction that "
        "contains one or more PolicyActions.") ]
    CIM_CompoundPolicyAction REF GroupComponent;
        [Override ("PartComponent"), Description (
        "This property holds the name of a PolicyAction "
        "contained by one or more CompoundPolicyActions.") ]
    CIM_PolicyAction REF PartComponent;
};


// ==================================================================
// PolicyContainerInPolicyContainer
// ==================================================================
   [Association, Aggregation, Version ("2.6.0"), Description (
   "A relationship that aggregates one or more lower-level "
   "ReusablePolicyContainer instances into a higher-level "
   "ReusablePolicyContainer.") ]
class CIM_PolicyContainerInPolicyContainer: CIM_SystemComponent {
        [Override ("GroupComponent"), Aggregate, Description (
        "A ReusablePolicyContainer that aggregates other "
          "ReusablePolicyContainers.") ]
    CIM_ReusablePolicyContainer REF GroupComponent;
        [Override ("PartComponent"), Description (
        "A ReusablePolicyContainer aggregated by another "
        "ReusablePolicyContainer.") ]
    CIM_ReusablePolicyContainer REF PartComponent;
};


// ==================================================================
// PolicyRepositoryInPolicyRepository *** deprecated
// ==================================================================
   [Association, Aggregation, 
   DEPRECATED {"CIM_PolicyContainerInPolicyContainer"},
   Version ("2.6.0"), Description (
   "The term 'PolicyRepository' has been confusing to both "
   "developers and users of the model.  The replacement class "
   "name describes model element properly and is less likely "
   "to be confused with a data repository.  ContainedDomain is a "
   "general purpose mechanism for expressing domain hierarchy. \n"
   "\n"
   "A relationship that aggregates one or more lower-level "
   "PolicyRepositories into a higher-level Repository.") ]
class CIM_PolicyRepositoryInPolicyRepository : CIM_SystemComponent {
        [Override ("GroupComponent"), Aggregate, Description (
        "A PolicyRepository that aggregates other Repositories.") ]
    CIM_PolicyRepository REF GroupComponent;
        [Override ("PartComponent"), Description (
         "A PolicyRepository aggregated by another Repository.") ]
    CIM_PolicyRepository REF PartComponent;
};


// ==================================================================
// ReusablePolicy
// ==================================================================
   [Association, Version ("2.6.0"), Description (
   "The ReusablePolicy association provides for the reuse of any "
   "subclass of Policy in a ReusablePolicyContainer.") ]
class CIM_ReusablePolicy : CIM_PolicyInSystem {
        [Override ("Antecedent"), Max (1), Description (
        "This property identifies a ReusablePolicyContainer that "
          "provides the administrative scope for the reuse of the "
          "referenced policy element.") ]
    CIM_ReusablePolicyContainer REF Antecedent;
        [Override ("Dependent"), Description (
          "A reusable policy element.") ]
    CIM_Policy REF Dependent;
};


// ==================================================================
// PolicyConditionInPolicyRepository *** deprecated
// ==================================================================
   [Association, DEPRECATED {"CIM_ReusablePolicy"},
   Version ("2.6.0"), Description (
   "The ReusablePolicy association is a more general relationship "
   "that incorporates both Conditions and Actions as well as any "
   "other policy subclass. \n"
   "\n"  
   "A class representing the hosting of reusable "
   "PolicyConditions by a PolicyRepository. A reusable Policy"
   "Condition is always related to a single PolicyRepository, "
   "via this association. \n"
   "\n"
   "Note, that an instance of PolicyCondition can be either "
   "reusable or rule-specific.  When the Condition is rule-"
   "specific, it shall not be related to any "
   "PolicyRepository via the PolicyConditionInPolicyRepository "
   "association.") ]
class CIM_PolicyConditionInPolicyRepository : CIM_PolicyInSystem {
        [Override ("Antecedent"), Max (1), Description (
        "This property identifies a PolicyRepository "
        "hosting one or more PolicyConditions.  A reusable "
        "PolicyCondition is always related to exactly one "
        "PolicyRepository via the PolicyConditionInPolicyRepository "
        "association.  The [0..1] cardinality for this property "
        "covers the two types of PolicyConditions:  0 for a "
        "rule-specific PolicyCondition, 1 for a reusable one.") ]
    CIM_PolicyRepository REF Antecedent;
        [Override ("Dependent"), Description (
        "This property holds the name of a PolicyCondition"
        "hosted in the PolicyRepository.") ]
    CIM_PolicyCondition REF Dependent;
};


// ==================================================================
// PolicyActionInPolicyRepository *** deprecated
// ==================================================================
   [Association, DEPRECATED {"CIM_ReusablePolicy"},
   Version ("2.6.0"), Description (
   "The ReusablePolicy association is a more general relationship "
   "that incorporates both Conditions and Actions as well as any "
   "other policy subclass. \n"
   "\n"  
   "A class representing the hosting of reusable "
   "PolicyActions by a PolicyRepository. A reusable Policy"
   "Action is always related to a single PolicyRepository, "
   "via this association. \n"
   "\n"
   "Note, that an instance of PolicyAction can be either "
   "reusable or rule-specific.  When the Action is rule-"
   "specific, it shall not be related to any "
   "PolicyRepository via the PolicyActionInPolicyRepository "
   "association.") ]
class CIM_PolicyActionInPolicyRepository : CIM_PolicyInSystem {
        [Override ("Antecedent"), Max (1), Description (
        "This property represents a PolicyRepository "
        "hosting one or more PolicyActions.  A reusable "
        "PolicyAction is always related to exactly one "
        "PolicyRepository via the PolicyActionInPolicyRepository "
        "association.  The [0..1] cardinality for this property "
        "covers the two types of PolicyActions:  0 for a "
        "rule-specific PolicyAction, 1 for a reusable one.") ]
    CIM_PolicyRepository REF Antecedent;
        [Override ("Dependent"), Description (
        "This property holds the name of a PolicyAction"
        "hosted in the PolicyRepository.") ]
    CIM_PolicyAction REF Dependent;
};


// ===================================================================
// end of file
// ===================================================================
